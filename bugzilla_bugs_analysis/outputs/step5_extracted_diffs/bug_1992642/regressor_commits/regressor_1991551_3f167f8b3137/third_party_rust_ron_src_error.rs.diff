# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: third_party/rust/ron/src/error.rs
# Commit: 3f167f8b3137
# Full Hash: 3f167f8b313749f50f135e189e5854bef7ac0c73
# Author: Erich Gubler <erichdongubler@gmail.com>
# Date: 2025-10-03 18:08 +0000
# Regressor Bug: 1991551
# File Overlap Count: 23
# Overlapping Files: third_party/rust/wgpu-hal/Cargo.toml, supply-chain/audits.toml, third_party/rust/naga/src/back/spv/writer.rs, third_party/rust/naga/src/back/msl/writer.rs, third_party/rust/wgpu-types/src/lib.rs
# Description:
#   Bug 1991551 - build(webgpu): update WGPU to 8c4aebc0c1b75e3f7412dfc180745a0717fc30ec r=webgpu-reviewers,supply-chain-reviewers,nical
# ==============================================================================

diff -r 823439f307a0 -r 3f167f8b3137 third_party/rust/ron/src/error.rs
--- a/third_party/rust/ron/src/error.rs	Fri Oct 03 18:01:30 2025 +0000
+++ b/third_party/rust/ron/src/error.rs	Fri Oct 03 18:08:29 2025 +0000
@@ -1,25 +1,31 @@
-use std::{
-    error::Error as StdError,
-    fmt, io,
+use alloc::string::{String, ToString};
+use core::{
+    fmt,
     str::{self, Utf8Error},
 };
 
-use serde::{de, ser};
+use serde::{
+    de,
+    ser::{self, StdError},
+};
 use unicode_ident::is_xid_continue;
 
 use crate::parse::{is_ident_first_char, is_ident_raw_char};
 
+#[cfg(feature = "std")]
+use std::io;
+
 /// This type represents all possible errors that can occur when
 /// serializing or deserializing RON data.
 #[allow(clippy::module_name_repetitions)]
 #[derive(Clone, Debug, PartialEq, Eq)]
 pub struct SpannedError {
     pub code: Error,
-    pub position: Position,
+    pub span: Span,
 }
 
-pub type Result<T, E = Error> = std::result::Result<T, E>;
-pub type SpannedResult<T> = std::result::Result<T, SpannedError>;
+pub type Result<T, E = Error> = core::result::Result<T, E>;
+pub type SpannedResult<T> = core::result::Result<T, SpannedError>;
 
 #[derive(Clone, Debug, PartialEq, Eq)]
 #[non_exhaustive]
@@ -115,7 +121,7 @@
 
 impl fmt::Display for SpannedError {
     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
-        write!(f, "{}: {}", self.position, self.code)
+        write!(f, "{}: {}", self.span, self.code)
     }
 }
 
@@ -312,6 +318,25 @@
     }
 }
 
+#[derive(Clone, Debug, PartialEq, Eq)]
+/// Spans select a range of text between two positions.
+/// Spans are used in [`SpannedError`] to indicate the start and end positions
+/// of the parser cursor before and after it encountered an error in parsing.
+pub struct Span {
+    pub start: Position,
+    pub end: Position,
+}
+
+impl fmt::Display for Span {
+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
+        if self.start == self.end {
+            write!(f, "{}", self.start)
+        } else {
+            write!(f, "{}-{}", self.start, self.end)
+        }
+    }
+}
+
 impl ser::Error for Error {
     #[cold]
     fn custom<T: fmt::Display>(msg: T) -> Self {
@@ -346,7 +371,7 @@
                     de::Unexpected::Str(s) => write!(f, "the string {:?}", s),
                     de::Unexpected::Bytes(b) => write!(f, "the byte string b\"{}\"", {
                         b.iter()
-                            .flat_map(|c| std::ascii::escape_default(*c))
+                            .flat_map(|c| core::ascii::escape_default(*c))
                             .map(char::from)
                             .collect::<String>()
                     }),
@@ -409,6 +434,7 @@
 }
 
 impl StdError for SpannedError {}
+
 impl StdError for Error {}
 
 impl From<Utf8Error> for Error {
@@ -423,6 +449,7 @@
     }
 }
 
+#[cfg(feature = "std")]
 impl From<io::Error> for Error {
     fn from(e: io::Error) -> Self {
         Error::Io(e.to_string())
@@ -484,13 +511,16 @@
 
 #[cfg(test)]
 mod tests {
+    use alloc::{format, string::String};
+
     use serde::{de::Error as DeError, de::Unexpected, ser::Error as SerError};
 
-    use super::{Error, Position, SpannedError};
+    use super::{Error, Position, Span, SpannedError};
 
     #[test]
     fn error_messages() {
-        check_error_message(&Error::from(std::fmt::Error), "Formatting RON failed");
+        check_error_message(&Error::from(core::fmt::Error), "Formatting RON failed");
+        #[cfg(feature = "std")]
         check_error_message(
             &Error::from(std::io::Error::new(
                 std::io::ErrorKind::InvalidData,
@@ -576,7 +606,7 @@
         check_error_message(&Error::UnexpectedChar('ðŸ¦€'), "Unexpected char \'ðŸ¦€\'");
         #[allow(invalid_from_utf8)]
         check_error_message(
-            &Error::Utf8Error(std::str::from_utf8(b"error: \xff\xff\xff\xff").unwrap_err()),
+            &Error::Utf8Error(core::str::from_utf8(b"error: \xff\xff\xff\xff").unwrap_err()),
             "invalid utf-8 sequence of 1 bytes from index 7",
         );
         check_error_message(
@@ -679,7 +709,7 @@
         );
     }
 
-    fn check_error_message<T: std::fmt::Display>(err: &T, msg: &str) {
+    fn check_error_message<T: core::fmt::Display>(err: &T, msg: &str) {
         assert_eq!(format!("{}", err), msg);
     }
 
@@ -688,14 +718,20 @@
         assert_eq!(
             Error::from(SpannedError {
                 code: Error::Eof,
-                position: Position { line: 1, col: 1 }
+                span: Span {
+                    start: Position { line: 1, col: 1 },
+                    end: Position { line: 1, col: 5 },
+                }
             }),
             Error::Eof
         );
         assert_eq!(
             Error::from(SpannedError {
                 code: Error::ExpectedRawValue,
-                position: Position { line: 1, col: 1 }
+                span: Span {
+                    start: Position { line: 1, col: 1 },
+                    end: Position { line: 1, col: 5 },
+                }
             }),
             Error::ExpectedRawValue
         );