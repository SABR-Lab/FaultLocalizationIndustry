# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: third_party/rust/wgpu-core/src/command/mod.rs
# Commit: 3f167f8b3137
# Full Hash: 3f167f8b313749f50f135e189e5854bef7ac0c73
# Author: Erich Gubler <erichdongubler@gmail.com>
# Date: 2025-10-03 18:08 +0000
# Regressor Bug: 1991551
# File Overlap Count: 23
# Overlapping Files: third_party/rust/wgpu-hal/Cargo.toml, supply-chain/audits.toml, third_party/rust/naga/src/back/spv/writer.rs, third_party/rust/naga/src/back/msl/writer.rs, third_party/rust/wgpu-types/src/lib.rs
# Description:
#   Bug 1991551 - build(webgpu): update WGPU to 8c4aebc0c1b75e3f7412dfc180745a0717fc30ec r=webgpu-reviewers,supply-chain-reviewers,nical
# ==============================================================================

diff -r 823439f307a0 -r 3f167f8b3137 third_party/rust/wgpu-core/src/command/mod.rs
--- a/third_party/rust/wgpu-core/src/command/mod.rs	Fri Oct 03 18:01:30 2025 +0000
+++ b/third_party/rust/wgpu-core/src/command/mod.rs	Fri Oct 03 18:08:29 2025 +0000
@@ -1,3 +1,13 @@
+//! # Command Encoding
+//!
+//! TODO: High-level description of command encoding.
+//!
+//! The convention in this module is that functions accepting a [`&mut dyn
+//! hal::DynCommandEncoder`] are low-level helpers and may assume the encoder is
+//! in the open state, ready to encode commands. Encoders that are not open
+//! should be nested within some other container that provides additional
+//! state tracking, like [`InnerCommandEncoder`].
+
 mod allocator;
 mod bind;
 mod bundle;
@@ -19,22 +29,37 @@
 mod transition_resources;
 
 use alloc::{borrow::ToOwned as _, boxed::Box, string::String, sync::Arc, vec::Vec};
+use core::convert::Infallible;
 use core::mem::{self, ManuallyDrop};
 use core::ops;
 
 pub(crate) use self::clear::clear_texture;
 pub use self::{
-    bundle::*, clear::ClearError, compute::*, compute_command::ComputeCommand, draw::*,
-    encoder_command::Command, query::*, render::*, render_command::RenderCommand, transfer::*,
+    bundle::*,
+    clear::ClearError,
+    compute::*,
+    compute_command::{ArcComputeCommand, ComputeCommand},
+    draw::*,
+    encoder_command::{ArcCommand, Command},
+    query::*,
+    render::*,
+    render_command::{ArcRenderCommand, RenderCommand},
+    transfer::*,
 };
 pub(crate) use allocator::CommandAllocator;
 
 pub(crate) use timestamp_writes::ArcPassTimestampWrites;
 pub use timestamp_writes::PassTimestampWrites;
 
-use self::memory_init::CommandBufferTextureMemoryActions;
+use self::{
+    clear::{clear_buffer, clear_texture_cmd},
+    memory_init::CommandBufferTextureMemoryActions,
+    ray_tracing::build_acceleration_structures,
+    transition_resources::transition_resources,
+};
 
 use crate::binding_model::BindingError;
+use crate::command::encoder::EncodingState;
 use crate::command::transition_resources::TransitionResourcesError;
 use crate::device::queue::TempResource;
 use crate::device::{Device, DeviceError, MissingFeatures};
@@ -123,12 +148,21 @@
 }
 
 impl CommandEncoderStatus {
-    /// Record commands using the supplied closure.
+    #[cfg(feature = "trace")]
+    fn trace(&mut self) -> Option<&mut Vec<TraceCommand>> {
+        match self {
+            Self::Recording(cmd_buf_data) => cmd_buf_data.trace_commands.as_mut(),
+            _ => None,
+        }
+    }
+
+    /// Push a command provided by a closure onto the encoder.
     ///
     /// If the encoder is in the [`Self::Recording`] state, calls the closure to
-    /// record commands. If the closure returns an error, stores that error in
-    /// the encoder for later reporting when `finish()` is called. Returns
-    /// `Ok(())` even if the closure returned an error.
+    /// obtain a command, and pushes it onto the encoder. If the closure returns
+    /// an error, stores that error in the encoder for later reporting when
+    /// `finish()` is called. Returns `Ok(())` even if the closure returned an
+    /// error.
     ///
     /// If the encoder is not in the [`Self::Recording`] state, the closure will
     /// not be called and nothing will be recorded. The encoder will be
@@ -137,7 +171,51 @@
     /// returns `Ok(())`.
     ///
     /// [ves]: https://www.w3.org/TR/webgpu/#abstract-opdef-validate-the-encoder-state
-    fn record_with<
+    fn push_with<F: FnOnce() -> Result<ArcCommand, E>, E: Clone + Into<CommandEncoderError>>(
+        &mut self,
+        f: F,
+    ) -> Result<(), EncoderStateError> {
+        match self {
+            Self::Recording(cmd_buf_data) => {
+                match f() {
+                    Ok(cmd) => cmd_buf_data.commands.push(cmd),
+                    Err(err) => {
+                        self.invalidate(err);
+                    }
+                }
+                Ok(())
+            }
+            Self::Locked(_) => {
+                // Invalidate the encoder and do not record anything, but do not
+                // return an immediate validation error.
+                self.invalidate(EncoderStateError::Locked);
+                Ok(())
+            }
+            // Encoder is ended. Invalidate the encoder, do not record anything,
+            // and return an immediate validation error.
+            Self::Finished(_) => Err(self.invalidate(EncoderStateError::Ended)),
+            Self::Consumed => Err(EncoderStateError::Ended),
+            // Encoder is already invalid. Do not record anything, but do not
+            // return an immediate validation error.
+            Self::Error(_) => Ok(()),
+            Self::Transitioning => unreachable!(),
+        }
+    }
+
+    /// Call a closure with the inner command buffer structure.
+    ///
+    /// If the encoder is in the [`Self::Recording`] state, calls the provided
+    /// closure. If the closure returns an error, stores that error in the
+    /// encoder for later reporting when `finish()` is called. Returns `Ok(())`
+    /// even if the closure returned an error.
+    ///
+    /// If the encoder is not in the [`Self::Recording`] state, the closure will
+    /// not be called. The encoder will be invalidated (if it is not already).
+    /// If the error is a [validation error that should be raised
+    /// immediately][ves], returns it in `Err`, otherwise, returns `Ok(())`.
+    ///
+    /// [ves]: https://www.w3.org/TR/webgpu/#abstract-opdef-validate-the-encoder-state
+    fn with_buffer<
         F: FnOnce(&mut CommandBufferMutable) -> Result<(), E>,
         E: Clone + Into<CommandEncoderError>,
     >(
@@ -193,7 +271,7 @@
         }
     }
 
-    #[cfg(feature = "trace")]
+    #[cfg(all(feature = "trace", any(feature = "serde", feature = "replay")))]
     fn get_inner(&mut self) -> &mut CommandBufferMutable {
         match self {
             Self::Locked(inner) | Self::Finished(inner) | Self::Recording(inner) => inner,
@@ -210,7 +288,7 @@
     /// Locks the encoder by putting it in the [`Self::Locked`] state.
     ///
     /// Render or compute passes call this on start. At the end of the pass,
-    /// they call [`Self::unlock_and_record`] to put the [`CommandBuffer`] back
+    /// they call [`Self::unlock_encoder`] to put the [`CommandBuffer`] back
     /// into the [`Self::Recording`] state.
     fn lock_encoder(&mut self) -> Result<(), EncoderStateError> {
         match mem::replace(self, Self::Transitioning) {
@@ -238,32 +316,19 @@
         }
     }
 
-    /// Unlocks the [`CommandBuffer`] and puts it back into the
-    /// [`Self::Recording`] state, then records commands using the supplied
-    /// closure.
+    /// Unlocks the encoder and puts it back into the [`Self::Recording`] state.
     ///
     /// This function is the unlocking counterpart to [`Self::lock_encoder`]. It
     /// is only valid to call this function if the encoder is in the
     /// [`Self::Locked`] state.
     ///
-    /// If the closure returns an error, stores that error in the encoder for
-    /// later reporting when `finish()` is called. Returns `Ok(())` even if the
-    /// closure returned an error.
-    ///
-    /// If the encoder is not in the [`Self::Locked`] state, the closure will
-    /// not be called and nothing will be recorded. If a validation error should
-    /// be raised immediately, returns it in `Err`, otherwise, returns `Ok(())`.
-    fn unlock_and_record<
-        F: FnOnce(&mut CommandBufferMutable) -> Result<(), E>,
-        E: Clone + Into<CommandEncoderError>,
-    >(
-        &mut self,
-        f: F,
-    ) -> Result<(), EncoderStateError> {
+    /// If the encoder is in a state other than [`Self::Locked`] and a
+    /// validation error should be raised immediately, returns it in `Err`,
+    /// otherwise, stores the error in the encoder and returns `Ok(())`.
+    fn unlock_encoder(&mut self) -> Result<(), EncoderStateError> {
         match mem::replace(self, Self::Transitioning) {
             Self::Locked(inner) => {
                 *self = Self::Recording(inner);
-                RecordingGuard { inner: self }.record(f);
                 Ok(())
             }
             st @ Self::Finished(_) => {
@@ -279,8 +344,8 @@
                 Err(EncoderStateError::Ended)
             }
             st @ Self::Error(_) => {
-                // Encoder is invalid. Do not record anything, but do not
-                // return an immediate validation error.
+                // Encoder is already invalid. The error will be reported by
+                // `CommandEncoder.finish`.
                 *self = st;
                 Ok(())
             }
@@ -292,18 +357,10 @@
         // Replace our state with `Consumed`, and return either the inner
         // state or an error, to be transferred to the command buffer.
         match mem::replace(self, Self::Consumed) {
-            Self::Recording(mut inner) => {
-                if let Err(err) = inner.encoder.close_if_open() {
-                    Self::Error(err.into())
-                } else if inner.debug_scope_depth > 0 {
-                    Self::Error(CommandEncoderError::DebugGroupError(
-                        DebugGroupError::MissingPop,
-                    ))
-                } else {
-                    // Note: if we want to stop tracking the swapchain texture view,
-                    // this is the place to do it.
-                    Self::Finished(inner)
-                }
+            Self::Recording(inner) => {
+                // Nothing should have opened the encoder yet.
+                assert!(!inner.encoder.is_open);
+                Self::Finished(inner)
             }
             Self::Consumed | Self::Finished(_) => Self::Error(EncoderStateError::Ended.into()),
             Self::Locked(_) => Self::Error(EncoderStateError::Locked.into()),
@@ -574,6 +631,22 @@
         Ok(())
     }
 
+    /// If the command encoder is not open, begin recording a new command buffer.
+    ///
+    /// If the command encoder was already open, does nothing.
+    ///
+    /// In both cases, returns a reference to the raw encoder.
+    fn open_if_closed(&mut self) -> Result<&mut dyn hal::DynCommandEncoder, DeviceError> {
+        if !self.is_open {
+            self.is_open = true;
+            let hal_label = hal_label(Some(self.label.as_str()), self.device.instance_flags);
+            unsafe { self.raw.begin_encoding(hal_label) }
+                .map_err(|e| self.device.handle_hal_error(e))?;
+        }
+
+        Ok(self.raw.as_mut())
+    }
+
     /// Begin recording a new command buffer, if we haven't already.
     ///
     /// The underlying hal encoder is put in the "recording" state.
@@ -588,7 +661,7 @@
         Ok(self.raw.as_mut())
     }
 
-    /// Begin recording a new command buffer for a render pass, with
+    /// Begin recording a new command buffer for a render or compute pass, with
     /// its own label.
     ///
     /// The underlying hal encoder is put in the "recording" state.
@@ -661,22 +734,13 @@
 
     indirect_draw_validation_resources: crate::indirect_validation::DrawResources,
 
-    debug_scope_depth: u32,
+    pub(crate) commands: Vec<ArcCommand>,
 
     #[cfg(feature = "trace")]
     pub(crate) trace_commands: Option<Vec<TraceCommand>>,
 }
 
 impl CommandBufferMutable {
-    pub(crate) fn open_encoder_and_tracker(
-        &mut self,
-    ) -> Result<(&mut dyn hal::DynCommandEncoder, &mut Tracker), DeviceError> {
-        let encoder = self.encoder.open()?;
-        let tracker = &mut self.trackers;
-
-        Ok((encoder, tracker))
-    }
-
     pub(crate) fn into_baked_commands(self) -> BakedCommands {
         BakedCommands {
             encoder: self.encoder,
@@ -735,7 +799,7 @@
                     temp_resources: Default::default(),
                     indirect_draw_validation_resources:
                         crate::indirect_validation::DrawResources::new(device.clone()),
-                    debug_scope_depth: 0,
+                    commands: Vec::new(),
                     #[cfg(feature = "trace")]
                     trace_commands: if device.trace.lock().is_some() {
                         Some(Vec::new())
@@ -883,6 +947,10 @@
     pub error: Option<E>,
 
     /// The stream of commands.
+    ///
+    /// The commands are moved out of this vector when the pass is ended (i.e.
+    /// at the same time that `parent` is taken out of the
+    /// `ComputePass`/`RenderPass`).
     pub commands: Vec<C>,
 
     /// Dynamic offsets consumed by [`SetBindGroup`] commands in `commands`.
@@ -926,6 +994,26 @@
             push_constant_data: Vec::new(),
         }
     }
+
+    /// Takes the commands from the pass, or returns an error if the pass is
+    /// invalid.
+    ///
+    /// This is called when the pass is ended, at the same time that the
+    /// `parent` member of the `ComputePass` or `RenderPass` containing the pass
+    /// is taken.
+    fn take(&mut self) -> Result<BasePass<C, Infallible>, E> {
+        match self.error.as_ref() {
+            Some(err) => Err(err.clone()),
+            None => Ok(BasePass {
+                label: self.label.clone(),
+                error: None,
+                commands: mem::take(&mut self.commands),
+                dynamic_offsets: mem::take(&mut self.dynamic_offsets),
+                string_data: mem::take(&mut self.string_data),
+                push_constant_data: mem::take(&mut self.push_constant_data),
+            }),
+        }
+    }
 }
 
 /// Checks the state of a [`compute::ComputePass`] or [`render::RenderPass`] and
@@ -1169,20 +1257,21 @@
         &self,
         buffer_id: Id<id::markers::Buffer>,
     ) -> Result<Arc<crate::resource::Buffer>, InvalidResourceError> {
-        let hub = &self.hub;
-        let buffer = hub.buffers.get(buffer_id).get()?;
+        self.hub.buffers.get(buffer_id).get()
+    }
 
-        Ok(buffer)
+    fn resolve_texture_id(
+        &self,
+        texture_id: Id<id::markers::Texture>,
+    ) -> Result<Arc<crate::resource::Texture>, InvalidResourceError> {
+        self.hub.textures.get(texture_id).get()
     }
 
     fn resolve_query_set(
         &self,
         query_set_id: Id<id::markers::QuerySet>,
     ) -> Result<Arc<QuerySet>, InvalidResourceError> {
-        let hub = &self.hub;
-        let query_set = hub.query_sets.get(query_set_id).get()?;
-
-        Ok(query_set)
+        self.hub.query_sets.get(query_set_id).get()
     }
 
     pub fn command_encoder_finish(
@@ -1196,14 +1285,196 @@
         let hub = &self.hub;
 
         let cmd_enc = hub.command_encoders.get(encoder_id);
+        let mut cmd_enc_status = cmd_enc.data.lock();
 
-        let data = cmd_enc.data.lock().finish();
+        let res = match cmd_enc_status.finish() {
+            CommandEncoderStatus::Finished(cmd_buf_data) => Ok(cmd_buf_data),
+            CommandEncoderStatus::Error(err) => Err(err),
+            _ => unreachable!(),
+        };
+
+        let res = res.and_then(|mut cmd_buf_data| {
+            cmd_enc.device.check_is_valid()?;
+            let snatch_guard = cmd_enc.device.snatchable_lock.read();
+            let mut debug_scope_depth = 0;
+
+            let mut commands = mem::take(&mut cmd_buf_data.commands);
+            for command in commands.drain(..) {
+                if matches!(
+                    command,
+                    ArcCommand::RunRenderPass { .. } | ArcCommand::RunComputePass { .. }
+                ) {
+                    // Compute passes and render passes can accept either an
+                    // open or closed encoder. This state object holds an
+                    // `InnerCommandEncoder`. See the documentation of
+                    // [`EncodingState`].
+                    let mut state = EncodingState {
+                        device: &cmd_enc.device,
+                        raw_encoder: &mut cmd_buf_data.encoder,
+                        tracker: &mut cmd_buf_data.trackers,
+                        buffer_memory_init_actions: &mut cmd_buf_data.buffer_memory_init_actions,
+                        texture_memory_actions: &mut cmd_buf_data.texture_memory_actions,
+                        as_actions: &mut cmd_buf_data.as_actions,
+                        temp_resources: &mut cmd_buf_data.temp_resources,
+                        indirect_draw_validation_resources: &mut cmd_buf_data
+                            .indirect_draw_validation_resources,
+                        snatch_guard: &snatch_guard,
+                        debug_scope_depth: &mut debug_scope_depth,
+                    };
 
-        // Errors related to destroyed resources are not reported until the
-        // command buffer is submitted.
-        let error = match data {
-            CommandEncoderStatus::Error(ref e) if !e.is_destroyed_error() => Some(e.clone()),
-            _ => None,
+                    match command {
+                        ArcCommand::RunRenderPass {
+                            pass,
+                            color_attachments,
+                            depth_stencil_attachment,
+                            timestamp_writes,
+                            occlusion_query_set,
+                        } => {
+                            encode_render_pass(
+                                &mut state,
+                                pass,
+                                color_attachments,
+                                depth_stencil_attachment,
+                                timestamp_writes,
+                                occlusion_query_set,
+                            )?;
+                        }
+                        ArcCommand::RunComputePass {
+                            pass,
+                            timestamp_writes,
+                        } => {
+                            encode_compute_pass(&mut state, pass, timestamp_writes)?;
+                        }
+                        _ => unreachable!(),
+                    }
+                } else {
+                    // All the other non-pass encoding routines assume the
+                    // encoder is open, so open it if necessary. This state
+                    // object holds an `&mut dyn hal::DynCommandEncoder`. By
+                    // convention, a bare HAL encoder reference in
+                    // [`EncodingState`] must always be an open encoder.
+                    let raw_encoder = cmd_buf_data.encoder.open_if_closed()?;
+                    let mut state = EncodingState {
+                        device: &cmd_enc.device,
+                        raw_encoder,
+                        tracker: &mut cmd_buf_data.trackers,
+                        buffer_memory_init_actions: &mut cmd_buf_data.buffer_memory_init_actions,
+                        texture_memory_actions: &mut cmd_buf_data.texture_memory_actions,
+                        as_actions: &mut cmd_buf_data.as_actions,
+                        temp_resources: &mut cmd_buf_data.temp_resources,
+                        indirect_draw_validation_resources: &mut cmd_buf_data
+                            .indirect_draw_validation_resources,
+                        snatch_guard: &snatch_guard,
+                        debug_scope_depth: &mut debug_scope_depth,
+                    };
+                    match command {
+                        ArcCommand::CopyBufferToBuffer {
+                            src,
+                            src_offset,
+                            dst,
+                            dst_offset,
+                            size,
+                        } => {
+                            copy_buffer_to_buffer(
+                                &mut state, &src, src_offset, &dst, dst_offset, size,
+                            )?;
+                        }
+                        ArcCommand::CopyBufferToTexture { src, dst, size } => {
+                            copy_buffer_to_texture(&mut state, &src, &dst, &size)?;
+                        }
+                        ArcCommand::CopyTextureToBuffer { src, dst, size } => {
+                            copy_texture_to_buffer(&mut state, &src, &dst, &size)?;
+                        }
+                        ArcCommand::CopyTextureToTexture { src, dst, size } => {
+                            copy_texture_to_texture(&mut state, &src, &dst, &size)?;
+                        }
+                        ArcCommand::ClearBuffer { dst, offset, size } => {
+                            clear_buffer(&mut state, dst, offset, size)?;
+                        }
+                        ArcCommand::ClearTexture {
+                            dst,
+                            subresource_range,
+                        } => {
+                            clear_texture_cmd(&mut state, dst, &subresource_range)?;
+                        }
+                        ArcCommand::WriteTimestamp {
+                            query_set,
+                            query_index,
+                        } => {
+                            write_timestamp(&mut state, query_set, query_index)?;
+                        }
+                        ArcCommand::ResolveQuerySet {
+                            query_set,
+                            start_query,
+                            query_count,
+                            destination,
+                            destination_offset,
+                        } => {
+                            resolve_query_set(
+                                &mut state,
+                                query_set,
+                                start_query,
+                                query_count,
+                                destination,
+                                destination_offset,
+                            )?;
+                        }
+                        ArcCommand::PushDebugGroup(label) => {
+                            push_debug_group(&mut state, &label)?;
+                        }
+                        ArcCommand::PopDebugGroup => {
+                            pop_debug_group(&mut state)?;
+                        }
+                        ArcCommand::InsertDebugMarker(label) => {
+                            insert_debug_marker(&mut state, &label)?;
+                        }
+                        ArcCommand::BuildAccelerationStructures { blas, tlas } => {
+                            build_acceleration_structures(&mut state, blas, tlas)?;
+                        }
+                        ArcCommand::TransitionResources {
+                            buffer_transitions,
+                            texture_transitions,
+                        } => {
+                            transition_resources(
+                                &mut state,
+                                buffer_transitions,
+                                texture_transitions,
+                            )?;
+                        }
+                        ArcCommand::RunComputePass { .. } | ArcCommand::RunRenderPass { .. } => {
+                            unreachable!()
+                        }
+                    }
+                }
+            }
+
+            if debug_scope_depth > 0 {
+                Err(CommandEncoderError::DebugGroupError(
+                    DebugGroupError::MissingPop,
+                ))?;
+            }
+
+            // Close the encoder, unless it was closed already by a render or compute pass.
+            cmd_buf_data.encoder.close_if_open()?;
+
+            // Note: if we want to stop tracking the swapchain texture view,
+            // this is the place to do it.
+
+            Ok(cmd_buf_data)
+        });
+
+        let (data, error) = match res {
+            Err(e) => {
+                if e.is_destroyed_error() {
+                    // Errors related to destroyed resources are not reported until the
+                    // command buffer is submitted.
+                    (CommandEncoderStatus::Error(e.clone()), None)
+                } else {
+                    (CommandEncoderStatus::Error(e.clone()), Some(e))
+                }
+            }
+
+            Ok(data) => (CommandEncoderStatus::Finished(data), None),
         };
 
         let cmd_buf = CommandBuffer {
@@ -1229,8 +1500,14 @@
 
         let cmd_enc = hub.command_encoders.get(encoder_id);
         let mut cmd_buf_data = cmd_enc.data.lock();
-        cmd_buf_data.record_with(|cmd_buf_data| -> Result<(), CommandEncoderError> {
-            push_debug_group(cmd_buf_data, &cmd_enc, label)
+
+        #[cfg(feature = "trace")]
+        if let Some(ref mut list) = cmd_buf_data.trace() {
+            list.push(TraceCommand::PushDebugGroup(label.to_owned()));
+        }
+
+        cmd_buf_data.push_with(|| -> Result<_, CommandEncoderError> {
+            Ok(ArcCommand::PushDebugGroup(label.to_owned()))
         })
     }
 
@@ -1246,8 +1523,14 @@
 
         let cmd_enc = hub.command_encoders.get(encoder_id);
         let mut cmd_buf_data = cmd_enc.data.lock();
-        cmd_buf_data.record_with(|cmd_buf_data| -> Result<(), CommandEncoderError> {
-            insert_debug_marker(cmd_buf_data, &cmd_enc, label)
+
+        #[cfg(feature = "trace")]
+        if let Some(ref mut list) = cmd_buf_data.trace() {
+            list.push(TraceCommand::InsertDebugMarker(label.to_owned()));
+        }
+
+        cmd_buf_data.push_with(|| -> Result<_, CommandEncoderError> {
+            Ok(ArcCommand::InsertDebugMarker(label.to_owned()))
         })
     }
 
@@ -1262,9 +1545,14 @@
 
         let cmd_enc = hub.command_encoders.get(encoder_id);
         let mut cmd_buf_data = cmd_enc.data.lock();
-        cmd_buf_data.record_with(|cmd_buf_data| -> Result<(), CommandEncoderError> {
-            pop_debug_group(cmd_buf_data, &cmd_enc)
-        })
+
+        #[cfg(feature = "trace")]
+        if let Some(ref mut list) = cmd_buf_data.trace() {
+            list.push(TraceCommand::PopDebugGroup);
+        }
+
+        cmd_buf_data
+            .push_with(|| -> Result<_, CommandEncoderError> { Ok(ArcCommand::PopDebugGroup) })
     }
 
     fn validate_pass_timestamp_writes<E>(
@@ -1320,84 +1608,49 @@
 }
 
 pub(crate) fn push_debug_group(
-    cmd_buf_data: &mut CommandBufferMutable,
-    cmd_enc: &Arc<CommandEncoder>,
+    state: &mut EncodingState,
     label: &str,
 ) -> Result<(), CommandEncoderError> {
-    cmd_buf_data.debug_scope_depth += 1;
+    *state.debug_scope_depth += 1;
 
-    #[cfg(feature = "trace")]
-    if let Some(ref mut list) = cmd_buf_data.trace_commands {
-        list.push(TraceCommand::PushDebugGroup(label.to_owned()));
-    }
-
-    cmd_enc.device.check_is_valid()?;
-
-    let cmd_buf_raw = cmd_buf_data.encoder.open()?;
-    if !cmd_enc
+    if !state
         .device
         .instance_flags
         .contains(wgt::InstanceFlags::DISCARD_HAL_LABELS)
     {
-        unsafe {
-            cmd_buf_raw.begin_debug_marker(label);
-        }
+        unsafe { state.raw_encoder.begin_debug_marker(label) };
     }
 
     Ok(())
 }
 
 pub(crate) fn insert_debug_marker(
-    cmd_buf_data: &mut CommandBufferMutable,
-    cmd_enc: &Arc<CommandEncoder>,
+    state: &mut EncodingState,
     label: &str,
 ) -> Result<(), CommandEncoderError> {
-    #[cfg(feature = "trace")]
-    if let Some(ref mut list) = cmd_buf_data.trace_commands {
-        list.push(TraceCommand::InsertDebugMarker(label.to_owned()));
-    }
-
-    cmd_enc.device.check_is_valid()?;
-
-    if !cmd_enc
+    if !state
         .device
         .instance_flags
         .contains(wgt::InstanceFlags::DISCARD_HAL_LABELS)
     {
-        let cmd_buf_raw = cmd_buf_data.encoder.open()?;
-        unsafe {
-            cmd_buf_raw.insert_debug_marker(label);
-        }
+        unsafe { state.raw_encoder.insert_debug_marker(label) };
     }
 
     Ok(())
 }
 
-pub(crate) fn pop_debug_group(
-    cmd_buf_data: &mut CommandBufferMutable,
-    cmd_enc: &Arc<CommandEncoder>,
-) -> Result<(), CommandEncoderError> {
-    if cmd_buf_data.debug_scope_depth == 0 {
+pub(crate) fn pop_debug_group(state: &mut EncodingState) -> Result<(), CommandEncoderError> {
+    if *state.debug_scope_depth == 0 {
         return Err(DebugGroupError::InvalidPop.into());
     }
-    cmd_buf_data.debug_scope_depth -= 1;
+    *state.debug_scope_depth -= 1;
 
-    #[cfg(feature = "trace")]
-    if let Some(ref mut list) = cmd_buf_data.trace_commands {
-        list.push(TraceCommand::PopDebugGroup);
-    }
-
-    cmd_enc.device.check_is_valid()?;
-
-    let cmd_buf_raw = cmd_buf_data.encoder.open()?;
-    if !cmd_enc
+    if !state
         .device
         .instance_flags
         .contains(wgt::InstanceFlags::DISCARD_HAL_LABELS)
     {
-        unsafe {
-            cmd_buf_raw.end_debug_marker();
-        }
+        unsafe { state.raw_encoder.end_debug_marker() };
     }
 
     Ok(())