# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: third_party/rust/wgpu-core/src/command/ray_tracing.rs
# Commit: 3f167f8b3137
# Full Hash: 3f167f8b313749f50f135e189e5854bef7ac0c73
# Author: Erich Gubler <erichdongubler@gmail.com>
# Date: 2025-10-03 18:08 +0000
# Regressor Bug: 1991551
# File Overlap Count: 23
# Overlapping Files: third_party/rust/wgpu-hal/Cargo.toml, supply-chain/audits.toml, third_party/rust/naga/src/back/spv/writer.rs, third_party/rust/naga/src/back/msl/writer.rs, third_party/rust/wgpu-types/src/lib.rs
# Description:
#   Bug 1991551 - build(webgpu): update WGPU to 8c4aebc0c1b75e3f7412dfc180745a0717fc30ec r=webgpu-reviewers,supply-chain-reviewers,nical
# ==============================================================================

diff -r 823439f307a0 -r 3f167f8b3137 third_party/rust/wgpu-core/src/command/ray_tracing.rs
--- a/third_party/rust/wgpu-core/src/command/ray_tracing.rs	Fri Oct 03 18:01:30 2025 +0000
+++ b/third_party/rust/wgpu-core/src/command/ray_tracing.rs	Fri Oct 03 18:08:29 2025 +0000
@@ -1,4 +1,4 @@
-use alloc::{boxed::Box, sync::Arc, vec::Vec};
+use alloc::{sync::Arc, vec::Vec};
 use core::{
     cmp::max,
     num::NonZeroU64,
@@ -11,34 +11,39 @@
     command::CommandBufferMutable,
     device::queue::TempResource,
     global::Global,
-    hub::Hub,
     id::CommandEncoderId,
     init_tracker::MemoryInitKind,
     ray_tracing::{
-        BlasBuildEntry, BlasGeometries, BlasTriangleGeometry, BuildAccelerationStructureError,
-        TlasInstance, TlasPackage, TraceBlasBuildEntry, TraceBlasGeometries,
-        TraceBlasTriangleGeometry, TraceTlasInstance, TraceTlasPackage,
+        BlasBuildEntry, BlasGeometries, BuildAccelerationStructureError, TlasPackage,
+        TraceBlasBuildEntry, TraceBlasGeometries, TraceBlasTriangleGeometry, TraceTlasInstance,
+        TraceTlasPackage,
     },
     resource::{Blas, BlasCompactState, Buffer, Labeled, StagingBuffer, Tlas},
     scratch::ScratchBuffer,
     snatch::SnatchGuard,
     track::PendingTransition,
 };
+use crate::{command::EncoderStateError, device::resource::CommandIndices};
 use crate::{
-    command::CommandEncoder,
-    ray_tracing::{AsAction, AsBuild, TlasBuild, ValidateAsActionsError},
+    command::{encoder::EncodingState, ArcCommand},
+    ray_tracing::{
+        ArcBlasBuildEntry, ArcBlasGeometries, ArcBlasTriangleGeometry, ArcTlasInstance,
+        ArcTlasPackage, AsAction, AsBuild, BlasTriangleGeometryInfo, TlasBuild,
+        ValidateAsActionsError,
+    },
+    resource::InvalidResourceError,
+    track::Tracker,
 };
-use crate::{command::EncoderStateError, device::resource::CommandIndices};
 use crate::{lock::RwLockWriteGuard, resource::RawResourceAccess};
 
 use crate::id::{BlasId, TlasId};
 
-struct TriangleBufferStore<'a> {
+struct TriangleBufferStore {
     vertex_buffer: Arc<Buffer>,
     vertex_transition: Option<PendingTransition<BufferUses>>,
     index_buffer_transition: Option<(Arc<Buffer>, Option<PendingTransition<BufferUses>>)>,
     transform_buffer_transition: Option<(Arc<Buffer>, Option<PendingTransition<BufferUses>>)>,
-    geometry: BlasTriangleGeometry<'a>,
+    geometry: BlasTriangleGeometryInfo,
     ending_blas: Option<Arc<Blas>>,
 }
 
@@ -60,6 +65,14 @@
 }
 
 impl Global {
+    fn resolve_blas_id(&self, blas_id: BlasId) -> Result<Arc<Blas>, InvalidResourceError> {
+        self.hub.blas_s.get(blas_id).get()
+    }
+
+    fn resolve_tlas_id(&self, tlas_id: TlasId) -> Result<Arc<Tlas>, InvalidResourceError> {
+        self.hub.tlas_s.get(tlas_id).get()
+    }
+
     pub fn command_encoder_mark_acceleration_structures_built(
         &self,
         command_encoder_id: CommandEncoderId,
@@ -73,7 +86,7 @@
         let cmd_enc = hub.command_encoders.get(command_encoder_id);
 
         let mut cmd_buf_data = cmd_enc.data.lock();
-        cmd_buf_data.record_with(
+        cmd_buf_data.with_buffer(
             |cmd_buf_data| -> Result<(), BuildAccelerationStructureError> {
                 let device = &cmd_enc.device;
                 device.check_is_valid()?;
@@ -161,115 +174,118 @@
             .collect();
 
         let mut cmd_buf_data = cmd_enc.data.lock();
-        cmd_buf_data.record_with(|cmd_buf_data| {
-            let blas_iter = trace_blas.iter().map(|blas_entry| {
-                let geometries = match &blas_entry.geometries {
-                    TraceBlasGeometries::TriangleGeometries(triangle_geometries) => {
-                        let iter = triangle_geometries.iter().map(|tg| BlasTriangleGeometry {
-                            size: &tg.size,
-                            vertex_buffer: tg.vertex_buffer,
-                            index_buffer: tg.index_buffer,
-                            transform_buffer: tg.transform_buffer,
-                            first_vertex: tg.first_vertex,
-                            vertex_stride: tg.vertex_stride,
-                            first_index: tg.first_index,
-                            transform_buffer_offset: tg.transform_buffer_offset,
-                        });
-                        BlasGeometries::TriangleGeometries(Box::new(iter))
-                    }
-                };
-                BlasBuildEntry {
-                    blas_id: blas_entry.blas_id,
-                    geometries,
-                }
+
+        #[cfg(feature = "trace")]
+        if let Some(ref mut list) = cmd_buf_data.trace() {
+            list.push(crate::command::Command::BuildAccelerationStructures {
+                blas: trace_blas.clone(),
+                tlas: trace_tlas.clone(),
             });
+        }
 
-            let tlas_iter = trace_tlas.iter().map(|tlas_package| {
-                let instances = tlas_package.instances.iter().map(|instance| {
-                    instance.as_ref().map(|instance| TlasInstance {
-                        blas_id: instance.blas_id,
-                        transform: &instance.transform,
-                        custom_data: instance.custom_data,
-                        mask: instance.mask,
+        cmd_buf_data.push_with(|| -> Result<_, BuildAccelerationStructureError> {
+            let blas = trace_blas
+                .iter()
+                .map(|blas_entry| {
+                    let geometries = match &blas_entry.geometries {
+                        TraceBlasGeometries::TriangleGeometries(triangle_geometries) => {
+                            let tri_geo = triangle_geometries
+                                .iter()
+                                .map(|tg| {
+                                    Ok(ArcBlasTriangleGeometry {
+                                        size: tg.size.clone(),
+                                        vertex_buffer: self.resolve_buffer_id(tg.vertex_buffer)?,
+                                        index_buffer: tg
+                                            .index_buffer
+                                            .map(|id| self.resolve_buffer_id(id))
+                                            .transpose()?,
+                                        transform_buffer: tg
+                                            .transform_buffer
+                                            .map(|id| self.resolve_buffer_id(id))
+                                            .transpose()?,
+                                        first_vertex: tg.first_vertex,
+                                        vertex_stride: tg.vertex_stride,
+                                        first_index: tg.first_index,
+                                        transform_buffer_offset: tg.transform_buffer_offset,
+                                    })
+                                })
+                                .collect::<Result<_, BuildAccelerationStructureError>>()?;
+                            ArcBlasGeometries::TriangleGeometries(tri_geo)
+                        }
+                    };
+                    Ok(ArcBlasBuildEntry {
+                        blas: self.resolve_blas_id(blas_entry.blas_id)?,
+                        geometries,
                     })
-                });
-                TlasPackage {
-                    tlas_id: tlas_package.tlas_id,
-                    instances: Box::new(instances),
-                    lowest_unmodified: tlas_package.lowest_unmodified,
-                }
-            });
+                })
+                .collect::<Result<_, BuildAccelerationStructureError>>()?;
 
-            build_acceleration_structures(
-                cmd_buf_data,
-                hub,
-                &cmd_enc,
-                trace_blas.clone(),
-                trace_tlas.clone(),
-                blas_iter,
-                tlas_iter,
-            )
+            let tlas = trace_tlas
+                .iter()
+                .map(|tlas_package| {
+                    let instances = tlas_package
+                        .instances
+                        .iter()
+                        .map(|instance| {
+                            instance
+                                .as_ref()
+                                .map(|instance| {
+                                    Ok(ArcTlasInstance {
+                                        blas: self.resolve_blas_id(instance.blas_id)?,
+                                        transform: instance.transform,
+                                        custom_data: instance.custom_data,
+                                        mask: instance.mask,
+                                    })
+                                })
+                                .transpose()
+                        })
+                        .collect::<Result<_, BuildAccelerationStructureError>>()?;
+                    Ok(ArcTlasPackage {
+                        tlas: self.resolve_tlas_id(tlas_package.tlas_id)?,
+                        instances,
+                        lowest_unmodified: tlas_package.lowest_unmodified,
+                    })
+                })
+                .collect::<Result<_, BuildAccelerationStructureError>>()?;
+
+            Ok(ArcCommand::BuildAccelerationStructures { blas, tlas })
         })
     }
 }
 
-pub(crate) fn build_acceleration_structures<'a>(
-    cmd_buf_data: &'a mut CommandBufferMutable,
-    hub: &'a Hub,
-    cmd_enc: &'a Arc<CommandEncoder>,
-    trace_blas: Vec<TraceBlasBuildEntry>,
-    trace_tlas: Vec<TraceTlasPackage>,
-    blas_iter: impl Iterator<Item = BlasBuildEntry<'a>>,
-    tlas_iter: impl Iterator<Item = TlasPackage<'a>>,
+pub(crate) fn build_acceleration_structures(
+    state: &mut EncodingState,
+    blas: Vec<ArcBlasBuildEntry>,
+    tlas: Vec<ArcTlasPackage>,
 ) -> Result<(), BuildAccelerationStructureError> {
-    #[cfg(feature = "trace")]
-    if let Some(ref mut list) = cmd_buf_data.trace_commands {
-        list.push(crate::command::Command::BuildAccelerationStructures {
-            blas: trace_blas,
-            tlas: trace_tlas,
-        });
-    }
-    #[cfg(not(feature = "trace"))]
-    {
-        let _ = trace_blas;
-        let _ = trace_tlas;
-    }
-
-    let device = &cmd_enc.device;
-    device.check_is_valid()?;
-    device.require_features(Features::EXPERIMENTAL_RAY_QUERY)?;
+    state
+        .device
+        .require_features(Features::EXPERIMENTAL_RAY_QUERY)?;
 
     let mut build_command = AsBuild::default();
     let mut buf_storage = Vec::new();
     iter_blas(
-        blas_iter,
-        cmd_buf_data,
+        blas.into_iter(),
+        state.tracker,
         &mut build_command,
         &mut buf_storage,
-        hub,
     )?;
 
-    let snatch_guard = device.snatchable_lock.read();
     let mut input_barriers = Vec::<hal::BufferBarrier<dyn hal::DynBuffer>>::new();
     let mut scratch_buffer_blas_size = 0;
     let mut blas_storage = Vec::new();
     iter_buffers(
+        state,
         &mut buf_storage,
-        &snatch_guard,
         &mut input_barriers,
-        cmd_buf_data,
         &mut scratch_buffer_blas_size,
         &mut blas_storage,
-        hub,
-        device.alignments.ray_tracing_scratch_buffer_alignment,
     )?;
-    let mut tlas_lock_store = Vec::<(Option<TlasPackage>, Arc<Tlas>)>::new();
+    let mut tlas_lock_store = Vec::<(Option<ArcTlasPackage>, Arc<Tlas>)>::new();
 
-    for package in tlas_iter {
-        let tlas = hub.tlas_s.get(package.tlas_id).get()?;
-
-        cmd_buf_data.trackers.tlas_s.insert_single(tlas.clone());
-
+    for package in tlas.into_iter() {
+        let tlas = package.tlas.clone();
+        state.tracker.tlas_s.insert_single(tlas.clone());
         tlas_lock_store.push((Some(package), tlas))
     }
 
@@ -283,7 +299,7 @@
         let scratch_buffer_offset = scratch_buffer_tlas_size;
         scratch_buffer_tlas_size += align_to(
             tlas.size_info.build_scratch_size as u32,
-            device.alignments.ray_tracing_scratch_buffer_alignment,
+            state.device.alignments.ray_tracing_scratch_buffer_alignment,
         ) as u64;
 
         let first_byte_index = instance_buffer_staging_source.len();
@@ -291,19 +307,18 @@
         let mut dependencies = Vec::new();
 
         let mut instance_count = 0;
-        for instance in package.instances.flatten() {
+        for instance in package.instances.into_iter().flatten() {
             if instance.custom_data >= (1u32 << 24u32) {
                 return Err(BuildAccelerationStructureError::TlasInvalidCustomIndex(
                     tlas.error_ident(),
                 ));
             }
-            let blas = hub.blas_s.get(instance.blas_id).get()?;
-
-            cmd_buf_data.trackers.blas_s.insert_single(blas.clone());
+            let blas = &instance.blas;
+            state.tracker.blas_s.insert_single(blas.clone());
 
-            instance_buffer_staging_source.extend(device.raw().tlas_instance_to_bytes(
+            instance_buffer_staging_source.extend(state.device.raw().tlas_instance_to_bytes(
                 hal::TlasInstance {
-                    transform: *instance.transform,
+                    transform: instance.transform,
                     custom_data: instance.custom_data,
                     mask: instance.mask,
                     blas_address: blas.handle,
@@ -366,7 +381,7 @@
         return Ok(());
     };
 
-    let scratch_buffer = ScratchBuffer::new(device, scratch_size)?;
+    let scratch_buffer = ScratchBuffer::new(state.device, scratch_size)?;
 
     let scratch_buffer_barrier = hal::BufferBarrier::<dyn hal::DynBuffer> {
         buffer: scratch_buffer.raw(),
@@ -396,7 +411,7 @@
             mode: hal::AccelerationStructureBuildMode::Build,
             flags: tlas.flags,
             source_acceleration_structure: None,
-            destination_acceleration_structure: tlas.try_raw(&snatch_guard)?,
+            destination_acceleration_structure: tlas.try_raw(state.snatch_guard)?,
             scratch_buffer: scratch_buffer.raw(),
             scratch_buffer_offset: *scratch_buffer_offset,
         })
@@ -405,7 +420,7 @@
     let blas_present = !blas_storage.is_empty();
     let tlas_present = !tlas_storage.is_empty();
 
-    let cmd_buf_raw = cmd_buf_data.encoder.open()?;
+    let raw_encoder = &mut state.raw_encoder;
 
     let mut blas_s_compactable = Vec::new();
     let mut descriptors = Vec::new();
@@ -414,13 +429,13 @@
         descriptors.push(map_blas(
             storage,
             scratch_buffer.raw(),
-            &snatch_guard,
+            state.snatch_guard,
             &mut blas_s_compactable,
         )?);
     }
 
     build_blas(
-        cmd_buf_raw,
+        *raw_encoder,
         blas_present,
         tlas_present,
         input_barriers,
@@ -432,7 +447,7 @@
     if tlas_present {
         let staging_buffer = if !instance_buffer_staging_source.is_empty() {
             let mut staging_buffer = StagingBuffer::new(
-                device,
+                state.device,
                 wgt::BufferSize::new(instance_buffer_staging_source.len() as u64).unwrap(),
             )?;
             staging_buffer.write(&instance_buffer_staging_source);
@@ -444,7 +459,7 @@
 
         unsafe {
             if let Some(ref staging_buffer) = staging_buffer {
-                cmd_buf_raw.transition_buffers(&[hal::BufferBarrier::<dyn hal::DynBuffer> {
+                raw_encoder.transition_buffers(&[hal::BufferBarrier::<dyn hal::DynBuffer> {
                     buffer: staging_buffer.raw(),
                     usage: hal::StateTransition {
                         from: BufferUses::MAP_WRITE,
@@ -472,7 +487,7 @@
                 },
             });
             unsafe {
-                cmd_buf_raw.transition_buffers(&[hal::BufferBarrier::<dyn hal::DynBuffer> {
+                raw_encoder.transition_buffers(&[hal::BufferBarrier::<dyn hal::DynBuffer> {
                     buffer: tlas.instance_buffer.as_ref(),
                     usage: hal::StateTransition {
                         from: BufferUses::TOP_LEVEL_ACCELERATION_STRUCTURE_INPUT,
@@ -484,9 +499,7 @@
                     dst_offset: 0,
                     size,
                 };
-                cmd_buf_raw.copy_buffer_to_buffer(
-                    // the range whose size we just checked end is at (at that point in time) instance_buffer_staging_source.len()
-                    // and since instance_buffer_staging_source doesn't shrink we can un wrap this without a panic
+                raw_encoder.copy_buffer_to_buffer(
                     staging_buffer.as_ref().unwrap().raw(),
                     tlas.instance_buffer.as_ref(),
                     &[temp],
@@ -495,11 +508,11 @@
         }
 
         unsafe {
-            cmd_buf_raw.transition_buffers(&instance_buffer_barriers);
+            raw_encoder.transition_buffers(&instance_buffer_barriers);
 
-            cmd_buf_raw.build_acceleration_structures(&tlas_descriptors);
+            raw_encoder.build_acceleration_structures(&tlas_descriptors);
 
-            cmd_buf_raw.place_acceleration_structure_barrier(hal::AccelerationStructureBarrier {
+            raw_encoder.place_acceleration_structure_barrier(hal::AccelerationStructureBarrier {
                 usage: hal::StateTransition {
                     from: hal::AccelerationStructureUses::BUILD_OUTPUT,
                     to: hal::AccelerationStructureUses::SHADER_INPUT,
@@ -508,17 +521,17 @@
         }
 
         if let Some(staging_buffer) = staging_buffer {
-            cmd_buf_data
+            state
                 .temp_resources
                 .push(TempResource::StagingBuffer(staging_buffer));
         }
     }
 
-    cmd_buf_data
+    state
         .temp_resources
         .push(TempResource::ScratchBuffer(scratch_buffer));
 
-    cmd_buf_data.as_actions.push(AsAction::Build(build_command));
+    state.as_actions.push(AsAction::Build(build_command));
 
     Ok(())
 }
@@ -600,23 +613,22 @@
 }
 
 ///iterates over the blas iterator, and it's geometry, pushing the buffers into a storage vector (and also some validation).
-fn iter_blas<'a>(
-    blas_iter: impl Iterator<Item = BlasBuildEntry<'a>>,
-    cmd_buf_data: &mut CommandBufferMutable,
+fn iter_blas(
+    blas_iter: impl Iterator<Item = ArcBlasBuildEntry>,
+    tracker: &mut Tracker,
     build_command: &mut AsBuild,
-    buf_storage: &mut Vec<TriangleBufferStore<'a>>,
-    hub: &Hub,
+    buf_storage: &mut Vec<TriangleBufferStore>,
 ) -> Result<(), BuildAccelerationStructureError> {
     let mut temp_buffer = Vec::new();
     for entry in blas_iter {
-        let blas = hub.blas_s.get(entry.blas_id).get()?;
-        cmd_buf_data.trackers.blas_s.insert_single(blas.clone());
+        let blas = &entry.blas;
+        tracker.blas_s.insert_single(blas.clone());
 
         build_command.blas_s_built.push(blas.clone());
 
         match entry.geometries {
-            BlasGeometries::TriangleGeometries(triangle_geometries) => {
-                for (i, mesh) in triangle_geometries.enumerate() {
+            ArcBlasGeometries::TriangleGeometries(triangle_geometries) => {
+                for (i, mesh) in triangle_geometries.into_iter().enumerate() {
                     let size_desc = match &blas.sizes {
                         wgt::BlasGeometrySizeDescriptors::Triangles { descriptors } => descriptors,
                     };
@@ -715,13 +727,12 @@
                             blas.error_ident(),
                         ));
                     }
-                    let vertex_buffer = hub.buffers.get(mesh.vertex_buffer).get()?;
-                    let vertex_pending = cmd_buf_data.trackers.buffers.set_single(
+                    let vertex_buffer = mesh.vertex_buffer.clone();
+                    let vertex_pending = tracker.buffers.set_single(
                         &vertex_buffer,
                         BufferUses::BOTTOM_LEVEL_ACCELERATION_STRUCTURE_INPUT,
                     );
-                    let index_data = if let Some(index_id) = mesh.index_buffer {
-                        let index_buffer = hub.buffers.get(index_id).get()?;
+                    let index_data = if let Some(index_buffer) = mesh.index_buffer {
                         if mesh.first_index.is_none()
                             || mesh.size.index_count.is_none()
                             || mesh.size.index_count.is_none()
@@ -730,7 +741,7 @@
                                 index_buffer.error_ident(),
                             ));
                         }
-                        let data = cmd_buf_data.trackers.buffers.set_single(
+                        let data = tracker.buffers.set_single(
                             &index_buffer,
                             BufferUses::BOTTOM_LEVEL_ACCELERATION_STRUCTURE_INPUT,
                         );
@@ -738,7 +749,7 @@
                     } else {
                         None
                     };
-                    let transform_data = if let Some(transform_id) = mesh.transform_buffer {
+                    let transform_data = if let Some(transform_buffer) = mesh.transform_buffer {
                         if !blas
                             .flags
                             .contains(wgt::AccelerationStructureFlags::USE_TRANSFORM)
@@ -747,13 +758,12 @@
                                 blas.error_ident(),
                             ));
                         }
-                        let transform_buffer = hub.buffers.get(transform_id).get()?;
                         if mesh.transform_buffer_offset.is_none() {
                             return Err(BuildAccelerationStructureError::MissingAssociatedData(
                                 transform_buffer.error_ident(),
                             ));
                         }
-                        let data = cmd_buf_data.trackers.buffers.set_single(
+                        let data = tracker.buffers.set_single(
                             &transform_buffer,
                             BufferUses::BOTTOM_LEVEL_ACCELERATION_STRUCTURE_INPUT,
                         );
@@ -774,13 +784,19 @@
                         vertex_transition: vertex_pending,
                         index_buffer_transition: index_data,
                         transform_buffer_transition: transform_data,
-                        geometry: mesh,
+                        geometry: BlasTriangleGeometryInfo {
+                            size: mesh.size,
+                            first_vertex: mesh.first_vertex,
+                            vertex_stride: mesh.vertex_stride,
+                            first_index: mesh.first_index,
+                            transform_buffer_offset: mesh.transform_buffer_offset,
+                        },
                         ending_blas: None,
                     });
                 }
 
                 if let Some(last) = temp_buffer.last_mut() {
-                    last.ending_blas = Some(blas);
+                    last.ending_blas = Some(blas.clone());
                     buf_storage.append(&mut temp_buffer);
                 }
             }
@@ -790,29 +806,30 @@
 }
 
 /// Iterates over the buffers generated in [iter_blas], convert the barriers into hal barriers, and the triangles into [hal::AccelerationStructureEntries] (and also some validation).
-fn iter_buffers<'a, 'b>(
-    buf_storage: &'a mut Vec<TriangleBufferStore<'b>>,
-    snatch_guard: &'a SnatchGuard,
-    input_barriers: &mut Vec<hal::BufferBarrier<'a, dyn hal::DynBuffer>>,
-    cmd_buf_data: &mut CommandBufferMutable,
+///
+/// `'buffers` is the lifetime of `&dyn hal::DynBuffer` in our working data,
+/// i.e., needs to span until `build_acceleration_structures` finishes encoding.
+/// `'snatch_guard` is the lifetime of the snatch lock acquisition.
+fn iter_buffers<'snatch_guard: 'buffers, 'buffers>(
+    state: &mut EncodingState<'snatch_guard, '_>,
+    buf_storage: &'buffers mut Vec<TriangleBufferStore>,
+    input_barriers: &mut Vec<hal::BufferBarrier<'buffers, dyn hal::DynBuffer>>,
     scratch_buffer_blas_size: &mut u64,
-    blas_storage: &mut Vec<BlasStore<'a>>,
-    hub: &Hub,
-    ray_tracing_scratch_buffer_alignment: u32,
+    blas_storage: &mut Vec<BlasStore<'buffers>>,
 ) -> Result<(), BuildAccelerationStructureError> {
     let mut triangle_entries =
         Vec::<hal::AccelerationStructureTriangles<dyn hal::DynBuffer>>::new();
     for buf in buf_storage {
         let mesh = &buf.geometry;
         let vertex_buffer = {
-            let vertex_buffer = buf.vertex_buffer.as_ref();
-            let vertex_raw = vertex_buffer.try_raw(snatch_guard)?;
+            let vertex_raw = buf.vertex_buffer.as_ref().try_raw(state.snatch_guard)?;
+            let vertex_buffer = &buf.vertex_buffer;
             vertex_buffer.check_usage(BufferUsages::BLAS_INPUT)?;
 
             if let Some(barrier) = buf
                 .vertex_transition
                 .take()
-                .map(|pending| pending.into_hal(vertex_buffer, snatch_guard))
+                .map(|pending| pending.into_hal(buf.vertex_buffer.as_ref(), state.snatch_guard))
             {
                 input_barriers.push(barrier);
             }
@@ -826,9 +843,9 @@
                 ));
             }
             let vertex_buffer_offset = mesh.first_vertex as u64 * mesh.vertex_stride;
-            cmd_buf_data.buffer_memory_init_actions.extend(
+            state.buffer_memory_init_actions.extend(
                 vertex_buffer.initialization_status.read().create_action(
-                    &hub.buffers.get(mesh.vertex_buffer).get()?,
+                    vertex_buffer,
                     vertex_buffer_offset
                         ..(vertex_buffer_offset
                             + mesh.size.vertex_count as u64 * mesh.vertex_stride),
@@ -840,12 +857,12 @@
         let index_buffer = if let Some((ref mut index_buffer, ref mut index_pending)) =
             buf.index_buffer_transition
         {
-            let index_raw = index_buffer.try_raw(snatch_guard)?;
+            let index_raw = index_buffer.try_raw(state.snatch_guard)?;
             index_buffer.check_usage(BufferUsages::BLAS_INPUT)?;
 
             if let Some(barrier) = index_pending
                 .take()
-                .map(|pending| pending.into_hal(index_buffer, snatch_guard))
+                .map(|pending| pending.into_hal(index_buffer, state.snatch_guard))
             {
                 input_barriers.push(barrier);
             }
@@ -867,7 +884,7 @@
                 ));
             }
 
-            cmd_buf_data.buffer_memory_init_actions.extend(
+            state.buffer_memory_init_actions.extend(
                 index_buffer.initialization_status.read().create_action(
                     index_buffer,
                     offset..(offset + index_buffer_size),
@@ -886,12 +903,12 @@
                     transform_buffer.error_ident(),
                 ));
             }
-            let transform_raw = transform_buffer.try_raw(snatch_guard)?;
+            let transform_raw = transform_buffer.try_raw(state.snatch_guard)?;
             transform_buffer.check_usage(BufferUsages::BLAS_INPUT)?;
 
             if let Some(barrier) = transform_pending
                 .take()
-                .map(|pending| pending.into_hal(transform_buffer, snatch_guard))
+                .map(|pending| pending.into_hal(transform_buffer, state.snatch_guard))
             {
                 input_barriers.push(barrier);
             }
@@ -912,7 +929,7 @@
                     48 + offset,
                 ));
             }
-            cmd_buf_data.buffer_memory_init_actions.extend(
+            state.buffer_memory_init_actions.extend(
                 transform_buffer.initialization_status.read().create_action(
                     transform_buffer,
                     offset..(offset + 48),
@@ -952,7 +969,7 @@
             let scratch_buffer_offset = *scratch_buffer_blas_size;
             *scratch_buffer_blas_size += align_to(
                 blas.size_info.build_scratch_size as u32,
-                ray_tracing_scratch_buffer_alignment,
+                state.device.alignments.ray_tracing_scratch_buffer_alignment,
             ) as u64;
 
             blas_storage.push(BlasStore {