# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: third_party/rust/wgpu-core/src/command/render.rs
# Commit: 3f167f8b3137
# Full Hash: 3f167f8b313749f50f135e189e5854bef7ac0c73
# Author: Erich Gubler <erichdongubler@gmail.com>
# Date: 2025-10-03 18:08 +0000
# Regressor Bug: 1991551
# File Overlap Count: 23
# Overlapping Files: third_party/rust/wgpu-hal/Cargo.toml, supply-chain/audits.toml, third_party/rust/naga/src/back/spv/writer.rs, third_party/rust/naga/src/back/msl/writer.rs, third_party/rust/wgpu-types/src/lib.rs
# Description:
#   Bug 1991551 - build(webgpu): update WGPU to 8c4aebc0c1b75e3f7412dfc180745a0717fc30ec r=webgpu-reviewers,supply-chain-reviewers,nical
# ==============================================================================

diff -r 823439f307a0 -r 3f167f8b3137 third_party/rust/wgpu-core/src/command/render.rs
--- a/third_party/rust/wgpu-core/src/command/render.rs	Fri Oct 03 18:01:30 2025 +0000
+++ b/third_party/rust/wgpu-core/src/command/render.rs	Fri Oct 03 18:08:29 2025 +0000
@@ -1,5 +1,6 @@
 use alloc::{borrow::Cow, sync::Arc, vec::Vec};
-use core::{fmt, num::NonZeroU32, ops::Range, str};
+use core::{convert::Infallible, fmt, num::NonZeroU32, ops::Range, str};
+use smallvec::SmallVec;
 
 use arrayvec::ArrayVec;
 use thiserror::Error;
@@ -11,8 +12,8 @@
 
 use crate::command::{
     encoder::EncodingState, pass, pass_base, pass_try, validate_and_begin_occlusion_query,
-    validate_and_begin_pipeline_statistics_query, CommandBufferMutable, DebugGroupError,
-    EncoderStateError, InnerCommandEncoder, PassStateError, TimestampWritesError,
+    validate_and_begin_pipeline_statistics_query, ArcCommand, DebugGroupError, EncoderStateError,
+    InnerCommandEncoder, PassStateError, TimestampWritesError,
 };
 use crate::pipeline::{RenderPipeline, VertexStep};
 use crate::resource::RawResourceAccess;
@@ -117,7 +118,7 @@
     }
 }
 
-#[derive(Debug)]
+#[derive(Clone, Debug)]
 pub enum ResolvedPassChannel<V> {
     ReadOnly,
     Operational(wgt::Operations<V>),
@@ -180,6 +181,11 @@
 
 pub type ArcRenderPassColorAttachment = RenderPassColorAttachment<Arc<TextureView>>;
 
+// Avoid allocation in the common case that there is only one color attachment,
+// but don't bloat `ArcCommand::RunRenderPass` excessively.
+pub type ArcRenderPassColorAttachmentArray =
+    SmallVec<[Option<RenderPassColorAttachment<Arc<TextureView>>>; 1]>;
+
 impl ArcRenderPassColorAttachment {
     fn hal_ops(&self) -> hal::AttachmentOps {
         load_hal_ops(self.load_op) | store_hal_ops(self.store_op)
@@ -207,7 +213,7 @@
 }
 
 /// Describes a depth/stencil attachment to a render pass.
-#[derive(Debug)]
+#[derive(Clone, Debug)]
 pub struct ArcRenderPassDepthStencilAttachment {
     /// The view to use as an attachment.
     pub view: Arc<TextureView>,
@@ -494,7 +500,7 @@
     }
 }
 
-struct State<'scope, 'snatch_guard, 'cmd_enc, 'raw_encoder> {
+struct State<'scope, 'snatch_guard, 'cmd_enc> {
     pipeline_flags: PipelineFlags,
     blend_constant: OptionalState,
     stencil_reference: u32,
@@ -504,15 +510,13 @@
 
     info: RenderPassInfo,
 
-    pass: pass::PassState<'scope, 'snatch_guard, 'cmd_enc, 'raw_encoder>,
+    pass: pass::PassState<'scope, 'snatch_guard, 'cmd_enc>,
 
     active_occlusion_query: Option<(Arc<QuerySet>, u32)>,
     active_pipeline_statistics_query: Option<(Arc<QuerySet>, u32)>,
 }
 
-impl<'scope, 'snatch_guard, 'cmd_enc, 'raw_encoder>
-    State<'scope, 'snatch_guard, 'cmd_enc, 'raw_encoder>
-{
+impl<'scope, 'snatch_guard, 'cmd_enc> State<'scope, 'snatch_guard, 'cmd_enc> {
     fn is_ready(&self, family: DrawCommandFamily) -> Result<(), DrawError> {
         if let Some(pipeline) = self.pipeline.as_ref() {
             self.pass.binder.check_compatibility(pipeline.as_ref())?;
@@ -953,14 +957,11 @@
     fn start(
         device: &Arc<Device>,
         hal_label: Option<&str>,
-        color_attachments: ArrayVec<
-            Option<ArcRenderPassColorAttachment>,
-            { hal::MAX_COLOR_ATTACHMENTS },
-        >,
+        color_attachments: &[Option<ArcRenderPassColorAttachment>],
         mut depth_stencil_attachment: Option<ArcRenderPassDepthStencilAttachment>,
         mut timestamp_writes: Option<ArcPassTimestampWrites>,
         mut occlusion_query_set: Option<Arc<QuerySet>>,
-        encoder: &mut InnerCommandEncoder,
+        encoder: &mut dyn hal::DynCommandEncoder,
         trackers: &mut Tracker,
         texture_memory_actions: &mut CommandBufferTextureMemoryActions,
         pending_query_resets: &mut QueryResetMap,
@@ -1422,7 +1423,6 @@
         };
         unsafe {
             encoder
-                .raw
                 .begin_render_pass(&hal_desc)
                 .map_err(|e| device.handle_hal_error(e))?;
         };
@@ -1438,9 +1438,9 @@
         if let Some(at) = depth_stencil_attachment.take() {
             trackers.views.insert_single(at.view.clone());
         }
-        for at in color_attachments.into_iter().flatten() {
+        for at in color_attachments.iter().flatten() {
             trackers.views.insert_single(at.view.clone());
-            if let Some(resolve_target) = at.resolve_target {
+            if let Some(resolve_target) = at.resolve_target.clone() {
                 trackers.views.insert_single(resolve_target);
             }
         }
@@ -1740,7 +1740,7 @@
     pub fn render_pass_end_with_unresolved_commands(
         &self,
         encoder_id: id::CommandEncoderId,
-        base: BasePass<super::RenderCommand, core::convert::Infallible>,
+        base: BasePass<super::RenderCommand, Infallible>,
         color_attachments: &[Option<RenderPassColorAttachment>],
         depth_stencil_attachment: Option<&RenderPassDepthStencilAttachment>,
         timestamp_writes: Option<&PassTimestampWrites>,
@@ -1815,87 +1815,97 @@
         let cmd_enc = pass.parent.take().ok_or(EncoderStateError::Ended)?;
         let mut cmd_buf_data = cmd_enc.data.lock();
 
-        if let Some(err) = pass.base.error.take() {
-            if matches!(
-                err,
-                RenderPassError {
-                    inner: RenderPassErrorInner::EncoderState(EncoderStateError::Ended),
-                    scope: _,
-                }
-            ) {
-                // If the encoder was already finished at time of pass creation,
-                // then it was not put in the locked state, so we need to
-                // generate a validation error here due to the encoder not being
-                // locked. The encoder already has a copy of the error.
-                return Err(EncoderStateError::Ended);
-            } else {
-                // If the pass is invalid, invalidate the parent encoder and return.
-                // Since we do not track the state of an invalid encoder, it is not
-                // necessary to unlock it.
-                cmd_buf_data.invalidate(err);
-                return Ok(());
-            }
+        cmd_buf_data.unlock_encoder()?;
+
+        let base = pass.base.take();
+
+        if matches!(
+            base,
+            Err(RenderPassError {
+                inner: RenderPassErrorInner::EncoderState(EncoderStateError::Ended),
+                scope: _,
+            })
+        ) {
+            // If the encoder was already finished at time of pass creation,
+            // then it was not put in the locked state, so we need to
+            // generate a validation error here and now due to the encoder not
+            // being locked. The encoder already holds an error from when the
+            // pass was opened, or earlier.
+            //
+            // All other errors are propagated to the encoder within `push_with`,
+            // and will be reported later.
+            return Err(EncoderStateError::Ended);
         }
 
-        cmd_buf_data.unlock_and_record(|cmd_buf_data| -> Result<(), RenderPassError> {
-            encode_render_pass(cmd_buf_data, &cmd_enc, pass)
+        cmd_buf_data.push_with(|| -> Result<_, RenderPassError> {
+            Ok(ArcCommand::RunRenderPass {
+                pass: base?,
+                color_attachments: SmallVec::from(pass.color_attachments.as_slice()),
+                depth_stencil_attachment: pass.depth_stencil_attachment.take(),
+                timestamp_writes: pass.timestamp_writes.take(),
+                occlusion_query_set: pass.occlusion_query_set.take(),
+            })
         })
     }
 }
 
-fn encode_render_pass(
-    cmd_buf_data: &mut CommandBufferMutable,
-    cmd_enc: &Arc<CommandEncoder>,
-    pass: &mut RenderPass,
+pub(super) fn encode_render_pass(
+    parent_state: &mut EncodingState<InnerCommandEncoder>,
+    mut base: BasePass<ArcRenderCommand, Infallible>,
+    color_attachments: ArcRenderPassColorAttachmentArray,
+    mut depth_stencil_attachment: Option<ArcRenderPassDepthStencilAttachment>,
+    mut timestamp_writes: Option<ArcPassTimestampWrites>,
+    occlusion_query_set: Option<Arc<QuerySet>>,
 ) -> Result<(), RenderPassError> {
     let pass_scope = PassErrorScope::Pass;
 
-    let device = &cmd_enc.device;
-    device.check_is_valid().map_pass_err(pass_scope)?;
-    let snatch_guard = &device.snatchable_lock.read();
-
-    let base = &mut pass.base;
+    let device = parent_state.device;
 
     let mut indirect_draw_validation_batcher = crate::indirect_validation::DrawBatcher::new();
 
+    // We automatically keep extending command buffers over time, and because
+    // we want to insert a command buffer _before_ what we're about to record,
+    // we need to make sure to close the previous one.
+    parent_state
+        .raw_encoder
+        .close_if_open()
+        .map_pass_err(pass_scope)?;
+    let raw_encoder = parent_state
+        .raw_encoder
+        .open_pass(base.label.as_deref())
+        .map_pass_err(pass_scope)?;
+
     let (scope, pending_discard_init_fixups, mut pending_query_resets) = {
-        let encoder = &mut cmd_buf_data.encoder;
-        let tracker = &mut cmd_buf_data.trackers;
-        let buffer_memory_init_actions = &mut cmd_buf_data.buffer_memory_init_actions;
-        let texture_memory_actions = &mut cmd_buf_data.texture_memory_actions;
-
-        // We automatically keep extending command buffers over time, and because
-        // we want to insert a command buffer _before_ what we're about to record,
-        // we need to make sure to close the previous one.
-        encoder.close_if_open().map_pass_err(pass_scope)?;
-        encoder
-            .open_pass(base.label.as_deref())
-            .map_pass_err(pass_scope)?;
-
         let mut pending_query_resets = QueryResetMap::new();
         let mut pending_discard_init_fixups = SurfacesInDiscardState::new();
 
         let info = RenderPassInfo::start(
             device,
             hal_label(base.label.as_deref(), device.instance_flags),
-            pass.color_attachments.take(),
-            pass.depth_stencil_attachment.take(),
-            pass.timestamp_writes.take(),
+            &color_attachments,
+            depth_stencil_attachment.take(),
+            timestamp_writes.take(),
             // Still needed down the line.
             // TODO(wumpf): by restructuring the code, we could get rid of some of this Arc clone.
-            pass.occlusion_query_set.clone(),
-            encoder,
-            tracker,
-            texture_memory_actions,
+            occlusion_query_set.clone(),
+            raw_encoder,
+            parent_state.tracker,
+            parent_state.texture_memory_actions,
             &mut pending_query_resets,
             &mut pending_discard_init_fixups,
-            snatch_guard,
+            parent_state.snatch_guard,
         )
         .map_pass_err(pass_scope)?;
 
         let indices = &device.tracker_indices;
-        tracker.buffers.set_size(indices.buffers.size());
-        tracker.textures.set_size(indices.textures.size());
+        parent_state
+            .tracker
+            .buffers
+            .set_size(indices.buffers.size());
+        parent_state
+            .tracker
+            .textures
+            .set_size(indices.textures.size());
 
         let mut debug_scope_depth = 0;
 
@@ -1912,14 +1922,15 @@
             pass: pass::PassState {
                 base: EncodingState {
                     device,
-                    raw_encoder: encoder.raw.as_mut(),
-                    tracker,
-                    buffer_memory_init_actions,
-                    texture_memory_actions,
-                    as_actions: &mut cmd_buf_data.as_actions,
-                    indirect_draw_validation_resources: &mut cmd_buf_data
+                    raw_encoder,
+                    tracker: parent_state.tracker,
+                    buffer_memory_init_actions: parent_state.buffer_memory_init_actions,
+                    texture_memory_actions: parent_state.texture_memory_actions,
+                    as_actions: parent_state.as_actions,
+                    temp_resources: parent_state.temp_resources,
+                    indirect_draw_validation_resources: parent_state
                         .indirect_draw_validation_resources,
-                    snatch_guard,
+                    snatch_guard: parent_state.snatch_guard,
                     debug_scope_depth: &mut debug_scope_depth,
                 },
                 pending_discard_init_fixups,
@@ -1946,7 +1957,7 @@
                     let scope = PassErrorScope::SetBindGroup;
                     pass::set_bind_group::<RenderPassErrorInner>(
                         &mut state.pass,
-                        cmd_enc.as_ref(),
+                        device,
                         &base.dynamic_offsets,
                         index,
                         num_dynamic_offsets,
@@ -1957,7 +1968,7 @@
                 }
                 ArcRenderCommand::SetPipeline(pipeline) => {
                     let scope = PassErrorScope::SetPipelineRender;
-                    set_pipeline(&mut state, cmd_enc, pipeline).map_pass_err(scope)?;
+                    set_pipeline(&mut state, device, pipeline).map_pass_err(scope)?;
                 }
                 ArcRenderCommand::SetIndexBuffer {
                     buffer,
@@ -1966,7 +1977,7 @@
                     size,
                 } => {
                     let scope = PassErrorScope::SetIndexBuffer;
-                    set_index_buffer(&mut state, cmd_enc, buffer, index_format, offset, size)
+                    set_index_buffer(&mut state, device, buffer, index_format, offset, size)
                         .map_pass_err(scope)?;
                 }
                 ArcRenderCommand::SetVertexBuffer {
@@ -1976,7 +1987,7 @@
                     size,
                 } => {
                     let scope = PassErrorScope::SetVertexBuffer;
-                    set_vertex_buffer(&mut state, cmd_enc, slot, buffer, offset, size)
+                    set_vertex_buffer(&mut state, device, slot, buffer, offset, size)
                         .map_pass_err(scope)?;
                 }
                 ArcRenderCommand::SetBlendConstant(ref color) => {
@@ -2087,7 +2098,7 @@
                     multi_draw_indirect(
                         &mut state,
                         &mut indirect_draw_validation_batcher,
-                        cmd_enc,
+                        device,
                         buffer,
                         offset,
                         count,
@@ -2109,7 +2120,7 @@
                     };
                     multi_draw_indirect_count(
                         &mut state,
-                        cmd_enc,
+                        device,
                         buffer,
                         offset,
                         count_buffer,
@@ -2137,7 +2148,7 @@
                     let scope = PassErrorScope::WriteTimestamp;
                     pass::write_timestamp::<RenderPassErrorInner>(
                         &mut state.pass,
-                        cmd_enc.as_ref(),
+                        device,
                         Some(&mut pending_query_resets),
                         query_set,
                         query_index,
@@ -2148,8 +2159,7 @@
                     api_log!("RenderPass::begin_occlusion_query {query_index}");
                     let scope = PassErrorScope::BeginOcclusionQuery;
 
-                    let query_set = pass
-                        .occlusion_query_set
+                    let query_set = occlusion_query_set
                         .clone()
                         .ok_or(RenderPassErrorInner::MissingOcclusionQuerySet)
                         .map_pass_err(scope)?;
@@ -2188,7 +2198,7 @@
                         query_set,
                         state.pass.base.raw_encoder,
                         &mut state.pass.base.tracker.query_sets,
-                        cmd_enc.as_ref(),
+                        device,
                         query_index,
                         Some(&mut pending_query_resets),
                         &mut state.active_pipeline_statistics_query,
@@ -2210,7 +2220,7 @@
                     execute_bundle(
                         &mut state,
                         &mut indirect_draw_validation_batcher,
-                        cmd_enc,
+                        device,
                         bundle,
                     )
                     .map_pass_err(scope)?;
@@ -2240,12 +2250,12 @@
 
         let pending_discard_init_fixups = state.pass.pending_discard_init_fixups;
 
-        encoder.close().map_pass_err(pass_scope)?;
+        parent_state.raw_encoder.close().map_pass_err(pass_scope)?;
         (trackers, pending_discard_init_fixups, pending_query_resets)
     };
 
-    let encoder = &mut cmd_buf_data.encoder;
-    let tracker = &mut cmd_buf_data.trackers;
+    let encoder = &mut parent_state.raw_encoder;
+    let tracker = &mut parent_state.tracker;
 
     {
         let transit = encoder
@@ -2259,22 +2269,27 @@
             pending_discard_init_fixups.into_iter(),
             transit,
             &mut tracker.textures,
-            &cmd_enc.device,
-            snatch_guard,
+            device,
+            parent_state.snatch_guard,
         );
 
         pending_query_resets.reset_queries(transit);
 
-        CommandEncoder::insert_barriers_from_scope(transit, tracker, &scope, snatch_guard);
+        CommandEncoder::insert_barriers_from_scope(
+            transit,
+            tracker,
+            &scope,
+            parent_state.snatch_guard,
+        );
 
         if let Some(ref indirect_validation) = device.indirect_validation {
             indirect_validation
                 .draw
                 .inject_validation_pass(
                     device,
-                    snatch_guard,
-                    &mut cmd_buf_data.indirect_draw_validation_resources,
-                    &mut cmd_buf_data.temp_resources,
+                    parent_state.snatch_guard,
+                    parent_state.indirect_draw_validation_resources,
+                    parent_state.temp_resources,
                     transit,
                     indirect_draw_validation_batcher,
                 )
@@ -2289,7 +2304,7 @@
 
 fn set_pipeline(
     state: &mut State,
-    cmd_enc: &Arc<CommandEncoder>,
+    device: &Arc<Device>,
     pipeline: Arc<RenderPipeline>,
 ) -> Result<(), RenderPassErrorInner> {
     api_log!("RenderPass::set_pipeline {}", pipeline.error_ident());
@@ -2304,7 +2319,7 @@
         .insert_single(pipeline)
         .clone();
 
-    pipeline.same_device_as(cmd_enc.as_ref())?;
+    pipeline.same_device(device)?;
 
     state
         .info
@@ -2359,7 +2374,7 @@
 // This function is duplicative of `bundle::set_index_buffer`.
 fn set_index_buffer(
     state: &mut State,
-    cmd_enc: &Arc<CommandEncoder>,
+    device: &Arc<Device>,
     buffer: Arc<crate::resource::Buffer>,
     index_format: IndexFormat,
     offset: u64,
@@ -2373,7 +2388,7 @@
         .buffers
         .merge_single(&buffer, wgt::BufferUses::INDEX)?;
 
-    buffer.same_device_as(cmd_enc.as_ref())?;
+    buffer.same_device(device)?;
 
     buffer.check_usage(BufferUsages::INDEX)?;
 
@@ -2411,7 +2426,7 @@
 // This function is duplicative of `render::set_vertex_buffer`.
 fn set_vertex_buffer(
     state: &mut State,
-    cmd_enc: &Arc<CommandEncoder>,
+    device: &Arc<Device>,
     slot: u32,
     buffer: Arc<crate::resource::Buffer>,
     offset: u64,
@@ -2428,7 +2443,7 @@
         .buffers
         .merge_single(&buffer, wgt::BufferUses::VERTEX)?;
 
-    buffer.same_device_as(cmd_enc.as_ref())?;
+    buffer.same_device(device)?;
 
     let max_vertex_buffers = state.pass.base.device.limits.max_vertex_buffers;
     if slot >= max_vertex_buffers {
@@ -2688,7 +2703,7 @@
 fn multi_draw_indirect(
     state: &mut State,
     indirect_draw_validation_batcher: &mut crate::indirect_validation::DrawBatcher,
-    cmd_enc: &Arc<CommandEncoder>,
+    device: &Arc<Device>,
     indirect_buffer: Arc<crate::resource::Buffer>,
     offset: u64,
     count: u32,
@@ -2707,7 +2722,7 @@
         .device
         .require_downlevel_flags(wgt::DownlevelFlags::INDIRECT_EXECUTION)?;
 
-    indirect_buffer.same_device_as(cmd_enc.as_ref())?;
+    indirect_buffer.same_device(device)?;
     indirect_buffer.check_usage(BufferUsages::INDIRECT)?;
     indirect_buffer.check_destroyed(state.pass.base.snatch_guard)?;
 
@@ -2866,7 +2881,7 @@
 
 fn multi_draw_indirect_count(
     state: &mut State,
-    cmd_enc: &Arc<CommandEncoder>,
+    device: &Arc<Device>,
     indirect_buffer: Arc<crate::resource::Buffer>,
     offset: u64,
     count_buffer: Arc<crate::resource::Buffer>,
@@ -2895,8 +2910,8 @@
         .device
         .require_downlevel_flags(wgt::DownlevelFlags::INDIRECT_EXECUTION)?;
 
-    indirect_buffer.same_device_as(cmd_enc.as_ref())?;
-    count_buffer.same_device_as(cmd_enc.as_ref())?;
+    indirect_buffer.same_device(device)?;
+    count_buffer.same_device(device)?;
 
     state
         .pass
@@ -2989,14 +3004,14 @@
 fn execute_bundle(
     state: &mut State,
     indirect_draw_validation_batcher: &mut crate::indirect_validation::DrawBatcher,
-    cmd_enc: &Arc<CommandEncoder>,
+    device: &Arc<Device>,
     bundle: Arc<super::RenderBundle>,
 ) -> Result<(), RenderPassErrorInner> {
     api_log!("RenderPass::execute_bundle {}", bundle.error_ident());
 
     let bundle = state.pass.base.tracker.bundles.insert_single(bundle);
 
-    bundle.same_device_as(cmd_enc.as_ref())?;
+    bundle.same_device(device)?;
 
     state
         .info