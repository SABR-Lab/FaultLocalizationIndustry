{
  "bug_id": "1988694",
  "processing_timestamp": "2025-12-16T09:31:57.965842",
  "files": [
    {
      "filepath": "js/src/jit-test/lib/wasm.js",
      "fixing_commits": [
        {
          "commit_hash": "75d829afb4b0",
          "full_hash": "75d829afb4b06a3a8b7e91ea15c8a0cf34665fb7",
          "parent_hash": "896c8ee9171db6fb15ab84ff673c1272c46f28b2",
          "commit_type": "fixing",
          "filepath": "js/src/jit-test/lib/wasm.js",
          "diff_found": true,
          "diff_path": "/Users/sidiqafekrat/Mozilla_crashAnalyzer_BugBug/method2_bugzilla_bugs/outputs/step5_extracted_diffs/bug_1988694/fixing_commit/75d829afb4b0/js_src_jit-test_lib_wasm.js.diff",
          "methods_count": 23,
          "matched_methods": {
            "fully_modified": [],
            "partially_modified": [],
            "unmodified": [
              {
                "name": "canRunHugeMemoryTests",
                "type": "function",
                "start_line": 6,
                "end_line": 28,
                "line_count": 23,
                "signature": "function canRunHugeMemoryTests() { // We're aiming for 64-bit desktop builds with no interesting analysis // running that might inflate memory consumption unreasonably.  It's OK if"
              },
              {
                "name": "wasmEvalBinary",
                "type": "function",
                "start_line": 45,
                "end_line": 60,
                "line_count": 16,
                "signature": "function wasmEvalBinary(binary, imports, compileOptions) { let valid = WebAssembly.validate(binary, compileOptions); "
              },
              {
                "name": "wasmEvalText",
                "type": "function",
                "start_line": 62,
                "end_line": 64,
                "line_count": 3,
                "signature": "function wasmEvalText(str, imports, compileOptions) { return wasmEvalBinary(wasmTextToBinary(str), imports, compileOptions); }"
              },
              {
                "name": "wasmValidateBinary",
                "type": "function",
                "start_line": 66,
                "end_line": 73,
                "line_count": 8,
                "signature": "function wasmValidateBinary(binary) { let valid = WebAssembly.validate(binary); if (!valid) {"
              },
              {
                "name": "wasmFailValidateBinary",
                "type": "function",
                "start_line": 75,
                "end_line": 78,
                "line_count": 4,
                "signature": "function wasmFailValidateBinary(binary, pattern) { assertEq(WebAssembly.validate(binary), false, \"module passed WebAssembly.validate when it should not have\"); assertErrorMessage(() => new WebAssembly"
              },
              {
                "name": "wasmValidateText",
                "type": "function",
                "start_line": 80,
                "end_line": 82,
                "line_count": 3,
                "signature": "function wasmValidateText(str) { return wasmValidateBinary(wasmTextToBinary(str)); }"
              },
              {
                "name": "wasmFailValidateText",
                "type": "function",
                "start_line": 84,
                "end_line": 86,
                "line_count": 3,
                "signature": "function wasmFailValidateText(str, pattern) { return wasmFailValidateBinary(wasmTextToBinary(str), pattern); }"
              },
              {
                "name": "wasmCompilationShouldFail",
                "type": "function",
                "start_line": 98,
                "end_line": 110,
                "line_count": 13,
                "signature": "function wasmCompilationShouldFail(bin, compile_error_regex) { try { new WebAssembly.Module(bin);"
              },
              {
                "name": "mismatchError",
                "type": "function",
                "start_line": 112,
                "end_line": 116,
                "line_count": 5,
                "signature": "function mismatchError(actual, expect) { var str = `(type mismatch: expression has type ${actual} but expected ${expect})|` + `(type mismatch: expected ${expect}, found ${actual}\\)`;"
              },
              {
                "name": "jsify",
                "type": "function",
                "start_line": 121,
                "end_line": 131,
                "line_count": 11,
                "signature": "function jsify(wasmVal) { if (wasmVal === 'nan') return NaN;"
              },
              {
                "name": "_augmentSrc",
                "type": "function",
                "start_line": 133,
                "end_line": 198,
                "line_count": 66,
                "signature": "function _augmentSrc(src, assertions) { let i = 0; let newSrc = src.substr(0, src.lastIndexOf(')'));"
              },
              {
                "name": "wasmAssert",
                "type": "function",
                "start_line": 200,
                "end_line": 210,
                "line_count": 11,
                "signature": "function wasmAssert(src, assertions, maybeImports = {}, exportBox = null) { let { exports } = wasmEvalText(_augmentSrc(src, assertions), maybeImports); if (exportBox !== null)"
              },
              {
                "name": "wasmFullPass",
                "type": "function",
                "start_line": 218,
                "end_line": 226,
                "line_count": 9,
                "signature": "function wasmFullPass(text, expected, maybeImports, ...args) { let binary = wasmTextToBinary(text); assertEq(WebAssembly.validate(binary), true, \"Must validate.\");"
              },
              {
                "name": "wasmFullPassI64",
                "type": "function",
                "start_line": 229,
                "end_line": 239,
                "line_count": 11,
                "signature": "function wasmFullPassI64(text, expected, maybeImports, ...args) { let binary = wasmTextToBinary(text); assertEq(WebAssembly.validate(binary), true, \"Must validate.\");"
              },
              {
                "name": "wasmRunWithDebugger",
                "type": "function",
                "start_line": 241,
                "end_line": 260,
                "line_count": 20,
                "signature": "function wasmRunWithDebugger(wast, lib, init, done) { let g = newGlobal({newCompartment: true}); let dbg = new Debugger(g);"
              },
              {
                "name": "fuzzingSafe",
                "type": "function",
                "start_line": 427,
                "end_line": 429,
                "line_count": 3,
                "signature": "function fuzzingSafe() { return typeof getErrorNotes == 'undefined'; }"
              },
              {
                "name": "iota",
                "type": "function",
                "start_line": 531,
                "end_line": 536,
                "line_count": 6,
                "signature": "function iota(len, k=0) { let xs = []; for ( let i=0 ; i < len ; i++ )"
              },
              {
                "name": "cross",
                "type": "function",
                "start_line": 540,
                "end_line": 546,
                "line_count": 7,
                "signature": "function cross(xs) { let results = []; for ( let x of xs )"
              },
              {
                "name": "remove",
                "type": "function",
                "start_line": 549,
                "end_line": 557,
                "line_count": 9,
                "signature": "function remove(v, xs) { let result = []; for ( let w of xs ) {"
              },
              {
                "name": "permute",
                "type": "function",
                "start_line": 562,
                "end_line": 570,
                "line_count": 9,
                "signature": "function permute(xs) { if (xs.length == 1) return [xs];"
              },
              {
                "name": "interleave",
                "type": "function",
                "start_line": 573,
                "end_line": 581,
                "line_count": 9,
                "signature": "function interleave(xs, ys) { assertEq(xs.length, ys.length); let res = [];"
              },
              {
                "name": "assertSame",
                "type": "function",
                "start_line": 586,
                "end_line": 599,
                "line_count": 14,
                "signature": "function assertSame(got, expected) { assertEq(got.length, expected.length); for ( let i=0; i < got.length; i++ ) {"
              },
              {
                "name": "assertEqResults",
                "type": "function",
                "start_line": 606,
                "end_line": 614,
                "line_count": 9,
                "signature": "function assertEqResults(got, expected) { if (!Array.isArray(got)) { got = [got];"
              }
            ]
          },
          "hunks_count": 1,
          "hunk_ranges": [
            "@@ -519,12 @@"
          ]
        }
      ],
      "regressor_commits": [
        {
          "commit_hash": "75d829afb4b0",
          "full_hash": "75d829afb4b06a3a8b7e91ea15c8a0cf34665fb7",
          "parent_hash": "896c8ee9171db6fb15ab84ff673c1272c46f28b2",
          "commit_type": "regressor",
          "filepath": "js/src/jit-test/lib/wasm.js",
          "diff_found": true,
          "diff_path": "/Users/sidiqafekrat/Mozilla_crashAnalyzer_BugBug/method2_bugzilla_bugs/outputs/step5_extracted_diffs/bug_1988694/regressor_commits/regressor_1969509_75d829afb4b0/js_src_jit-test_lib_wasm.js.diff",
          "methods_count": 23,
          "matched_methods": {
            "fully_modified": [],
            "partially_modified": [],
            "unmodified": [
              {
                "name": "canRunHugeMemoryTests",
                "type": "function",
                "start_line": 6,
                "end_line": 28,
                "line_count": 23,
                "signature": "function canRunHugeMemoryTests() { // We're aiming for 64-bit desktop builds with no interesting analysis // running that might inflate memory consumption unreasonably.  It's OK if"
              },
              {
                "name": "wasmEvalBinary",
                "type": "function",
                "start_line": 45,
                "end_line": 60,
                "line_count": 16,
                "signature": "function wasmEvalBinary(binary, imports, compileOptions) { let valid = WebAssembly.validate(binary, compileOptions); "
              },
              {
                "name": "wasmEvalText",
                "type": "function",
                "start_line": 62,
                "end_line": 64,
                "line_count": 3,
                "signature": "function wasmEvalText(str, imports, compileOptions) { return wasmEvalBinary(wasmTextToBinary(str), imports, compileOptions); }"
              },
              {
                "name": "wasmValidateBinary",
                "type": "function",
                "start_line": 66,
                "end_line": 73,
                "line_count": 8,
                "signature": "function wasmValidateBinary(binary) { let valid = WebAssembly.validate(binary); if (!valid) {"
              },
              {
                "name": "wasmFailValidateBinary",
                "type": "function",
                "start_line": 75,
                "end_line": 78,
                "line_count": 4,
                "signature": "function wasmFailValidateBinary(binary, pattern) { assertEq(WebAssembly.validate(binary), false, \"module passed WebAssembly.validate when it should not have\"); assertErrorMessage(() => new WebAssembly"
              },
              {
                "name": "wasmValidateText",
                "type": "function",
                "start_line": 80,
                "end_line": 82,
                "line_count": 3,
                "signature": "function wasmValidateText(str) { return wasmValidateBinary(wasmTextToBinary(str)); }"
              },
              {
                "name": "wasmFailValidateText",
                "type": "function",
                "start_line": 84,
                "end_line": 86,
                "line_count": 3,
                "signature": "function wasmFailValidateText(str, pattern) { return wasmFailValidateBinary(wasmTextToBinary(str), pattern); }"
              },
              {
                "name": "wasmCompilationShouldFail",
                "type": "function",
                "start_line": 98,
                "end_line": 110,
                "line_count": 13,
                "signature": "function wasmCompilationShouldFail(bin, compile_error_regex) { try { new WebAssembly.Module(bin);"
              },
              {
                "name": "mismatchError",
                "type": "function",
                "start_line": 112,
                "end_line": 116,
                "line_count": 5,
                "signature": "function mismatchError(actual, expect) { var str = `(type mismatch: expression has type ${actual} but expected ${expect})|` + `(type mismatch: expected ${expect}, found ${actual}\\)`;"
              },
              {
                "name": "jsify",
                "type": "function",
                "start_line": 121,
                "end_line": 131,
                "line_count": 11,
                "signature": "function jsify(wasmVal) { if (wasmVal === 'nan') return NaN;"
              },
              {
                "name": "_augmentSrc",
                "type": "function",
                "start_line": 133,
                "end_line": 198,
                "line_count": 66,
                "signature": "function _augmentSrc(src, assertions) { let i = 0; let newSrc = src.substr(0, src.lastIndexOf(')'));"
              },
              {
                "name": "wasmAssert",
                "type": "function",
                "start_line": 200,
                "end_line": 210,
                "line_count": 11,
                "signature": "function wasmAssert(src, assertions, maybeImports = {}, exportBox = null) { let { exports } = wasmEvalText(_augmentSrc(src, assertions), maybeImports); if (exportBox !== null)"
              },
              {
                "name": "wasmFullPass",
                "type": "function",
                "start_line": 218,
                "end_line": 226,
                "line_count": 9,
                "signature": "function wasmFullPass(text, expected, maybeImports, ...args) { let binary = wasmTextToBinary(text); assertEq(WebAssembly.validate(binary), true, \"Must validate.\");"
              },
              {
                "name": "wasmFullPassI64",
                "type": "function",
                "start_line": 229,
                "end_line": 239,
                "line_count": 11,
                "signature": "function wasmFullPassI64(text, expected, maybeImports, ...args) { let binary = wasmTextToBinary(text); assertEq(WebAssembly.validate(binary), true, \"Must validate.\");"
              },
              {
                "name": "wasmRunWithDebugger",
                "type": "function",
                "start_line": 241,
                "end_line": 260,
                "line_count": 20,
                "signature": "function wasmRunWithDebugger(wast, lib, init, done) { let g = newGlobal({newCompartment: true}); let dbg = new Debugger(g);"
              },
              {
                "name": "fuzzingSafe",
                "type": "function",
                "start_line": 427,
                "end_line": 429,
                "line_count": 3,
                "signature": "function fuzzingSafe() { return typeof getErrorNotes == 'undefined'; }"
              },
              {
                "name": "iota",
                "type": "function",
                "start_line": 531,
                "end_line": 536,
                "line_count": 6,
                "signature": "function iota(len, k=0) { let xs = []; for ( let i=0 ; i < len ; i++ )"
              },
              {
                "name": "cross",
                "type": "function",
                "start_line": 540,
                "end_line": 546,
                "line_count": 7,
                "signature": "function cross(xs) { let results = []; for ( let x of xs )"
              },
              {
                "name": "remove",
                "type": "function",
                "start_line": 549,
                "end_line": 557,
                "line_count": 9,
                "signature": "function remove(v, xs) { let result = []; for ( let w of xs ) {"
              },
              {
                "name": "permute",
                "type": "function",
                "start_line": 562,
                "end_line": 570,
                "line_count": 9,
                "signature": "function permute(xs) { if (xs.length == 1) return [xs];"
              },
              {
                "name": "interleave",
                "type": "function",
                "start_line": 573,
                "end_line": 581,
                "line_count": 9,
                "signature": "function interleave(xs, ys) { assertEq(xs.length, ys.length); let res = [];"
              },
              {
                "name": "assertSame",
                "type": "function",
                "start_line": 586,
                "end_line": 599,
                "line_count": 14,
                "signature": "function assertSame(got, expected) { assertEq(got.length, expected.length); for ( let i=0; i < got.length; i++ ) {"
              },
              {
                "name": "assertEqResults",
                "type": "function",
                "start_line": 606,
                "end_line": 614,
                "line_count": 9,
                "signature": "function assertEqResults(got, expected) { if (!Array.isArray(got)) { got = [got];"
              }
            ]
          },
          "hunks_count": 1,
          "hunk_ranges": [
            "@@ -519,12 @@"
          ]
        },
        {
          "commit_hash": "13b7086f65cb",
          "full_hash": "13b7086f65cbbbf1fed6e0341cfbdfb309fb962c",
          "parent_hash": "f7c96ac82c1aa9ff1f1a873b6d15ac9c3900b05d",
          "commit_type": "regressor",
          "filepath": "js/src/jit-test/lib/wasm.js",
          "diff_found": true,
          "diff_path": "/Users/sidiqafekrat/Mozilla_crashAnalyzer_BugBug/method2_bugzilla_bugs/outputs/step5_extracted_diffs/bug_1988694/regressor_commits/regressor_1969509_13b7086f65cb/js_src_jit-test_lib_wasm.js.diff",
          "methods_count": 23,
          "matched_methods": {
            "fully_modified": [],
            "partially_modified": [],
            "unmodified": [
              {
                "name": "canRunHugeMemoryTests",
                "type": "function",
                "start_line": 6,
                "end_line": 28,
                "line_count": 23,
                "signature": "function canRunHugeMemoryTests() { // We're aiming for 64-bit desktop builds with no interesting analysis // running that might inflate memory consumption unreasonably.  It's OK if"
              },
              {
                "name": "wasmEvalBinary",
                "type": "function",
                "start_line": 45,
                "end_line": 60,
                "line_count": 16,
                "signature": "function wasmEvalBinary(binary, imports, compileOptions) { let valid = WebAssembly.validate(binary, compileOptions); "
              },
              {
                "name": "wasmEvalText",
                "type": "function",
                "start_line": 62,
                "end_line": 64,
                "line_count": 3,
                "signature": "function wasmEvalText(str, imports, compileOptions) { return wasmEvalBinary(wasmTextToBinary(str), imports, compileOptions); }"
              },
              {
                "name": "wasmValidateBinary",
                "type": "function",
                "start_line": 66,
                "end_line": 73,
                "line_count": 8,
                "signature": "function wasmValidateBinary(binary) { let valid = WebAssembly.validate(binary); if (!valid) {"
              },
              {
                "name": "wasmFailValidateBinary",
                "type": "function",
                "start_line": 75,
                "end_line": 78,
                "line_count": 4,
                "signature": "function wasmFailValidateBinary(binary, pattern) { assertEq(WebAssembly.validate(binary), false, \"module passed WebAssembly.validate when it should not have\"); assertErrorMessage(() => new WebAssembly"
              },
              {
                "name": "wasmValidateText",
                "type": "function",
                "start_line": 80,
                "end_line": 82,
                "line_count": 3,
                "signature": "function wasmValidateText(str) { return wasmValidateBinary(wasmTextToBinary(str)); }"
              },
              {
                "name": "wasmFailValidateText",
                "type": "function",
                "start_line": 84,
                "end_line": 86,
                "line_count": 3,
                "signature": "function wasmFailValidateText(str, pattern) { return wasmFailValidateBinary(wasmTextToBinary(str), pattern); }"
              },
              {
                "name": "wasmCompilationShouldFail",
                "type": "function",
                "start_line": 98,
                "end_line": 110,
                "line_count": 13,
                "signature": "function wasmCompilationShouldFail(bin, compile_error_regex) { try { new WebAssembly.Module(bin);"
              },
              {
                "name": "mismatchError",
                "type": "function",
                "start_line": 112,
                "end_line": 116,
                "line_count": 5,
                "signature": "function mismatchError(actual, expect) { var str = `(type mismatch: expression has type ${actual} but expected ${expect})|` + `(type mismatch: expected ${expect}, found ${actual}\\)`;"
              },
              {
                "name": "jsify",
                "type": "function",
                "start_line": 121,
                "end_line": 131,
                "line_count": 11,
                "signature": "function jsify(wasmVal) { if (wasmVal === 'nan') return NaN;"
              },
              {
                "name": "_augmentSrc",
                "type": "function",
                "start_line": 133,
                "end_line": 198,
                "line_count": 66,
                "signature": "function _augmentSrc(src, assertions) { let i = 0; let newSrc = src.substr(0, src.lastIndexOf(')'));"
              },
              {
                "name": "wasmAssert",
                "type": "function",
                "start_line": 200,
                "end_line": 210,
                "line_count": 11,
                "signature": "function wasmAssert(src, assertions, maybeImports = {}, exportBox = null) { let { exports } = wasmEvalText(_augmentSrc(src, assertions), maybeImports); if (exportBox !== null)"
              },
              {
                "name": "wasmFullPass",
                "type": "function",
                "start_line": 218,
                "end_line": 226,
                "line_count": 9,
                "signature": "function wasmFullPass(text, expected, maybeImports, ...args) { let binary = wasmTextToBinary(text); assertEq(WebAssembly.validate(binary), true, \"Must validate.\");"
              },
              {
                "name": "wasmFullPassI64",
                "type": "function",
                "start_line": 229,
                "end_line": 239,
                "line_count": 11,
                "signature": "function wasmFullPassI64(text, expected, maybeImports, ...args) { let binary = wasmTextToBinary(text); assertEq(WebAssembly.validate(binary), true, \"Must validate.\");"
              },
              {
                "name": "wasmRunWithDebugger",
                "type": "function",
                "start_line": 241,
                "end_line": 260,
                "line_count": 20,
                "signature": "function wasmRunWithDebugger(wast, lib, init, done) { let g = newGlobal({newCompartment: true}); let dbg = new Debugger(g);"
              },
              {
                "name": "fuzzingSafe",
                "type": "function",
                "start_line": 427,
                "end_line": 429,
                "line_count": 3,
                "signature": "function fuzzingSafe() { return typeof getErrorNotes == 'undefined'; }"
              },
              {
                "name": "iota",
                "type": "function",
                "start_line": 525,
                "end_line": 530,
                "line_count": 6,
                "signature": "function iota(len, k=0) { let xs = []; for ( let i=0 ; i < len ; i++ )"
              },
              {
                "name": "cross",
                "type": "function",
                "start_line": 534,
                "end_line": 540,
                "line_count": 7,
                "signature": "function cross(xs) { let results = []; for ( let x of xs )"
              },
              {
                "name": "remove",
                "type": "function",
                "start_line": 543,
                "end_line": 551,
                "line_count": 9,
                "signature": "function remove(v, xs) { let result = []; for ( let w of xs ) {"
              },
              {
                "name": "permute",
                "type": "function",
                "start_line": 556,
                "end_line": 564,
                "line_count": 9,
                "signature": "function permute(xs) { if (xs.length == 1) return [xs];"
              },
              {
                "name": "interleave",
                "type": "function",
                "start_line": 567,
                "end_line": 575,
                "line_count": 9,
                "signature": "function interleave(xs, ys) { assertEq(xs.length, ys.length); let res = [];"
              },
              {
                "name": "assertSame",
                "type": "function",
                "start_line": 580,
                "end_line": 593,
                "line_count": 14,
                "signature": "function assertSame(got, expected) { assertEq(got.length, expected.length); for ( let i=0; i < got.length; i++ ) {"
              },
              {
                "name": "assertEqResults",
                "type": "function",
                "start_line": 600,
                "end_line": 608,
                "line_count": 9,
                "signature": "function assertEqResults(got, expected) { if (!Array.isArray(got)) { got = [got];"
              }
            ]
          },
          "hunks_count": 1,
          "hunk_ranges": [
            "@@ -519,6 @@"
          ]
        },
        {
          "commit_hash": "85d47a33200c",
          "full_hash": "85d47a33200c36a5f91f011f5713c34da79329ee",
          "parent_hash": "5860a981c750659eba0199e9ee5e45edcaa58a5a",
          "commit_type": "regressor",
          "filepath": "js/src/jit-test/lib/wasm.js",
          "diff_found": true,
          "diff_path": "/Users/sidiqafekrat/Mozilla_crashAnalyzer_BugBug/method2_bugzilla_bugs/outputs/step5_extracted_diffs/bug_1988694/regressor_commits/regressor_1969509_85d47a33200c/js_src_jit-test_lib_wasm.js.diff",
          "methods_count": 23,
          "matched_methods": {
            "fully_modified": [],
            "partially_modified": [],
            "unmodified": [
              {
                "name": "canRunHugeMemoryTests",
                "type": "function",
                "start_line": 6,
                "end_line": 28,
                "line_count": 23,
                "signature": "function canRunHugeMemoryTests() { // We're aiming for 64-bit desktop builds with no interesting analysis // running that might inflate memory consumption unreasonably.  It's OK if"
              },
              {
                "name": "wasmEvalBinary",
                "type": "function",
                "start_line": 45,
                "end_line": 60,
                "line_count": 16,
                "signature": "function wasmEvalBinary(binary, imports, compileOptions) { let valid = WebAssembly.validate(binary, compileOptions); "
              },
              {
                "name": "wasmEvalText",
                "type": "function",
                "start_line": 62,
                "end_line": 64,
                "line_count": 3,
                "signature": "function wasmEvalText(str, imports, compileOptions) { return wasmEvalBinary(wasmTextToBinary(str), imports, compileOptions); }"
              },
              {
                "name": "wasmValidateBinary",
                "type": "function",
                "start_line": 66,
                "end_line": 73,
                "line_count": 8,
                "signature": "function wasmValidateBinary(binary) { let valid = WebAssembly.validate(binary); if (!valid) {"
              },
              {
                "name": "wasmFailValidateBinary",
                "type": "function",
                "start_line": 75,
                "end_line": 78,
                "line_count": 4,
                "signature": "function wasmFailValidateBinary(binary, pattern) { assertEq(WebAssembly.validate(binary), false, \"module passed WebAssembly.validate when it should not have\"); assertErrorMessage(() => new WebAssembly"
              },
              {
                "name": "wasmValidateText",
                "type": "function",
                "start_line": 80,
                "end_line": 82,
                "line_count": 3,
                "signature": "function wasmValidateText(str) { return wasmValidateBinary(wasmTextToBinary(str)); }"
              },
              {
                "name": "wasmFailValidateText",
                "type": "function",
                "start_line": 84,
                "end_line": 86,
                "line_count": 3,
                "signature": "function wasmFailValidateText(str, pattern) { return wasmFailValidateBinary(wasmTextToBinary(str), pattern); }"
              },
              {
                "name": "wasmCompilationShouldFail",
                "type": "function",
                "start_line": 98,
                "end_line": 110,
                "line_count": 13,
                "signature": "function wasmCompilationShouldFail(bin, compile_error_regex) { try { new WebAssembly.Module(bin);"
              },
              {
                "name": "mismatchError",
                "type": "function",
                "start_line": 112,
                "end_line": 116,
                "line_count": 5,
                "signature": "function mismatchError(actual, expect) { var str = `(type mismatch: expression has type ${actual} but expected ${expect})|` + `(type mismatch: expected ${expect}, found ${actual}\\)`;"
              },
              {
                "name": "jsify",
                "type": "function",
                "start_line": 121,
                "end_line": 131,
                "line_count": 11,
                "signature": "function jsify(wasmVal) { if (wasmVal === 'nan') return NaN;"
              },
              {
                "name": "_augmentSrc",
                "type": "function",
                "start_line": 133,
                "end_line": 198,
                "line_count": 66,
                "signature": "function _augmentSrc(src, assertions) { let i = 0; let newSrc = src.substr(0, src.lastIndexOf(')'));"
              },
              {
                "name": "wasmAssert",
                "type": "function",
                "start_line": 200,
                "end_line": 210,
                "line_count": 11,
                "signature": "function wasmAssert(src, assertions, maybeImports = {}, exportBox = null) { let { exports } = wasmEvalText(_augmentSrc(src, assertions), maybeImports); if (exportBox !== null)"
              },
              {
                "name": "wasmFullPass",
                "type": "function",
                "start_line": 218,
                "end_line": 226,
                "line_count": 9,
                "signature": "function wasmFullPass(text, expected, maybeImports, ...args) { let binary = wasmTextToBinary(text); assertEq(WebAssembly.validate(binary), true, \"Must validate.\");"
              },
              {
                "name": "wasmFullPassI64",
                "type": "function",
                "start_line": 229,
                "end_line": 239,
                "line_count": 11,
                "signature": "function wasmFullPassI64(text, expected, maybeImports, ...args) { let binary = wasmTextToBinary(text); assertEq(WebAssembly.validate(binary), true, \"Must validate.\");"
              },
              {
                "name": "wasmRunWithDebugger",
                "type": "function",
                "start_line": 241,
                "end_line": 260,
                "line_count": 20,
                "signature": "function wasmRunWithDebugger(wast, lib, init, done) { let g = newGlobal({newCompartment: true}); let dbg = new Debugger(g);"
              },
              {
                "name": "fuzzingSafe",
                "type": "function",
                "start_line": 427,
                "end_line": 429,
                "line_count": 3,
                "signature": "function fuzzingSafe() { return typeof getErrorNotes == 'undefined'; }"
              },
              {
                "name": "iota",
                "type": "function",
                "start_line": 525,
                "end_line": 530,
                "line_count": 6,
                "signature": "function iota(len, k=0) { let xs = []; for ( let i=0 ; i < len ; i++ )"
              },
              {
                "name": "cross",
                "type": "function",
                "start_line": 534,
                "end_line": 540,
                "line_count": 7,
                "signature": "function cross(xs) { let results = []; for ( let x of xs )"
              },
              {
                "name": "remove",
                "type": "function",
                "start_line": 543,
                "end_line": 551,
                "line_count": 9,
                "signature": "function remove(v, xs) { let result = []; for ( let w of xs ) {"
              },
              {
                "name": "permute",
                "type": "function",
                "start_line": 556,
                "end_line": 564,
                "line_count": 9,
                "signature": "function permute(xs) { if (xs.length == 1) return [xs];"
              },
              {
                "name": "interleave",
                "type": "function",
                "start_line": 567,
                "end_line": 575,
                "line_count": 9,
                "signature": "function interleave(xs, ys) { assertEq(xs.length, ys.length); let res = [];"
              },
              {
                "name": "assertSame",
                "type": "function",
                "start_line": 580,
                "end_line": 593,
                "line_count": 14,
                "signature": "function assertSame(got, expected) { assertEq(got.length, expected.length); for ( let i=0; i < got.length; i++ ) {"
              },
              {
                "name": "assertEqResults",
                "type": "function",
                "start_line": 600,
                "end_line": 608,
                "line_count": 9,
                "signature": "function assertEqResults(got, expected) { if (!Array.isArray(got)) { got = [got];"
              }
            ]
          },
          "hunks_count": 1,
          "hunk_ranges": [
            "@@ -519,6 @@"
          ]
        }
      ]
    },
    {
      "filepath": "js/src/vm/ArrayBufferObject.cpp",
      "fixing_commits": [
        {
          "commit_hash": "75d829afb4b0",
          "full_hash": "75d829afb4b06a3a8b7e91ea15c8a0cf34665fb7",
          "parent_hash": "896c8ee9171db6fb15ab84ff673c1272c46f28b2",
          "commit_type": "fixing",
          "filepath": "js/src/vm/ArrayBufferObject.cpp",
          "diff_found": true,
          "diff_path": "/Users/sidiqafekrat/Mozilla_crashAnalyzer_BugBug/method2_bugzilla_bugs/outputs/step5_extracted_diffs/bug_1988694/fixing_commit/75d829afb4b0/js_src_vm_ArrayBufferObject.cpp.diff",
          "methods_count": 95,
          "matched_methods": {
            "fully_modified": [],
            "partially_modified": [
              {
                "name": "maxByteLengthGetterImpl",
                "type": "method",
                "start_line": 543,
                "end_line": 569,
                "line_count": 27,
                "signature": "bool ArrayBufferObject::maxByteLengthGetterImpl(JSContext* cx, const CallArgs& args) { MOZ_ASSERT(IsArrayBuffer(args.thisv()));",
                "changed_lines": [
                  546,
                  547,
                  548,
                  549,
                  550,
                  551,
                  552,
                  553,
                  554,
                  555,
                  556,
                  557,
                  558,
                  559,
                  560,
                  561,
                  562,
                  563,
                  564
                ],
                "overlap_count": 19,
                "overlap_percentage": 70.4
              }
            ],
            "unmodified": [
              {
                "name": "WasmReservedBytes",
                "type": "method",
                "start_line": 160,
                "end_line": 160,
                "line_count": 1,
                "signature": "uint64_t js::WasmReservedBytes() { return wasmReservedBytes; }  [[nodiscard]] static bool CheckArrayBufferTooLarge(JSContext* cx,"
              },
              {
                "name": "CheckArrayBufferTooLarge",
                "type": "function",
                "start_line": 162,
                "end_line": 172,
                "line_count": 11,
                "signature": "[[nodiscard]] static bool CheckArrayBufferTooLarge(JSContext* cx, uint64_t nbytes) { // Refuse to allocate too large buffers."
              },
              {
                "name": "CommitBufferMemory",
                "type": "method",
                "start_line": 244,
                "end_line": 269,
                "line_count": 26,
                "signature": "bool js::CommitBufferMemory(void* dataEnd, size_t delta) { MOZ_ASSERT(delta); MOZ_ASSERT(delta % gc::SystemPageSize() == 0);"
              },
              {
                "name": "UnmapBufferMemory",
                "type": "method",
                "start_line": 271,
                "end_line": 296,
                "line_count": 26,
                "signature": "void js::UnmapBufferMemory(wasm::AddressType t, void* base, size_t mappedSize, size_t committedSize) { MOZ_ASSERT(mappedSize % gc::SystemPageSize() == 0);"
              },
              {
                "name": "IsArrayBuffer",
                "type": "function",
                "start_line": 431,
                "end_line": 433,
                "line_count": 3,
                "signature": "static bool IsArrayBuffer(HandleValue v) { return v.isObject() && v.toObject().is<ArrayBufferObject>(); }"
              },
              {
                "name": "IsResizableArrayBuffer",
                "type": "function",
                "start_line": 435,
                "end_line": 437,
                "line_count": 3,
                "signature": "static bool IsResizableArrayBuffer(HandleValue v) { return v.isObject() && v.toObject().is<ResizableArrayBufferObject>(); }"
              },
              {
                "name": "byteLengthGetterImpl",
                "type": "method",
                "start_line": 439,
                "end_line": 445,
                "line_count": 7,
                "signature": "MOZ_ALWAYS_INLINE bool ArrayBufferObject::byteLengthGetterImpl( JSContext* cx, const CallArgs& args) { MOZ_ASSERT(IsArrayBuffer(args.thisv()));"
              },
              {
                "name": "byteLengthGetter",
                "type": "method",
                "start_line": 447,
                "end_line": 451,
                "line_count": 5,
                "signature": "bool ArrayBufferObject::byteLengthGetter(JSContext* cx, unsigned argc, Value* vp) { CallArgs args = CallArgsFromVp(argc, vp);"
              },
              {
                "name": "maxByteLengthGetter",
                "type": "method",
                "start_line": 576,
                "end_line": 581,
                "line_count": 6,
                "signature": "bool ArrayBufferObject::maxByteLengthGetter(JSContext* cx, unsigned argc, Value* vp) { // Steps 1-3."
              },
              {
                "name": "resizableGetterImpl",
                "type": "method",
                "start_line": 588,
                "end_line": 596,
                "line_count": 9,
                "signature": "bool ArrayBufferObject::resizableGetterImpl(JSContext* cx, const CallArgs& args) { MOZ_ASSERT(IsArrayBuffer(args.thisv()));"
              },
              {
                "name": "resizableGetter",
                "type": "method",
                "start_line": 603,
                "end_line": 608,
                "line_count": 6,
                "signature": "bool ArrayBufferObject::resizableGetter(JSContext* cx, unsigned argc, Value* vp) { // Steps 1-3."
              },
              {
                "name": "detachedGetterImpl",
                "type": "method",
                "start_line": 615,
                "end_line": 623,
                "line_count": 9,
                "signature": "bool ArrayBufferObject::detachedGetterImpl(JSContext* cx, const CallArgs& args) { MOZ_ASSERT(IsArrayBuffer(args.thisv()));"
              },
              {
                "name": "detachedGetter",
                "type": "method",
                "start_line": 630,
                "end_line": 635,
                "line_count": 6,
                "signature": "bool ArrayBufferObject::detachedGetter(JSContext* cx, unsigned argc, Value* vp) { // Steps 1-3."
              },
              {
                "name": "immutableGetterImpl",
                "type": "method",
                "start_line": 643,
                "end_line": 651,
                "line_count": 9,
                "signature": "bool ArrayBufferObject::immutableGetterImpl(JSContext* cx, const CallArgs& args) { MOZ_ASSERT(IsArrayBuffer(args.thisv()));"
              },
              {
                "name": "immutableGetter",
                "type": "method",
                "start_line": 658,
                "end_line": 663,
                "line_count": 6,
                "signature": "bool ArrayBufferObject::immutableGetter(JSContext* cx, unsigned argc, Value* vp) { // Steps 1-3."
              },
              {
                "name": "transferImpl",
                "type": "method",
                "start_line": 671,
                "end_line": 685,
                "line_count": 15,
                "signature": "bool ArrayBufferObject::transferImpl(JSContext* cx, const CallArgs& args) { MOZ_ASSERT(IsArrayBuffer(args.thisv())); "
              },
              {
                "name": "transfer",
                "type": "method",
                "start_line": 692,
                "end_line": 695,
                "line_count": 4,
                "signature": "bool ArrayBufferObject::transfer(JSContext* cx, unsigned argc, Value* vp) { CallArgs args = CallArgsFromVp(argc, vp); return CallNonGenericMethod<IsArrayBuffer, transferImpl>(cx, args);"
              },
              {
                "name": "transferToFixedLengthImpl",
                "type": "method",
                "start_line": 702,
                "end_line": 717,
                "line_count": 16,
                "signature": "bool ArrayBufferObject::transferToFixedLengthImpl(JSContext* cx, const CallArgs& args) { MOZ_ASSERT(IsArrayBuffer(args.thisv()));"
              },
              {
                "name": "transferToFixedLength",
                "type": "method",
                "start_line": 724,
                "end_line": 729,
                "line_count": 6,
                "signature": "bool ArrayBufferObject::transferToFixedLength(JSContext* cx, unsigned argc, Value* vp) { CallArgs args = CallArgsFromVp(argc, vp);"
              },
              {
                "name": "transferToImmutableImpl",
                "type": "method",
                "start_line": 737,
                "end_line": 752,
                "line_count": 16,
                "signature": "bool ArrayBufferObject::transferToImmutableImpl(JSContext* cx, const CallArgs& args) { MOZ_ASSERT(IsArrayBuffer(args.thisv()));"
              },
              {
                "name": "transferToImmutable",
                "type": "method",
                "start_line": 759,
                "end_line": 763,
                "line_count": 5,
                "signature": "bool ArrayBufferObject::transferToImmutable(JSContext* cx, unsigned argc, Value* vp) { CallArgs args = CallArgsFromVp(argc, vp);"
              },
              {
                "name": "resizeImpl",
                "type": "method",
                "start_line": 771,
                "end_line": 833,
                "line_count": 63,
                "signature": "bool ArrayBufferObject::resizeImpl(JSContext* cx, const CallArgs& args) { MOZ_ASSERT(IsResizableArrayBuffer(args.thisv())); "
              },
              {
                "name": "resize",
                "type": "method",
                "start_line": 840,
                "end_line": 844,
                "line_count": 5,
                "signature": "bool ArrayBufferObject::resize(JSContext* cx, unsigned argc, Value* vp) { // Steps 1-3. CallArgs args = CallArgsFromVp(argc, vp);"
              },
              {
                "name": "IsArrayBufferSpecies",
                "type": "function",
                "start_line": 846,
                "end_line": 849,
                "line_count": 4,
                "signature": "static bool IsArrayBufferSpecies(JSContext* cx, JSFunction* species) { return IsSelfHostedFunctionWithName(species, cx->names().dollar_ArrayBufferSpecies_);"
              },
              {
                "name": "HasBuiltinArrayBufferSpecies",
                "type": "function",
                "start_line": 851,
                "end_line": 871,
                "line_count": 21,
                "signature": "static bool HasBuiltinArrayBufferSpecies(ArrayBufferObject* obj, JSContext* cx) { // Ensure `ArrayBuffer.prototype.constructor` and `ArrayBuffer[@@species]`"
              },
              {
                "name": "sliceImpl",
                "type": "method",
                "start_line": 878,
                "end_line": 1024,
                "line_count": 147,
                "signature": "bool ArrayBufferObject::sliceImpl(JSContext* cx, const CallArgs& args) { MOZ_ASSERT(IsArrayBuffer(args.thisv())); "
              },
              {
                "name": "slice",
                "type": "method",
                "start_line": 1031,
                "end_line": 1035,
                "line_count": 5,
                "signature": "bool ArrayBufferObject::slice(JSContext* cx, unsigned argc, Value* vp) { // Steps 1-3. CallArgs args = CallArgsFromVp(argc, vp);"
              },
              {
                "name": "sliceToImmutableImpl",
                "type": "method",
                "start_line": 1043,
                "end_line": 1108,
                "line_count": 66,
                "signature": "bool ArrayBufferObject::sliceToImmutableImpl(JSContext* cx, const CallArgs& args) { MOZ_ASSERT(IsArrayBuffer(args.thisv()));"
              },
              {
                "name": "sliceToImmutable",
                "type": "method",
                "start_line": 1115,
                "end_line": 1120,
                "line_count": 6,
                "signature": "bool ArrayBufferObject::sliceToImmutable(JSContext* cx, unsigned argc, Value* vp) { // Steps 1-3."
              },
              {
                "name": "fun_isView",
                "type": "method",
                "start_line": 1126,
                "end_line": 1131,
                "line_count": 6,
                "signature": "bool ArrayBufferObject::fun_isView(JSContext* cx, unsigned argc, Value* vp) { CallArgs args = CallArgsFromVp(argc, vp); args.rval().setBoolean(args.get(0).isObject() &&"
              },
              {
                "name": "class_constructor",
                "type": "method",
                "start_line": 1135,
                "end_line": 1212,
                "line_count": 78,
                "signature": "bool ArrayBufferObject::class_constructor(JSContext* cx, unsigned argc, Value* vp) { CallArgs args = CallArgsFromVp(argc, vp);"
              },
              {
                "name": "AllocateUninitializedArrayBufferContents",
                "type": "function",
                "start_line": 1216,
                "end_line": 1234,
                "line_count": 19,
                "signature": "static ArrayBufferContents AllocateUninitializedArrayBufferContents( JSContext* cx, size_t nbytes) { // First attempt a normal allocation."
              },
              {
                "name": "AllocateArrayBufferContents",
                "type": "function",
                "start_line": 1236,
                "end_line": 1252,
                "line_count": 17,
                "signature": "static ArrayBufferContents AllocateArrayBufferContents(JSContext* cx, size_t nbytes) { // First attempt a normal allocation."
              },
              {
                "name": "ReallocateArrayBufferContents",
                "type": "function",
                "start_line": 1254,
                "end_line": 1273,
                "line_count": 20,
                "signature": "static ArrayBufferContents ReallocateArrayBufferContents(JSContext* cx, uint8_t* old, size_t oldSize,"
              },
              {
                "name": "NewCopiedBufferContents",
                "type": "function",
                "start_line": 1275,
                "end_line": 1285,
                "line_count": 11,
                "signature": "static ArrayBufferContents NewCopiedBufferContents( JSContext* cx, Handle<ArrayBufferObject*> buffer) { ArrayBufferContents dataCopy ="
              },
              {
                "name": "detach",
                "type": "method",
                "start_line": 1288,
                "end_line": 1323,
                "line_count": 36,
                "signature": "void ArrayBufferObject::detach(JSContext* cx, Handle<ArrayBufferObject*> buffer) { cx->check(buffer);"
              },
              {
                "name": "resize",
                "type": "method",
                "start_line": 1325,
                "end_line": 1360,
                "line_count": 36,
                "signature": "void ResizableArrayBufferObject::resize(size_t newByteLength) { MOZ_ASSERT(!isPreparedForAsmJS()); MOZ_ASSERT(!isWasm());"
              },
              {
                "name": " true;\n}\n\nvoid Was",
                "type": "method",
                "start_line": 1533,
                "end_line": 1554,
                "line_count": 22,
                "signature": "[[nodiscard]] bool WasmArrayRawBuffer::growToPagesInPlace(Pages newPages) { size_t newSize = newPages.byteLength(); size_t oldSize = byteLength();"
              },
              {
                "name": " void* ",
                "type": "method",
                "start_line": 1556,
                "end_line": 1599,
                "line_count": 44,
                "signature": "void WasmArrayRawBuffer::discard(size_t byteOffset, size_t byteLen) { uint8_t* memBase = dataPointer(); "
              },
              {
                "name": "sePoint",
                "type": "method",
                "start_line": 1644,
                "end_line": 1657,
                "line_count": 14,
                "signature": "void WasmArrayRawBuffer::Release(void* mem) { WasmArrayRawBuffer* header = (WasmArrayRawBuffer*)((uint8_t*)mem - sizeof(WasmArrayRawBuffer));"
              },
              {
                "name": " MALLOCED_UNKNO",
                "type": "method",
                "start_line": 1788,
                "end_line": 1834,
                "line_count": 47,
                "signature": "bool ArrayBufferObject::prepareForAsmJS() { MOZ_ASSERT(byteLength() % wasm::PageSize == 0, \"prior size checking should have guaranteed page-size multiple\");"
              },
              {
                "name": "ect::inlineDataPoint",
                "type": "method",
                "start_line": 1836,
                "end_line": 1841,
                "line_count": 6,
                "signature": "ArrayBufferObject::BufferContents ArrayBufferObject::createMappedContents( int fd, size_t offset, size_t length) { void* data ="
              },
              {
                "name": "asing.\n      brea",
                "type": "method",
                "start_line": 1859,
                "end_line": 1861,
                "line_count": 3,
                "signature": "SharedMem<uint8_t*> ArrayBufferObject::dataPointerShared() const { return SharedMem<uint8_t*>::unshared(getFixedSlot(DATA_SLOT).toPrivate()); }"
              },
              {
                "name": "ed by, well",
                "type": "method",
                "start_line": 1871,
                "end_line": 1909,
                "line_count": 39,
                "signature": "void ArrayBufferObject::releaseData(JS::GCContext* gcx) { switch (bufferKind()) { case INLINE_DATA:"
              },
              {
                "name": "  if (isMapped",
                "type": "method",
                "start_line": 1911,
                "end_line": 1920,
                "line_count": 10,
                "signature": "void ArrayBufferObject::setDataPointer(BufferContents contents) { setFixedSlot(DATA_SLOT, PrivateValue(contents.data())); setFlags((flags() & ~KIND_MASK) | contents.kind());"
              },
              {
                "name": "MappedSize",
                "type": "method",
                "start_line": 1922,
                "end_line": 1924,
                "line_count": 3,
                "signature": "size_t ArrayBufferObject::byteLength() const { return size_t(getFixedSlot(BYTE_LENGTH_SLOT).toPrivate()); }"
              },
              {
                "name": "\nAddressType Ar",
                "type": "method",
                "start_line": 1926,
                "end_line": 1934,
                "line_count": 9,
                "signature": "inline size_t ArrayBufferObject::associatedBytes() const { if (isMalloced()) { return maxByteLength();"
              },
              {
                "name": "smPages() con",
                "type": "method",
                "start_line": 1936,
                "end_line": 1939,
                "line_count": 4,
                "signature": "void ArrayBufferObject::setByteLength(size_t length) { MOZ_ASSERT(length <= ArrayBufferObject::ByteLengthLimit); setFixedSlot(BYTE_LENGTH_SLOT, PrivateValue(length));"
              },
              {
                "name": "ages ArrayBuff",
                "type": "method",
                "start_line": 1941,
                "end_line": 1946,
                "line_count": 6,
                "signature": "size_t ArrayBufferObject::wasmMappedSize() const { if (isWasm()) { return contents().wasmBuffer()->mappedSize();"
              },
              {
                "name": "ForAsmJS());\n  ",
                "type": "method",
                "start_line": 1948,
                "end_line": 1954,
                "line_count": 7,
                "signature": "AddressType ArrayBufferObject::wasmAddressType() const { if (isWasm()) { return contents().wasmBuffer()->addressType();"
              },
              {
                "name": "();\n  }\n ",
                "type": "method",
                "start_line": 1956,
                "end_line": 1962,
                "line_count": 7,
                "signature": "Pages ArrayBufferObject::wasmPages() const { if (isWasm()) { return contents().wasmBuffer()->pages();"
              },
              {
                "name": "is<ArrayBufferObjec",
                "type": "method",
                "start_line": 1964,
                "end_line": 1970,
                "line_count": 7,
                "signature": "Pages ArrayBufferObject::wasmClampedMaxPages() const { if (isWasm()) { return contents().wasmBuffer()->clampedMaxPages();"
              },
              {
                "name": "eShared* buf) {\n  ",
                "type": "method",
                "start_line": 1972,
                "end_line": 1978,
                "line_count": 7,
                "signature": "Maybe<Pages> ArrayBufferObject::wasmSourceMaxPages() const { if (isWasm()) { return contents().wasmBuffer()->sourceMaxPages();"
              },
              {
                "name": "ArrayBufferObjectMaybeSha",
                "type": "method",
                "start_line": 1980,
                "end_line": 1985,
                "line_count": 6,
                "signature": "size_t js::WasmArrayBufferMappedSize(const ArrayBufferObjectMaybeShared* buf) { if (buf->is<ArrayBufferObject>()) { return buf->as<ArrayBufferObject>().wasmMappedSize();"
              },
              {
                "name": " ArrayBufferObjectMaybeSha",
                "type": "method",
                "start_line": 1987,
                "end_line": 1993,
                "line_count": 7,
                "signature": "AddressType js::WasmArrayBufferAddressType( const ArrayBufferObjectMaybeShared* buf) { if (buf->is<ArrayBufferObject>()) {"
              },
              {
                "name": "axPages(\n    const A",
                "type": "method",
                "start_line": 1994,
                "end_line": 1999,
                "line_count": 6,
                "signature": "Pages js::WasmArrayBufferPages(const ArrayBufferObjectMaybeShared* buf) { if (buf->is<ArrayBufferObject>()) { return buf->as<ArrayBufferObject>().wasmPages();"
              },
              {
                "name": "tatic void CheckStealPrecondit",
                "type": "method",
                "start_line": 2000,
                "end_line": 2006,
                "line_count": 7,
                "signature": "Pages js::WasmArrayBufferClampedMaxPages( const ArrayBufferObjectMaybeShared* buf) { if (buf->is<ArrayBufferObject>()) {"
              },
              {
                "name": "from an immutable buffer\");\n ",
                "type": "method",
                "start_line": 2007,
                "end_line": 2013,
                "line_count": 7,
                "signature": "Maybe<Pages> js::WasmArrayBufferSourceMaxPages( const ArrayBufferObjectMaybeShared* buf) { if (buf->is<ArrayBufferObject>()) {"
              },
              {
                "name": "\nArrayBufferObject* Arr",
                "type": "function",
                "start_line": 2015,
                "end_line": 2025,
                "line_count": 11,
                "signature": "static void CheckStealPreconditions(Handle<ArrayBufferObject*> buffer, JSContext* cx) { cx->check(buffer);"
              },
              {
                "name": "turn js::gc",
                "type": "method",
                "start_line": 2161,
                "end_line": 2165,
                "line_count": 5,
                "signature": "void ArrayBufferObject::wasmDiscard(Handle<ArrayBufferObject*> buf, uint64_t byteOffset, uint64_t byteLen) { MOZ_ASSERT(buf->isWasm());"
              },
              {
                "name": "lass ",
                "type": "method",
                "start_line": 2167,
                "end_line": 2169,
                "line_count": 3,
                "signature": "uint32_t ArrayBufferObject::flags() const { return uint32_t(getFixedSlot(FLAGS_SLOT).toInt32()); }"
              },
              {
                "name": "to_,\n   ",
                "type": "method",
                "start_line": 2171,
                "end_line": 2173,
                "line_count": 3,
                "signature": "void ArrayBufferObject::setFlags(uint32_t flags) { setFixedSlot(FLAGS_SLOT, Int32Value(flags)); }"
              },
              {
                "name": "Kind::ARRAYBUFFER4 ||\n    ",
                "type": "function",
                "start_line": 2175,
                "end_line": 2186,
                "line_count": 12,
                "signature": "static constexpr js::gc::AllocKind GetArrayBufferGCObjectKind(size_t numSlots) { if (numSlots <= 4) { return js::gc::AllocKind::ARRAYBUFFER4;"
              },
              {
                "name": "h the object by repurposing fixe",
                "type": "method",
                "start_line": 2371,
                "end_line": 2429,
                "line_count": 59,
                "signature": "/* static */ std::tuple<ArrayBufferType*, uint8_t*> ArrayBufferObject::createUninitializedBufferAndData( JSContext* cx, size_t nbytes, AutoSetNewObjectMetadata&,"
              },
              {
                "name": " metadata, proto);\n",
                "type": "method",
                "start_line": 2432,
                "end_line": 2458,
                "line_count": 27,
                "signature": "/* static */ std::tuple<ArrayBufferType*, uint8_t*> ArrayBufferObject::createBufferAndData( JSContext* cx, size_t nbytes, AutoSetNewObjectMetadata& metadata,"
              },
              {
                "name": "e allocating the ma",
                "type": "method",
                "start_line": 2461,
                "end_line": 2493,
                "line_count": 33,
                "signature": "/* static */ std::tuple<ResizableArrayBufferObject*, uint8_t*> ResizableArrayBufferObject::createBufferAndData( JSContext* cx, size_t byteLength, size_t maxByteLength,"
              },
              {
                "name": "Contents contents = buffer->co",
                "type": "method",
                "start_line": 3026,
                "end_line": 3087,
                "line_count": 62,
                "signature": "/* static */ ArrayBufferObject::BufferContents ArrayBufferObject::extractStructuredCloneContents( JSContext* cx, Handle<ArrayBufferObject*> buffer) {"
              },
              {
                "name": " != INLINE_DATA",
                "type": "method",
                "start_line": 3090,
                "end_line": 3135,
                "line_count": 46,
                "signature": "bool ArrayBufferObject::ensureNonInline(JSContext* cx, Handle<ArrayBufferObject*> buffer) { if (buffer->isDetached() || buffer->isPreparedForAsmJS()) {"
              },
              {
                "name": "mallocSizeOf(buffer.da",
                "type": "method",
                "start_line": 3138,
                "end_line": 3182,
                "line_count": 45,
                "signature": "void ArrayBufferObject::addSizeOfExcludingThis( JSObject* obj, mozilla::MallocSizeOf mallocSizeOf, JS::ClassInfo* info, JS::RuntimeSizes* runtimeSizes) {"
              },
              {
                "name": ">byteLen",
                "type": "method",
                "start_line": 3185,
                "end_line": 3187,
                "line_count": 3,
                "signature": "void ArrayBufferObject::finalize(JS::GCContext* gcx, JSObject* obj) { obj->as<ArrayBufferObject>().releaseData(gcx); }"
              },
              {
                "name": "        ",
                "type": "method",
                "start_line": 3190,
                "end_line": 3202,
                "line_count": 13,
                "signature": "void ArrayBufferObject::copyData(ArrayBufferObject* toBuffer, size_t toIndex, ArrayBufferObject* fromBuffer, size_t fromIndex, size_t count) {"
              },
              {
                "name": "!nursery.is",
                "type": "method",
                "start_line": 3206,
                "end_line": 3226,
                "line_count": 21,
                "signature": "size_t ArrayBufferObject::objectMoved(JSObject* obj, JSObject* old) { auto& dst = obj->as<ArrayBufferType>(); const auto& src = old->as<ArrayBufferType>();"
              },
              {
                "name": "own) {\n  swi",
                "type": "method",
                "start_line": 3234,
                "end_line": 3236,
                "line_count": 3,
                "signature": "void ArrayBufferObject::setFirstView(ArrayBufferViewObject* view) { setFixedSlot(FIRST_VIEW_SLOT, ObjectOrNullValue(view)); }"
              },
              {
                "name": "rrayBuf",
                "type": "method",
                "start_line": 3238,
                "end_line": 3245,
                "line_count": 8,
                "signature": "bool ArrayBufferObject::addView(JSContext* cx, ArrayBufferViewObject* view) { if (!firstView()) { setFirstView(view);"
              },
              {
                "name": "\");\n      break;\n ",
                "type": "function",
                "start_line": 3250,
                "end_line": 3281,
                "line_count": 32,
                "signature": "void BufferKindToString(ArrayBufferObject::BufferKind kind, KnownF known, UnknownF unknown) { switch (kind) {"
              },
              {
                "name": " break;\n    }\n  }\n}\n\nv",
                "type": "function",
                "start_line": 3284,
                "end_line": 3302,
                "line_count": 19,
                "signature": "void ForEachArrayBufferFlag(uint32_t flags, KnownF known, UnknownF unknown) { for (uint32_t i = ArrayBufferObject::ArrayBufferFlags::BUFFER_KIND_MASK + 1; i; i = i << 1) {"
              },
              {
                "name": "_t value) { j",
                "type": "method",
                "start_line": 3304,
                "end_line": 3327,
                "line_count": 24,
                "signature": "void ArrayBufferObject::dumpOwnFields(js::JSONPrinter& json) const { json.formatProperty(\"byteLength\", \"%zu\", size_t(getFixedSlot(BYTE_LENGTH_SLOT).toPrivate()));"
              },
              {
                "name": "first = false;\n     ",
                "type": "method",
                "start_line": 3329,
                "end_line": 3364,
                "line_count": 36,
                "signature": "void ArrayBufferObject::dumpOwnStringContent(js::GenericPrinter& out) const { out.printf(\"byteLength=%zu, \", size_t(getFixedSlot(BYTE_LENGTH_SLOT).toPrivate()));"
              },
              {
                "name": "urseryV",
                "type": "method",
                "start_line": 3443,
                "end_line": 3480,
                "line_count": 38,
                "signature": "bool InnerViewTable::addView(JSContext* cx, ArrayBufferObject* buffer, ArrayBufferViewObject* view) { // ArrayBufferObject entries are only added when there are multiple views."
              },
              {
                "name": "ject* buffe",
                "type": "method",
                "start_line": 3491,
                "end_line": 3496,
                "line_count": 6,
                "signature": "void InnerViewTable::removeViews(ArrayBufferObject* buffer) { auto ptr = map.lookup(buffer); MOZ_ASSERT(ptr);"
              },
              {
                "name": "fterMinor",
                "type": "method",
                "start_line": 3498,
                "end_line": 3502,
                "line_count": 5,
                "signature": "bool InnerViewTable::traceWeak(JSTracer* trc) { nurseryKeys.traceWeak(trc); map.traceWeak(trc);"
              },
              {
                "name": "at every map entr",
                "type": "method",
                "start_line": 3504,
                "end_line": 3531,
                "line_count": 28,
                "signature": "void InnerViewTable::sweepAfterMinorGC(JSTracer* trc) { MOZ_ASSERT(needsSweepAfterMinorGC()); "
              },
              {
                "name": "    vectorSize += r.fr",
                "type": "method",
                "start_line": 3533,
                "end_line": 3545,
                "line_count": 13,
                "signature": "bool InnerViewTable::sweepViewsAfterMinorGC(JSTracer* trc, ArrayBufferObject* buffer, Views& views) {"
              },
              {
                "name": "ferByteLength(JSObj",
                "type": "method",
                "start_line": 3547,
                "end_line": 3555,
                "line_count": 9,
                "signature": "size_t InnerViewTable::sizeOfExcludingThis(mozilla::MallocSizeOf mallocSizeOf) { size_t vectorSize = 0; for (auto r = map.all(); !r.empty(); r.popFront()) {"
              },
              {
                "name": "tatic ArrayBufferObject*",
                "type": "method",
                "start_line": 3562,
                "end_line": 3565,
                "line_count": 4,
                "signature": "JS_PUBLIC_API size_t JS::GetArrayBufferByteLength(JSObject* obj) { ArrayBufferObject* aobj = obj->maybeUnwrapAs<ArrayBufferObject>(); return aobj ? aobj->byteLength() : 0;"
              },
              {
                "name": "ge, nullptr,\n    ",
                "type": "method",
                "start_line": 3595,
                "end_line": 3625,
                "line_count": 31,
                "signature": "JS_PUBLIC_API bool JS::DetachArrayBuffer(JSContext* cx, HandleObject obj) { AssertHeapIsIdle(); CHECK_THREAD(cx);"
              },
              {
                "name": "fferObject>();\n  if (!aobj) {\n",
                "type": "method",
                "start_line": 3627,
                "end_line": 3638,
                "line_count": 12,
                "signature": "JS_PUBLIC_API bool JS::HasDefinedArrayBufferDetachKey(JSContext* cx, HandleObject obj, bool* isDefined) {"
              },
              {
                "name": "rayBufferWithContents(\n    ",
                "type": "method",
                "start_line": 3640,
                "end_line": 3647,
                "line_count": 8,
                "signature": "JS_PUBLIC_API bool JS::IsDetachedArrayBufferObject(JSObject* obj) { ArrayBufferObject* aobj = obj->maybeUnwrapIf<ArrayBufferObject>(); if (!aobj) {"
              },
              {
                "name": "                   ",
                "type": "method",
                "start_line": 3747,
                "end_line": 3749,
                "line_count": 3,
                "signature": "JS_PUBLIC_API bool JS::IsArrayBufferObject(JSObject* obj) { return obj->canUnwrapAs<ArrayBufferObject>(); }"
              },
              {
                "name": "(obj);\n\n  Rooted<A",
                "type": "method",
                "start_line": 3751,
                "end_line": 3753,
                "line_count": 3,
                "signature": "JS_PUBLIC_API bool JS::ArrayBufferHasData(JSObject* obj) { return !obj->unwrapAs<ArrayBufferObject>().isDetached(); }"
              },
              {
                "name": "                                ",
                "type": "method",
                "start_line": 3820,
                "end_line": 3823,
                "line_count": 4,
                "signature": "JS_PUBLIC_API void JS::ReleaseMappedArrayBufferContents(void* contents, size_t length) { gc::DeallocateMappedContent(contents, length);"
              },
              {
                "name": "ta = aobj->dataPointer();",
                "type": "method",
                "start_line": 3825,
                "end_line": 3832,
                "line_count": 8,
                "signature": "JS_PUBLIC_API bool JS::IsMappedArrayBufferObject(JSObject* obj) { ArrayBufferObject* aobj = obj->maybeUnwrapIf<ArrayBufferObject>(); if (!aobj) {"
              },
              {
                "name": "ffer::ResizableUnsharedClas",
                "type": "method",
                "start_line": 3848,
                "end_line": 3856,
                "line_count": 9,
                "signature": "JS_PUBLIC_API void JS::GetArrayBufferLengthAndData(JSObject* obj, size_t* length, bool* isSharedMemory,"
              },
              {
                "name": ");\n  if (!unwrapped",
                "type": "method",
                "start_line": 3899,
                "end_line": 3949,
                "line_count": 51,
                "signature": "bool JS::ArrayBufferCopyData(JSContext* cx, Handle<JSObject*> toBlock, size_t toIndex, Handle<JSObject*> fromBlock, size_t fromIndex, size_t count) {"
              }
            ]
          },
          "hunks_count": 1,
          "hunk_ranges": [
            "@@ -546,19 @@"
          ]
        }
      ],
      "regressor_commits": [
        {
          "commit_hash": "75d829afb4b0",
          "full_hash": "75d829afb4b06a3a8b7e91ea15c8a0cf34665fb7",
          "parent_hash": "896c8ee9171db6fb15ab84ff673c1272c46f28b2",
          "commit_type": "regressor",
          "filepath": "js/src/vm/ArrayBufferObject.cpp",
          "diff_found": true,
          "diff_path": "/Users/sidiqafekrat/Mozilla_crashAnalyzer_BugBug/method2_bugzilla_bugs/outputs/step5_extracted_diffs/bug_1988694/regressor_commits/regressor_1969509_75d829afb4b0/js_src_vm_ArrayBufferObject.cpp.diff",
          "methods_count": 95,
          "matched_methods": {
            "fully_modified": [],
            "partially_modified": [
              {
                "name": "maxByteLengthGetterImpl",
                "type": "method",
                "start_line": 543,
                "end_line": 569,
                "line_count": 27,
                "signature": "bool ArrayBufferObject::maxByteLengthGetterImpl(JSContext* cx, const CallArgs& args) { MOZ_ASSERT(IsArrayBuffer(args.thisv()));",
                "changed_lines": [
                  546,
                  547,
                  548,
                  549,
                  550,
                  551,
                  552,
                  553,
                  554,
                  555,
                  556,
                  557,
                  558,
                  559,
                  560,
                  561,
                  562,
                  563,
                  564
                ],
                "overlap_count": 19,
                "overlap_percentage": 70.4
              }
            ],
            "unmodified": [
              {
                "name": "WasmReservedBytes",
                "type": "method",
                "start_line": 160,
                "end_line": 160,
                "line_count": 1,
                "signature": "uint64_t js::WasmReservedBytes() { return wasmReservedBytes; }  [[nodiscard]] static bool CheckArrayBufferTooLarge(JSContext* cx,"
              },
              {
                "name": "CheckArrayBufferTooLarge",
                "type": "function",
                "start_line": 162,
                "end_line": 172,
                "line_count": 11,
                "signature": "[[nodiscard]] static bool CheckArrayBufferTooLarge(JSContext* cx, uint64_t nbytes) { // Refuse to allocate too large buffers."
              },
              {
                "name": "CommitBufferMemory",
                "type": "method",
                "start_line": 244,
                "end_line": 269,
                "line_count": 26,
                "signature": "bool js::CommitBufferMemory(void* dataEnd, size_t delta) { MOZ_ASSERT(delta); MOZ_ASSERT(delta % gc::SystemPageSize() == 0);"
              },
              {
                "name": "UnmapBufferMemory",
                "type": "method",
                "start_line": 271,
                "end_line": 296,
                "line_count": 26,
                "signature": "void js::UnmapBufferMemory(wasm::AddressType t, void* base, size_t mappedSize, size_t committedSize) { MOZ_ASSERT(mappedSize % gc::SystemPageSize() == 0);"
              },
              {
                "name": "IsArrayBuffer",
                "type": "function",
                "start_line": 431,
                "end_line": 433,
                "line_count": 3,
                "signature": "static bool IsArrayBuffer(HandleValue v) { return v.isObject() && v.toObject().is<ArrayBufferObject>(); }"
              },
              {
                "name": "IsResizableArrayBuffer",
                "type": "function",
                "start_line": 435,
                "end_line": 437,
                "line_count": 3,
                "signature": "static bool IsResizableArrayBuffer(HandleValue v) { return v.isObject() && v.toObject().is<ResizableArrayBufferObject>(); }"
              },
              {
                "name": "byteLengthGetterImpl",
                "type": "method",
                "start_line": 439,
                "end_line": 445,
                "line_count": 7,
                "signature": "MOZ_ALWAYS_INLINE bool ArrayBufferObject::byteLengthGetterImpl( JSContext* cx, const CallArgs& args) { MOZ_ASSERT(IsArrayBuffer(args.thisv()));"
              },
              {
                "name": "byteLengthGetter",
                "type": "method",
                "start_line": 447,
                "end_line": 451,
                "line_count": 5,
                "signature": "bool ArrayBufferObject::byteLengthGetter(JSContext* cx, unsigned argc, Value* vp) { CallArgs args = CallArgsFromVp(argc, vp);"
              },
              {
                "name": "maxByteLengthGetter",
                "type": "method",
                "start_line": 576,
                "end_line": 581,
                "line_count": 6,
                "signature": "bool ArrayBufferObject::maxByteLengthGetter(JSContext* cx, unsigned argc, Value* vp) { // Steps 1-3."
              },
              {
                "name": "resizableGetterImpl",
                "type": "method",
                "start_line": 588,
                "end_line": 596,
                "line_count": 9,
                "signature": "bool ArrayBufferObject::resizableGetterImpl(JSContext* cx, const CallArgs& args) { MOZ_ASSERT(IsArrayBuffer(args.thisv()));"
              },
              {
                "name": "resizableGetter",
                "type": "method",
                "start_line": 603,
                "end_line": 608,
                "line_count": 6,
                "signature": "bool ArrayBufferObject::resizableGetter(JSContext* cx, unsigned argc, Value* vp) { // Steps 1-3."
              },
              {
                "name": "detachedGetterImpl",
                "type": "method",
                "start_line": 615,
                "end_line": 623,
                "line_count": 9,
                "signature": "bool ArrayBufferObject::detachedGetterImpl(JSContext* cx, const CallArgs& args) { MOZ_ASSERT(IsArrayBuffer(args.thisv()));"
              },
              {
                "name": "detachedGetter",
                "type": "method",
                "start_line": 630,
                "end_line": 635,
                "line_count": 6,
                "signature": "bool ArrayBufferObject::detachedGetter(JSContext* cx, unsigned argc, Value* vp) { // Steps 1-3."
              },
              {
                "name": "immutableGetterImpl",
                "type": "method",
                "start_line": 643,
                "end_line": 651,
                "line_count": 9,
                "signature": "bool ArrayBufferObject::immutableGetterImpl(JSContext* cx, const CallArgs& args) { MOZ_ASSERT(IsArrayBuffer(args.thisv()));"
              },
              {
                "name": "immutableGetter",
                "type": "method",
                "start_line": 658,
                "end_line": 663,
                "line_count": 6,
                "signature": "bool ArrayBufferObject::immutableGetter(JSContext* cx, unsigned argc, Value* vp) { // Steps 1-3."
              },
              {
                "name": "transferImpl",
                "type": "method",
                "start_line": 671,
                "end_line": 685,
                "line_count": 15,
                "signature": "bool ArrayBufferObject::transferImpl(JSContext* cx, const CallArgs& args) { MOZ_ASSERT(IsArrayBuffer(args.thisv())); "
              },
              {
                "name": "transfer",
                "type": "method",
                "start_line": 692,
                "end_line": 695,
                "line_count": 4,
                "signature": "bool ArrayBufferObject::transfer(JSContext* cx, unsigned argc, Value* vp) { CallArgs args = CallArgsFromVp(argc, vp); return CallNonGenericMethod<IsArrayBuffer, transferImpl>(cx, args);"
              },
              {
                "name": "transferToFixedLengthImpl",
                "type": "method",
                "start_line": 702,
                "end_line": 717,
                "line_count": 16,
                "signature": "bool ArrayBufferObject::transferToFixedLengthImpl(JSContext* cx, const CallArgs& args) { MOZ_ASSERT(IsArrayBuffer(args.thisv()));"
              },
              {
                "name": "transferToFixedLength",
                "type": "method",
                "start_line": 724,
                "end_line": 729,
                "line_count": 6,
                "signature": "bool ArrayBufferObject::transferToFixedLength(JSContext* cx, unsigned argc, Value* vp) { CallArgs args = CallArgsFromVp(argc, vp);"
              },
              {
                "name": "transferToImmutableImpl",
                "type": "method",
                "start_line": 737,
                "end_line": 752,
                "line_count": 16,
                "signature": "bool ArrayBufferObject::transferToImmutableImpl(JSContext* cx, const CallArgs& args) { MOZ_ASSERT(IsArrayBuffer(args.thisv()));"
              },
              {
                "name": "transferToImmutable",
                "type": "method",
                "start_line": 759,
                "end_line": 763,
                "line_count": 5,
                "signature": "bool ArrayBufferObject::transferToImmutable(JSContext* cx, unsigned argc, Value* vp) { CallArgs args = CallArgsFromVp(argc, vp);"
              },
              {
                "name": "resizeImpl",
                "type": "method",
                "start_line": 771,
                "end_line": 833,
                "line_count": 63,
                "signature": "bool ArrayBufferObject::resizeImpl(JSContext* cx, const CallArgs& args) { MOZ_ASSERT(IsResizableArrayBuffer(args.thisv())); "
              },
              {
                "name": "resize",
                "type": "method",
                "start_line": 840,
                "end_line": 844,
                "line_count": 5,
                "signature": "bool ArrayBufferObject::resize(JSContext* cx, unsigned argc, Value* vp) { // Steps 1-3. CallArgs args = CallArgsFromVp(argc, vp);"
              },
              {
                "name": "IsArrayBufferSpecies",
                "type": "function",
                "start_line": 846,
                "end_line": 849,
                "line_count": 4,
                "signature": "static bool IsArrayBufferSpecies(JSContext* cx, JSFunction* species) { return IsSelfHostedFunctionWithName(species, cx->names().dollar_ArrayBufferSpecies_);"
              },
              {
                "name": "HasBuiltinArrayBufferSpecies",
                "type": "function",
                "start_line": 851,
                "end_line": 871,
                "line_count": 21,
                "signature": "static bool HasBuiltinArrayBufferSpecies(ArrayBufferObject* obj, JSContext* cx) { // Ensure `ArrayBuffer.prototype.constructor` and `ArrayBuffer[@@species]`"
              },
              {
                "name": "sliceImpl",
                "type": "method",
                "start_line": 878,
                "end_line": 1024,
                "line_count": 147,
                "signature": "bool ArrayBufferObject::sliceImpl(JSContext* cx, const CallArgs& args) { MOZ_ASSERT(IsArrayBuffer(args.thisv())); "
              },
              {
                "name": "slice",
                "type": "method",
                "start_line": 1031,
                "end_line": 1035,
                "line_count": 5,
                "signature": "bool ArrayBufferObject::slice(JSContext* cx, unsigned argc, Value* vp) { // Steps 1-3. CallArgs args = CallArgsFromVp(argc, vp);"
              },
              {
                "name": "sliceToImmutableImpl",
                "type": "method",
                "start_line": 1043,
                "end_line": 1108,
                "line_count": 66,
                "signature": "bool ArrayBufferObject::sliceToImmutableImpl(JSContext* cx, const CallArgs& args) { MOZ_ASSERT(IsArrayBuffer(args.thisv()));"
              },
              {
                "name": "sliceToImmutable",
                "type": "method",
                "start_line": 1115,
                "end_line": 1120,
                "line_count": 6,
                "signature": "bool ArrayBufferObject::sliceToImmutable(JSContext* cx, unsigned argc, Value* vp) { // Steps 1-3."
              },
              {
                "name": "fun_isView",
                "type": "method",
                "start_line": 1126,
                "end_line": 1131,
                "line_count": 6,
                "signature": "bool ArrayBufferObject::fun_isView(JSContext* cx, unsigned argc, Value* vp) { CallArgs args = CallArgsFromVp(argc, vp); args.rval().setBoolean(args.get(0).isObject() &&"
              },
              {
                "name": "class_constructor",
                "type": "method",
                "start_line": 1135,
                "end_line": 1212,
                "line_count": 78,
                "signature": "bool ArrayBufferObject::class_constructor(JSContext* cx, unsigned argc, Value* vp) { CallArgs args = CallArgsFromVp(argc, vp);"
              },
              {
                "name": "AllocateUninitializedArrayBufferContents",
                "type": "function",
                "start_line": 1216,
                "end_line": 1234,
                "line_count": 19,
                "signature": "static ArrayBufferContents AllocateUninitializedArrayBufferContents( JSContext* cx, size_t nbytes) { // First attempt a normal allocation."
              },
              {
                "name": "AllocateArrayBufferContents",
                "type": "function",
                "start_line": 1236,
                "end_line": 1252,
                "line_count": 17,
                "signature": "static ArrayBufferContents AllocateArrayBufferContents(JSContext* cx, size_t nbytes) { // First attempt a normal allocation."
              },
              {
                "name": "ReallocateArrayBufferContents",
                "type": "function",
                "start_line": 1254,
                "end_line": 1273,
                "line_count": 20,
                "signature": "static ArrayBufferContents ReallocateArrayBufferContents(JSContext* cx, uint8_t* old, size_t oldSize,"
              },
              {
                "name": "NewCopiedBufferContents",
                "type": "function",
                "start_line": 1275,
                "end_line": 1285,
                "line_count": 11,
                "signature": "static ArrayBufferContents NewCopiedBufferContents( JSContext* cx, Handle<ArrayBufferObject*> buffer) { ArrayBufferContents dataCopy ="
              },
              {
                "name": "detach",
                "type": "method",
                "start_line": 1288,
                "end_line": 1323,
                "line_count": 36,
                "signature": "void ArrayBufferObject::detach(JSContext* cx, Handle<ArrayBufferObject*> buffer) { cx->check(buffer);"
              },
              {
                "name": "resize",
                "type": "method",
                "start_line": 1325,
                "end_line": 1360,
                "line_count": 36,
                "signature": "void ResizableArrayBufferObject::resize(size_t newByteLength) { MOZ_ASSERT(!isPreparedForAsmJS()); MOZ_ASSERT(!isWasm());"
              },
              {
                "name": " true;\n}\n\nvoid Was",
                "type": "method",
                "start_line": 1533,
                "end_line": 1554,
                "line_count": 22,
                "signature": "[[nodiscard]] bool WasmArrayRawBuffer::growToPagesInPlace(Pages newPages) { size_t newSize = newPages.byteLength(); size_t oldSize = byteLength();"
              },
              {
                "name": " void* ",
                "type": "method",
                "start_line": 1556,
                "end_line": 1599,
                "line_count": 44,
                "signature": "void WasmArrayRawBuffer::discard(size_t byteOffset, size_t byteLen) { uint8_t* memBase = dataPointer(); "
              },
              {
                "name": "sePoint",
                "type": "method",
                "start_line": 1644,
                "end_line": 1657,
                "line_count": 14,
                "signature": "void WasmArrayRawBuffer::Release(void* mem) { WasmArrayRawBuffer* header = (WasmArrayRawBuffer*)((uint8_t*)mem - sizeof(WasmArrayRawBuffer));"
              },
              {
                "name": " MALLOCED_UNKNO",
                "type": "method",
                "start_line": 1788,
                "end_line": 1834,
                "line_count": 47,
                "signature": "bool ArrayBufferObject::prepareForAsmJS() { MOZ_ASSERT(byteLength() % wasm::PageSize == 0, \"prior size checking should have guaranteed page-size multiple\");"
              },
              {
                "name": "ect::inlineDataPoint",
                "type": "method",
                "start_line": 1836,
                "end_line": 1841,
                "line_count": 6,
                "signature": "ArrayBufferObject::BufferContents ArrayBufferObject::createMappedContents( int fd, size_t offset, size_t length) { void* data ="
              },
              {
                "name": "asing.\n      brea",
                "type": "method",
                "start_line": 1859,
                "end_line": 1861,
                "line_count": 3,
                "signature": "SharedMem<uint8_t*> ArrayBufferObject::dataPointerShared() const { return SharedMem<uint8_t*>::unshared(getFixedSlot(DATA_SLOT).toPrivate()); }"
              },
              {
                "name": "ed by, well",
                "type": "method",
                "start_line": 1871,
                "end_line": 1909,
                "line_count": 39,
                "signature": "void ArrayBufferObject::releaseData(JS::GCContext* gcx) { switch (bufferKind()) { case INLINE_DATA:"
              },
              {
                "name": "  if (isMapped",
                "type": "method",
                "start_line": 1911,
                "end_line": 1920,
                "line_count": 10,
                "signature": "void ArrayBufferObject::setDataPointer(BufferContents contents) { setFixedSlot(DATA_SLOT, PrivateValue(contents.data())); setFlags((flags() & ~KIND_MASK) | contents.kind());"
              },
              {
                "name": "MappedSize",
                "type": "method",
                "start_line": 1922,
                "end_line": 1924,
                "line_count": 3,
                "signature": "size_t ArrayBufferObject::byteLength() const { return size_t(getFixedSlot(BYTE_LENGTH_SLOT).toPrivate()); }"
              },
              {
                "name": "\nAddressType Ar",
                "type": "method",
                "start_line": 1926,
                "end_line": 1934,
                "line_count": 9,
                "signature": "inline size_t ArrayBufferObject::associatedBytes() const { if (isMalloced()) { return maxByteLength();"
              },
              {
                "name": "smPages() con",
                "type": "method",
                "start_line": 1936,
                "end_line": 1939,
                "line_count": 4,
                "signature": "void ArrayBufferObject::setByteLength(size_t length) { MOZ_ASSERT(length <= ArrayBufferObject::ByteLengthLimit); setFixedSlot(BYTE_LENGTH_SLOT, PrivateValue(length));"
              },
              {
                "name": "ages ArrayBuff",
                "type": "method",
                "start_line": 1941,
                "end_line": 1946,
                "line_count": 6,
                "signature": "size_t ArrayBufferObject::wasmMappedSize() const { if (isWasm()) { return contents().wasmBuffer()->mappedSize();"
              },
              {
                "name": "ForAsmJS());\n  ",
                "type": "method",
                "start_line": 1948,
                "end_line": 1954,
                "line_count": 7,
                "signature": "AddressType ArrayBufferObject::wasmAddressType() const { if (isWasm()) { return contents().wasmBuffer()->addressType();"
              },
              {
                "name": "();\n  }\n ",
                "type": "method",
                "start_line": 1956,
                "end_line": 1962,
                "line_count": 7,
                "signature": "Pages ArrayBufferObject::wasmPages() const { if (isWasm()) { return contents().wasmBuffer()->pages();"
              },
              {
                "name": "is<ArrayBufferObjec",
                "type": "method",
                "start_line": 1964,
                "end_line": 1970,
                "line_count": 7,
                "signature": "Pages ArrayBufferObject::wasmClampedMaxPages() const { if (isWasm()) { return contents().wasmBuffer()->clampedMaxPages();"
              },
              {
                "name": "eShared* buf) {\n  ",
                "type": "method",
                "start_line": 1972,
                "end_line": 1978,
                "line_count": 7,
                "signature": "Maybe<Pages> ArrayBufferObject::wasmSourceMaxPages() const { if (isWasm()) { return contents().wasmBuffer()->sourceMaxPages();"
              },
              {
                "name": "ArrayBufferObjectMaybeSha",
                "type": "method",
                "start_line": 1980,
                "end_line": 1985,
                "line_count": 6,
                "signature": "size_t js::WasmArrayBufferMappedSize(const ArrayBufferObjectMaybeShared* buf) { if (buf->is<ArrayBufferObject>()) { return buf->as<ArrayBufferObject>().wasmMappedSize();"
              },
              {
                "name": " ArrayBufferObjectMaybeSha",
                "type": "method",
                "start_line": 1987,
                "end_line": 1993,
                "line_count": 7,
                "signature": "AddressType js::WasmArrayBufferAddressType( const ArrayBufferObjectMaybeShared* buf) { if (buf->is<ArrayBufferObject>()) {"
              },
              {
                "name": "axPages(\n    const A",
                "type": "method",
                "start_line": 1994,
                "end_line": 1999,
                "line_count": 6,
                "signature": "Pages js::WasmArrayBufferPages(const ArrayBufferObjectMaybeShared* buf) { if (buf->is<ArrayBufferObject>()) { return buf->as<ArrayBufferObject>().wasmPages();"
              },
              {
                "name": "tatic void CheckStealPrecondit",
                "type": "method",
                "start_line": 2000,
                "end_line": 2006,
                "line_count": 7,
                "signature": "Pages js::WasmArrayBufferClampedMaxPages( const ArrayBufferObjectMaybeShared* buf) { if (buf->is<ArrayBufferObject>()) {"
              },
              {
                "name": "from an immutable buffer\");\n ",
                "type": "method",
                "start_line": 2007,
                "end_line": 2013,
                "line_count": 7,
                "signature": "Maybe<Pages> js::WasmArrayBufferSourceMaxPages( const ArrayBufferObjectMaybeShared* buf) { if (buf->is<ArrayBufferObject>()) {"
              },
              {
                "name": "\nArrayBufferObject* Arr",
                "type": "function",
                "start_line": 2015,
                "end_line": 2025,
                "line_count": 11,
                "signature": "static void CheckStealPreconditions(Handle<ArrayBufferObject*> buffer, JSContext* cx) { cx->check(buffer);"
              },
              {
                "name": "turn js::gc",
                "type": "method",
                "start_line": 2161,
                "end_line": 2165,
                "line_count": 5,
                "signature": "void ArrayBufferObject::wasmDiscard(Handle<ArrayBufferObject*> buf, uint64_t byteOffset, uint64_t byteLen) { MOZ_ASSERT(buf->isWasm());"
              },
              {
                "name": "lass ",
                "type": "method",
                "start_line": 2167,
                "end_line": 2169,
                "line_count": 3,
                "signature": "uint32_t ArrayBufferObject::flags() const { return uint32_t(getFixedSlot(FLAGS_SLOT).toInt32()); }"
              },
              {
                "name": "to_,\n   ",
                "type": "method",
                "start_line": 2171,
                "end_line": 2173,
                "line_count": 3,
                "signature": "void ArrayBufferObject::setFlags(uint32_t flags) { setFixedSlot(FLAGS_SLOT, Int32Value(flags)); }"
              },
              {
                "name": "Kind::ARRAYBUFFER4 ||\n    ",
                "type": "function",
                "start_line": 2175,
                "end_line": 2186,
                "line_count": 12,
                "signature": "static constexpr js::gc::AllocKind GetArrayBufferGCObjectKind(size_t numSlots) { if (numSlots <= 4) { return js::gc::AllocKind::ARRAYBUFFER4;"
              },
              {
                "name": "h the object by repurposing fixe",
                "type": "method",
                "start_line": 2371,
                "end_line": 2429,
                "line_count": 59,
                "signature": "/* static */ std::tuple<ArrayBufferType*, uint8_t*> ArrayBufferObject::createUninitializedBufferAndData( JSContext* cx, size_t nbytes, AutoSetNewObjectMetadata&,"
              },
              {
                "name": " metadata, proto);\n",
                "type": "method",
                "start_line": 2432,
                "end_line": 2458,
                "line_count": 27,
                "signature": "/* static */ std::tuple<ArrayBufferType*, uint8_t*> ArrayBufferObject::createBufferAndData( JSContext* cx, size_t nbytes, AutoSetNewObjectMetadata& metadata,"
              },
              {
                "name": "e allocating the ma",
                "type": "method",
                "start_line": 2461,
                "end_line": 2493,
                "line_count": 33,
                "signature": "/* static */ std::tuple<ResizableArrayBufferObject*, uint8_t*> ResizableArrayBufferObject::createBufferAndData( JSContext* cx, size_t byteLength, size_t maxByteLength,"
              },
              {
                "name": "Contents contents = buffer->co",
                "type": "method",
                "start_line": 3026,
                "end_line": 3087,
                "line_count": 62,
                "signature": "/* static */ ArrayBufferObject::BufferContents ArrayBufferObject::extractStructuredCloneContents( JSContext* cx, Handle<ArrayBufferObject*> buffer) {"
              },
              {
                "name": " != INLINE_DATA",
                "type": "method",
                "start_line": 3090,
                "end_line": 3135,
                "line_count": 46,
                "signature": "bool ArrayBufferObject::ensureNonInline(JSContext* cx, Handle<ArrayBufferObject*> buffer) { if (buffer->isDetached() || buffer->isPreparedForAsmJS()) {"
              },
              {
                "name": "mallocSizeOf(buffer.da",
                "type": "method",
                "start_line": 3138,
                "end_line": 3182,
                "line_count": 45,
                "signature": "void ArrayBufferObject::addSizeOfExcludingThis( JSObject* obj, mozilla::MallocSizeOf mallocSizeOf, JS::ClassInfo* info, JS::RuntimeSizes* runtimeSizes) {"
              },
              {
                "name": ">byteLen",
                "type": "method",
                "start_line": 3185,
                "end_line": 3187,
                "line_count": 3,
                "signature": "void ArrayBufferObject::finalize(JS::GCContext* gcx, JSObject* obj) { obj->as<ArrayBufferObject>().releaseData(gcx); }"
              },
              {
                "name": "        ",
                "type": "method",
                "start_line": 3190,
                "end_line": 3202,
                "line_count": 13,
                "signature": "void ArrayBufferObject::copyData(ArrayBufferObject* toBuffer, size_t toIndex, ArrayBufferObject* fromBuffer, size_t fromIndex, size_t count) {"
              },
              {
                "name": "!nursery.is",
                "type": "method",
                "start_line": 3206,
                "end_line": 3226,
                "line_count": 21,
                "signature": "size_t ArrayBufferObject::objectMoved(JSObject* obj, JSObject* old) { auto& dst = obj->as<ArrayBufferType>(); const auto& src = old->as<ArrayBufferType>();"
              },
              {
                "name": "own) {\n  swi",
                "type": "method",
                "start_line": 3234,
                "end_line": 3236,
                "line_count": 3,
                "signature": "void ArrayBufferObject::setFirstView(ArrayBufferViewObject* view) { setFixedSlot(FIRST_VIEW_SLOT, ObjectOrNullValue(view)); }"
              },
              {
                "name": "rrayBuf",
                "type": "method",
                "start_line": 3238,
                "end_line": 3245,
                "line_count": 8,
                "signature": "bool ArrayBufferObject::addView(JSContext* cx, ArrayBufferViewObject* view) { if (!firstView()) { setFirstView(view);"
              },
              {
                "name": "\");\n      break;\n ",
                "type": "function",
                "start_line": 3250,
                "end_line": 3281,
                "line_count": 32,
                "signature": "void BufferKindToString(ArrayBufferObject::BufferKind kind, KnownF known, UnknownF unknown) { switch (kind) {"
              },
              {
                "name": " break;\n    }\n  }\n}\n\nv",
                "type": "function",
                "start_line": 3284,
                "end_line": 3302,
                "line_count": 19,
                "signature": "void ForEachArrayBufferFlag(uint32_t flags, KnownF known, UnknownF unknown) { for (uint32_t i = ArrayBufferObject::ArrayBufferFlags::BUFFER_KIND_MASK + 1; i; i = i << 1) {"
              },
              {
                "name": "_t value) { j",
                "type": "method",
                "start_line": 3304,
                "end_line": 3327,
                "line_count": 24,
                "signature": "void ArrayBufferObject::dumpOwnFields(js::JSONPrinter& json) const { json.formatProperty(\"byteLength\", \"%zu\", size_t(getFixedSlot(BYTE_LENGTH_SLOT).toPrivate()));"
              },
              {
                "name": "first = false;\n     ",
                "type": "method",
                "start_line": 3329,
                "end_line": 3364,
                "line_count": 36,
                "signature": "void ArrayBufferObject::dumpOwnStringContent(js::GenericPrinter& out) const { out.printf(\"byteLength=%zu, \", size_t(getFixedSlot(BYTE_LENGTH_SLOT).toPrivate()));"
              },
              {
                "name": "urseryV",
                "type": "method",
                "start_line": 3443,
                "end_line": 3480,
                "line_count": 38,
                "signature": "bool InnerViewTable::addView(JSContext* cx, ArrayBufferObject* buffer, ArrayBufferViewObject* view) { // ArrayBufferObject entries are only added when there are multiple views."
              },
              {
                "name": "ject* buffe",
                "type": "method",
                "start_line": 3491,
                "end_line": 3496,
                "line_count": 6,
                "signature": "void InnerViewTable::removeViews(ArrayBufferObject* buffer) { auto ptr = map.lookup(buffer); MOZ_ASSERT(ptr);"
              },
              {
                "name": "fterMinor",
                "type": "method",
                "start_line": 3498,
                "end_line": 3502,
                "line_count": 5,
                "signature": "bool InnerViewTable::traceWeak(JSTracer* trc) { nurseryKeys.traceWeak(trc); map.traceWeak(trc);"
              },
              {
                "name": "at every map entr",
                "type": "method",
                "start_line": 3504,
                "end_line": 3531,
                "line_count": 28,
                "signature": "void InnerViewTable::sweepAfterMinorGC(JSTracer* trc) { MOZ_ASSERT(needsSweepAfterMinorGC()); "
              },
              {
                "name": "    vectorSize += r.fr",
                "type": "method",
                "start_line": 3533,
                "end_line": 3545,
                "line_count": 13,
                "signature": "bool InnerViewTable::sweepViewsAfterMinorGC(JSTracer* trc, ArrayBufferObject* buffer, Views& views) {"
              },
              {
                "name": "ferByteLength(JSObj",
                "type": "method",
                "start_line": 3547,
                "end_line": 3555,
                "line_count": 9,
                "signature": "size_t InnerViewTable::sizeOfExcludingThis(mozilla::MallocSizeOf mallocSizeOf) { size_t vectorSize = 0; for (auto r = map.all(); !r.empty(); r.popFront()) {"
              },
              {
                "name": "tatic ArrayBufferObject*",
                "type": "method",
                "start_line": 3562,
                "end_line": 3565,
                "line_count": 4,
                "signature": "JS_PUBLIC_API size_t JS::GetArrayBufferByteLength(JSObject* obj) { ArrayBufferObject* aobj = obj->maybeUnwrapAs<ArrayBufferObject>(); return aobj ? aobj->byteLength() : 0;"
              },
              {
                "name": "ge, nullptr,\n    ",
                "type": "method",
                "start_line": 3595,
                "end_line": 3625,
                "line_count": 31,
                "signature": "JS_PUBLIC_API bool JS::DetachArrayBuffer(JSContext* cx, HandleObject obj) { AssertHeapIsIdle(); CHECK_THREAD(cx);"
              },
              {
                "name": "fferObject>();\n  if (!aobj) {\n",
                "type": "method",
                "start_line": 3627,
                "end_line": 3638,
                "line_count": 12,
                "signature": "JS_PUBLIC_API bool JS::HasDefinedArrayBufferDetachKey(JSContext* cx, HandleObject obj, bool* isDefined) {"
              },
              {
                "name": "rayBufferWithContents(\n    ",
                "type": "method",
                "start_line": 3640,
                "end_line": 3647,
                "line_count": 8,
                "signature": "JS_PUBLIC_API bool JS::IsDetachedArrayBufferObject(JSObject* obj) { ArrayBufferObject* aobj = obj->maybeUnwrapIf<ArrayBufferObject>(); if (!aobj) {"
              },
              {
                "name": "                   ",
                "type": "method",
                "start_line": 3747,
                "end_line": 3749,
                "line_count": 3,
                "signature": "JS_PUBLIC_API bool JS::IsArrayBufferObject(JSObject* obj) { return obj->canUnwrapAs<ArrayBufferObject>(); }"
              },
              {
                "name": "(obj);\n\n  Rooted<A",
                "type": "method",
                "start_line": 3751,
                "end_line": 3753,
                "line_count": 3,
                "signature": "JS_PUBLIC_API bool JS::ArrayBufferHasData(JSObject* obj) { return !obj->unwrapAs<ArrayBufferObject>().isDetached(); }"
              },
              {
                "name": "                                ",
                "type": "method",
                "start_line": 3820,
                "end_line": 3823,
                "line_count": 4,
                "signature": "JS_PUBLIC_API void JS::ReleaseMappedArrayBufferContents(void* contents, size_t length) { gc::DeallocateMappedContent(contents, length);"
              },
              {
                "name": "ta = aobj->dataPointer();",
                "type": "method",
                "start_line": 3825,
                "end_line": 3832,
                "line_count": 8,
                "signature": "JS_PUBLIC_API bool JS::IsMappedArrayBufferObject(JSObject* obj) { ArrayBufferObject* aobj = obj->maybeUnwrapIf<ArrayBufferObject>(); if (!aobj) {"
              },
              {
                "name": "ffer::ResizableUnsharedClas",
                "type": "method",
                "start_line": 3848,
                "end_line": 3856,
                "line_count": 9,
                "signature": "JS_PUBLIC_API void JS::GetArrayBufferLengthAndData(JSObject* obj, size_t* length, bool* isSharedMemory,"
              },
              {
                "name": ");\n  if (!unwrapped",
                "type": "method",
                "start_line": 3899,
                "end_line": 3949,
                "line_count": 51,
                "signature": "bool JS::ArrayBufferCopyData(JSContext* cx, Handle<JSObject*> toBlock, size_t toIndex, Handle<JSObject*> fromBlock, size_t fromIndex, size_t count) {"
              }
            ]
          },
          "hunks_count": 1,
          "hunk_ranges": [
            "@@ -546,19 @@"
          ]
        },
        {
          "commit_hash": "13b7086f65cb",
          "full_hash": "13b7086f65cbbbf1fed6e0341cfbdfb309fb962c",
          "parent_hash": "f7c96ac82c1aa9ff1f1a873b6d15ac9c3900b05d",
          "commit_type": "regressor",
          "filepath": "js/src/vm/ArrayBufferObject.cpp",
          "diff_found": true,
          "diff_path": "/Users/sidiqafekrat/Mozilla_crashAnalyzer_BugBug/method2_bugzilla_bugs/outputs/step5_extracted_diffs/bug_1988694/regressor_commits/regressor_1969509_13b7086f65cb/js_src_vm_ArrayBufferObject.cpp.diff",
          "methods_count": 95,
          "matched_methods": {
            "fully_modified": [],
            "partially_modified": [
              {
                "name": "maxByteLengthGetterImpl",
                "type": "method",
                "start_line": 543,
                "end_line": 556,
                "line_count": 14,
                "signature": "bool ArrayBufferObject::maxByteLengthGetterImpl(JSContext* cx, const CallArgs& args) { MOZ_ASSERT(IsArrayBuffer(args.thisv()));",
                "changed_lines": [
                  546,
                  547,
                  548,
                  549,
                  550,
                  551
                ],
                "overlap_count": 6,
                "overlap_percentage": 42.9
              }
            ],
            "unmodified": [
              {
                "name": "WasmReservedBytes",
                "type": "method",
                "start_line": 160,
                "end_line": 160,
                "line_count": 1,
                "signature": "uint64_t js::WasmReservedBytes() { return wasmReservedBytes; }  [[nodiscard]] static bool CheckArrayBufferTooLarge(JSContext* cx,"
              },
              {
                "name": "CheckArrayBufferTooLarge",
                "type": "function",
                "start_line": 162,
                "end_line": 172,
                "line_count": 11,
                "signature": "[[nodiscard]] static bool CheckArrayBufferTooLarge(JSContext* cx, uint64_t nbytes) { // Refuse to allocate too large buffers."
              },
              {
                "name": "CommitBufferMemory",
                "type": "method",
                "start_line": 244,
                "end_line": 269,
                "line_count": 26,
                "signature": "bool js::CommitBufferMemory(void* dataEnd, size_t delta) { MOZ_ASSERT(delta); MOZ_ASSERT(delta % gc::SystemPageSize() == 0);"
              },
              {
                "name": "UnmapBufferMemory",
                "type": "method",
                "start_line": 271,
                "end_line": 296,
                "line_count": 26,
                "signature": "void js::UnmapBufferMemory(wasm::AddressType t, void* base, size_t mappedSize, size_t committedSize) { MOZ_ASSERT(mappedSize % gc::SystemPageSize() == 0);"
              },
              {
                "name": "IsArrayBuffer",
                "type": "function",
                "start_line": 431,
                "end_line": 433,
                "line_count": 3,
                "signature": "static bool IsArrayBuffer(HandleValue v) { return v.isObject() && v.toObject().is<ArrayBufferObject>(); }"
              },
              {
                "name": "IsResizableArrayBuffer",
                "type": "function",
                "start_line": 435,
                "end_line": 437,
                "line_count": 3,
                "signature": "static bool IsResizableArrayBuffer(HandleValue v) { return v.isObject() && v.toObject().is<ResizableArrayBufferObject>(); }"
              },
              {
                "name": "byteLengthGetterImpl",
                "type": "method",
                "start_line": 439,
                "end_line": 445,
                "line_count": 7,
                "signature": "MOZ_ALWAYS_INLINE bool ArrayBufferObject::byteLengthGetterImpl( JSContext* cx, const CallArgs& args) { MOZ_ASSERT(IsArrayBuffer(args.thisv()));"
              },
              {
                "name": "byteLengthGetter",
                "type": "method",
                "start_line": 447,
                "end_line": 451,
                "line_count": 5,
                "signature": "bool ArrayBufferObject::byteLengthGetter(JSContext* cx, unsigned argc, Value* vp) { CallArgs args = CallArgsFromVp(argc, vp);"
              },
              {
                "name": "maxByteLengthGetter",
                "type": "method",
                "start_line": 563,
                "end_line": 568,
                "line_count": 6,
                "signature": "bool ArrayBufferObject::maxByteLengthGetter(JSContext* cx, unsigned argc, Value* vp) { // Steps 1-3."
              },
              {
                "name": "resizableGetterImpl",
                "type": "method",
                "start_line": 575,
                "end_line": 583,
                "line_count": 9,
                "signature": "bool ArrayBufferObject::resizableGetterImpl(JSContext* cx, const CallArgs& args) { MOZ_ASSERT(IsArrayBuffer(args.thisv()));"
              },
              {
                "name": "resizableGetter",
                "type": "method",
                "start_line": 590,
                "end_line": 595,
                "line_count": 6,
                "signature": "bool ArrayBufferObject::resizableGetter(JSContext* cx, unsigned argc, Value* vp) { // Steps 1-3."
              },
              {
                "name": "detachedGetterImpl",
                "type": "method",
                "start_line": 602,
                "end_line": 610,
                "line_count": 9,
                "signature": "bool ArrayBufferObject::detachedGetterImpl(JSContext* cx, const CallArgs& args) { MOZ_ASSERT(IsArrayBuffer(args.thisv()));"
              },
              {
                "name": "detachedGetter",
                "type": "method",
                "start_line": 617,
                "end_line": 622,
                "line_count": 6,
                "signature": "bool ArrayBufferObject::detachedGetter(JSContext* cx, unsigned argc, Value* vp) { // Steps 1-3."
              },
              {
                "name": "immutableGetterImpl",
                "type": "method",
                "start_line": 630,
                "end_line": 638,
                "line_count": 9,
                "signature": "bool ArrayBufferObject::immutableGetterImpl(JSContext* cx, const CallArgs& args) { MOZ_ASSERT(IsArrayBuffer(args.thisv()));"
              },
              {
                "name": "immutableGetter",
                "type": "method",
                "start_line": 645,
                "end_line": 650,
                "line_count": 6,
                "signature": "bool ArrayBufferObject::immutableGetter(JSContext* cx, unsigned argc, Value* vp) { // Steps 1-3."
              },
              {
                "name": "transferImpl",
                "type": "method",
                "start_line": 658,
                "end_line": 672,
                "line_count": 15,
                "signature": "bool ArrayBufferObject::transferImpl(JSContext* cx, const CallArgs& args) { MOZ_ASSERT(IsArrayBuffer(args.thisv())); "
              },
              {
                "name": "transfer",
                "type": "method",
                "start_line": 679,
                "end_line": 682,
                "line_count": 4,
                "signature": "bool ArrayBufferObject::transfer(JSContext* cx, unsigned argc, Value* vp) { CallArgs args = CallArgsFromVp(argc, vp); return CallNonGenericMethod<IsArrayBuffer, transferImpl>(cx, args);"
              },
              {
                "name": "transferToFixedLengthImpl",
                "type": "method",
                "start_line": 689,
                "end_line": 704,
                "line_count": 16,
                "signature": "bool ArrayBufferObject::transferToFixedLengthImpl(JSContext* cx, const CallArgs& args) { MOZ_ASSERT(IsArrayBuffer(args.thisv()));"
              },
              {
                "name": "transferToFixedLength",
                "type": "method",
                "start_line": 711,
                "end_line": 716,
                "line_count": 6,
                "signature": "bool ArrayBufferObject::transferToFixedLength(JSContext* cx, unsigned argc, Value* vp) { CallArgs args = CallArgsFromVp(argc, vp);"
              },
              {
                "name": "transferToImmutableImpl",
                "type": "method",
                "start_line": 724,
                "end_line": 739,
                "line_count": 16,
                "signature": "bool ArrayBufferObject::transferToImmutableImpl(JSContext* cx, const CallArgs& args) { MOZ_ASSERT(IsArrayBuffer(args.thisv()));"
              },
              {
                "name": "transferToImmutable",
                "type": "method",
                "start_line": 746,
                "end_line": 750,
                "line_count": 5,
                "signature": "bool ArrayBufferObject::transferToImmutable(JSContext* cx, unsigned argc, Value* vp) { CallArgs args = CallArgsFromVp(argc, vp);"
              },
              {
                "name": "resizeImpl",
                "type": "method",
                "start_line": 758,
                "end_line": 820,
                "line_count": 63,
                "signature": "bool ArrayBufferObject::resizeImpl(JSContext* cx, const CallArgs& args) { MOZ_ASSERT(IsResizableArrayBuffer(args.thisv())); "
              },
              {
                "name": "resize",
                "type": "method",
                "start_line": 827,
                "end_line": 831,
                "line_count": 5,
                "signature": "bool ArrayBufferObject::resize(JSContext* cx, unsigned argc, Value* vp) { // Steps 1-3. CallArgs args = CallArgsFromVp(argc, vp);"
              },
              {
                "name": "IsArrayBufferSpecies",
                "type": "function",
                "start_line": 833,
                "end_line": 836,
                "line_count": 4,
                "signature": "static bool IsArrayBufferSpecies(JSContext* cx, JSFunction* species) { return IsSelfHostedFunctionWithName(species, cx->names().dollar_ArrayBufferSpecies_);"
              },
              {
                "name": "HasBuiltinArrayBufferSpecies",
                "type": "function",
                "start_line": 838,
                "end_line": 858,
                "line_count": 21,
                "signature": "static bool HasBuiltinArrayBufferSpecies(ArrayBufferObject* obj, JSContext* cx) { // Ensure `ArrayBuffer.prototype.constructor` and `ArrayBuffer[@@species]`"
              },
              {
                "name": "sliceImpl",
                "type": "method",
                "start_line": 865,
                "end_line": 1011,
                "line_count": 147,
                "signature": "bool ArrayBufferObject::sliceImpl(JSContext* cx, const CallArgs& args) { MOZ_ASSERT(IsArrayBuffer(args.thisv())); "
              },
              {
                "name": "slice",
                "type": "method",
                "start_line": 1018,
                "end_line": 1022,
                "line_count": 5,
                "signature": "bool ArrayBufferObject::slice(JSContext* cx, unsigned argc, Value* vp) { // Steps 1-3. CallArgs args = CallArgsFromVp(argc, vp);"
              },
              {
                "name": "sliceToImmutableImpl",
                "type": "method",
                "start_line": 1030,
                "end_line": 1095,
                "line_count": 66,
                "signature": "bool ArrayBufferObject::sliceToImmutableImpl(JSContext* cx, const CallArgs& args) { MOZ_ASSERT(IsArrayBuffer(args.thisv()));"
              },
              {
                "name": "sliceToImmutable",
                "type": "method",
                "start_line": 1102,
                "end_line": 1107,
                "line_count": 6,
                "signature": "bool ArrayBufferObject::sliceToImmutable(JSContext* cx, unsigned argc, Value* vp) { // Steps 1-3."
              },
              {
                "name": "fun_isView",
                "type": "method",
                "start_line": 1113,
                "end_line": 1118,
                "line_count": 6,
                "signature": "bool ArrayBufferObject::fun_isView(JSContext* cx, unsigned argc, Value* vp) { CallArgs args = CallArgsFromVp(argc, vp); args.rval().setBoolean(args.get(0).isObject() &&"
              },
              {
                "name": "class_constructor",
                "type": "method",
                "start_line": 1122,
                "end_line": 1199,
                "line_count": 78,
                "signature": "bool ArrayBufferObject::class_constructor(JSContext* cx, unsigned argc, Value* vp) { CallArgs args = CallArgsFromVp(argc, vp);"
              },
              {
                "name": "AllocateUninitializedArrayBufferContents",
                "type": "function",
                "start_line": 1203,
                "end_line": 1221,
                "line_count": 19,
                "signature": "static ArrayBufferContents AllocateUninitializedArrayBufferContents( JSContext* cx, size_t nbytes) { // First attempt a normal allocation."
              },
              {
                "name": "AllocateArrayBufferContents",
                "type": "function",
                "start_line": 1223,
                "end_line": 1239,
                "line_count": 17,
                "signature": "static ArrayBufferContents AllocateArrayBufferContents(JSContext* cx, size_t nbytes) { // First attempt a normal allocation."
              },
              {
                "name": "ReallocateArrayBufferContents",
                "type": "function",
                "start_line": 1241,
                "end_line": 1260,
                "line_count": 20,
                "signature": "static ArrayBufferContents ReallocateArrayBufferContents(JSContext* cx, uint8_t* old, size_t oldSize,"
              },
              {
                "name": "NewCopiedBufferContents",
                "type": "function",
                "start_line": 1262,
                "end_line": 1272,
                "line_count": 11,
                "signature": "static ArrayBufferContents NewCopiedBufferContents( JSContext* cx, Handle<ArrayBufferObject*> buffer) { ArrayBufferContents dataCopy ="
              },
              {
                "name": "detach",
                "type": "method",
                "start_line": 1275,
                "end_line": 1310,
                "line_count": 36,
                "signature": "void ArrayBufferObject::detach(JSContext* cx, Handle<ArrayBufferObject*> buffer) { cx->check(buffer);"
              },
              {
                "name": "resize",
                "type": "method",
                "start_line": 1312,
                "end_line": 1347,
                "line_count": 36,
                "signature": "void ResizableArrayBufferObject::resize(size_t newByteLength) { MOZ_ASSERT(!isPreparedForAsmJS()); MOZ_ASSERT(!isWasm());"
              },
              {
                "name": " true;\n}\n\nvoid Was",
                "type": "method",
                "start_line": 1520,
                "end_line": 1541,
                "line_count": 22,
                "signature": "[[nodiscard]] bool WasmArrayRawBuffer::growToPagesInPlace(Pages newPages) { size_t newSize = newPages.byteLength(); size_t oldSize = byteLength();"
              },
              {
                "name": " void* ",
                "type": "method",
                "start_line": 1543,
                "end_line": 1586,
                "line_count": 44,
                "signature": "void WasmArrayRawBuffer::discard(size_t byteOffset, size_t byteLen) { uint8_t* memBase = dataPointer(); "
              },
              {
                "name": "sePoint",
                "type": "method",
                "start_line": 1631,
                "end_line": 1644,
                "line_count": 14,
                "signature": "void WasmArrayRawBuffer::Release(void* mem) { WasmArrayRawBuffer* header = (WasmArrayRawBuffer*)((uint8_t*)mem - sizeof(WasmArrayRawBuffer));"
              },
              {
                "name": " MALLOCED_UNKNO",
                "type": "method",
                "start_line": 1775,
                "end_line": 1821,
                "line_count": 47,
                "signature": "bool ArrayBufferObject::prepareForAsmJS() { MOZ_ASSERT(byteLength() % wasm::PageSize == 0, \"prior size checking should have guaranteed page-size multiple\");"
              },
              {
                "name": "ect::inlineDataPoint",
                "type": "method",
                "start_line": 1823,
                "end_line": 1828,
                "line_count": 6,
                "signature": "ArrayBufferObject::BufferContents ArrayBufferObject::createMappedContents( int fd, size_t offset, size_t length) { void* data ="
              },
              {
                "name": "asing.\n      brea",
                "type": "method",
                "start_line": 1846,
                "end_line": 1848,
                "line_count": 3,
                "signature": "SharedMem<uint8_t*> ArrayBufferObject::dataPointerShared() const { return SharedMem<uint8_t*>::unshared(getFixedSlot(DATA_SLOT).toPrivate()); }"
              },
              {
                "name": "ed by, well",
                "type": "method",
                "start_line": 1858,
                "end_line": 1896,
                "line_count": 39,
                "signature": "void ArrayBufferObject::releaseData(JS::GCContext* gcx) { switch (bufferKind()) { case INLINE_DATA:"
              },
              {
                "name": "  if (isMapped",
                "type": "method",
                "start_line": 1898,
                "end_line": 1907,
                "line_count": 10,
                "signature": "void ArrayBufferObject::setDataPointer(BufferContents contents) { setFixedSlot(DATA_SLOT, PrivateValue(contents.data())); setFlags((flags() & ~KIND_MASK) | contents.kind());"
              },
              {
                "name": "MappedSize",
                "type": "method",
                "start_line": 1909,
                "end_line": 1911,
                "line_count": 3,
                "signature": "size_t ArrayBufferObject::byteLength() const { return size_t(getFixedSlot(BYTE_LENGTH_SLOT).toPrivate()); }"
              },
              {
                "name": "\nAddressType Ar",
                "type": "method",
                "start_line": 1913,
                "end_line": 1921,
                "line_count": 9,
                "signature": "inline size_t ArrayBufferObject::associatedBytes() const { if (isMalloced()) { return maxByteLength();"
              },
              {
                "name": "smPages() con",
                "type": "method",
                "start_line": 1923,
                "end_line": 1926,
                "line_count": 4,
                "signature": "void ArrayBufferObject::setByteLength(size_t length) { MOZ_ASSERT(length <= ArrayBufferObject::ByteLengthLimit); setFixedSlot(BYTE_LENGTH_SLOT, PrivateValue(length));"
              },
              {
                "name": "ages ArrayBuff",
                "type": "method",
                "start_line": 1928,
                "end_line": 1933,
                "line_count": 6,
                "signature": "size_t ArrayBufferObject::wasmMappedSize() const { if (isWasm()) { return contents().wasmBuffer()->mappedSize();"
              },
              {
                "name": "ForAsmJS());\n  ",
                "type": "method",
                "start_line": 1935,
                "end_line": 1941,
                "line_count": 7,
                "signature": "AddressType ArrayBufferObject::wasmAddressType() const { if (isWasm()) { return contents().wasmBuffer()->addressType();"
              },
              {
                "name": "();\n  }\n ",
                "type": "method",
                "start_line": 1943,
                "end_line": 1949,
                "line_count": 7,
                "signature": "Pages ArrayBufferObject::wasmPages() const { if (isWasm()) { return contents().wasmBuffer()->pages();"
              },
              {
                "name": "is<ArrayBufferObjec",
                "type": "method",
                "start_line": 1951,
                "end_line": 1957,
                "line_count": 7,
                "signature": "Pages ArrayBufferObject::wasmClampedMaxPages() const { if (isWasm()) { return contents().wasmBuffer()->clampedMaxPages();"
              },
              {
                "name": "eShared* buf) {\n  ",
                "type": "method",
                "start_line": 1959,
                "end_line": 1965,
                "line_count": 7,
                "signature": "Maybe<Pages> ArrayBufferObject::wasmSourceMaxPages() const { if (isWasm()) { return contents().wasmBuffer()->sourceMaxPages();"
              },
              {
                "name": "ArrayBufferObjectMaybeSha",
                "type": "method",
                "start_line": 1967,
                "end_line": 1972,
                "line_count": 6,
                "signature": "size_t js::WasmArrayBufferMappedSize(const ArrayBufferObjectMaybeShared* buf) { if (buf->is<ArrayBufferObject>()) { return buf->as<ArrayBufferObject>().wasmMappedSize();"
              },
              {
                "name": " ArrayBufferObjectMaybeSha",
                "type": "method",
                "start_line": 1974,
                "end_line": 1980,
                "line_count": 7,
                "signature": "AddressType js::WasmArrayBufferAddressType( const ArrayBufferObjectMaybeShared* buf) { if (buf->is<ArrayBufferObject>()) {"
              },
              {
                "name": "axPages(\n    const A",
                "type": "method",
                "start_line": 1981,
                "end_line": 1986,
                "line_count": 6,
                "signature": "Pages js::WasmArrayBufferPages(const ArrayBufferObjectMaybeShared* buf) { if (buf->is<ArrayBufferObject>()) { return buf->as<ArrayBufferObject>().wasmPages();"
              },
              {
                "name": "tatic void CheckStealPrecondit",
                "type": "method",
                "start_line": 1987,
                "end_line": 1993,
                "line_count": 7,
                "signature": "Pages js::WasmArrayBufferClampedMaxPages( const ArrayBufferObjectMaybeShared* buf) { if (buf->is<ArrayBufferObject>()) {"
              },
              {
                "name": "from an immutable buffer\");\n ",
                "type": "method",
                "start_line": 1994,
                "end_line": 2000,
                "line_count": 7,
                "signature": "Maybe<Pages> js::WasmArrayBufferSourceMaxPages( const ArrayBufferObjectMaybeShared* buf) { if (buf->is<ArrayBufferObject>()) {"
              },
              {
                "name": "\nArrayBufferObject* Arr",
                "type": "function",
                "start_line": 2002,
                "end_line": 2012,
                "line_count": 11,
                "signature": "static void CheckStealPreconditions(Handle<ArrayBufferObject*> buffer, JSContext* cx) { cx->check(buffer);"
              },
              {
                "name": "turn js::gc",
                "type": "method",
                "start_line": 2148,
                "end_line": 2152,
                "line_count": 5,
                "signature": "void ArrayBufferObject::wasmDiscard(Handle<ArrayBufferObject*> buf, uint64_t byteOffset, uint64_t byteLen) { MOZ_ASSERT(buf->isWasm());"
              },
              {
                "name": "lass ",
                "type": "method",
                "start_line": 2154,
                "end_line": 2156,
                "line_count": 3,
                "signature": "uint32_t ArrayBufferObject::flags() const { return uint32_t(getFixedSlot(FLAGS_SLOT).toInt32()); }"
              },
              {
                "name": "to_,\n   ",
                "type": "method",
                "start_line": 2158,
                "end_line": 2160,
                "line_count": 3,
                "signature": "void ArrayBufferObject::setFlags(uint32_t flags) { setFixedSlot(FLAGS_SLOT, Int32Value(flags)); }"
              },
              {
                "name": "Kind::ARRAYBUFFER4 ||\n    ",
                "type": "function",
                "start_line": 2162,
                "end_line": 2173,
                "line_count": 12,
                "signature": "static constexpr js::gc::AllocKind GetArrayBufferGCObjectKind(size_t numSlots) { if (numSlots <= 4) { return js::gc::AllocKind::ARRAYBUFFER4;"
              },
              {
                "name": "h the object by repurposing fixe",
                "type": "method",
                "start_line": 2358,
                "end_line": 2416,
                "line_count": 59,
                "signature": "/* static */ std::tuple<ArrayBufferType*, uint8_t*> ArrayBufferObject::createUninitializedBufferAndData( JSContext* cx, size_t nbytes, AutoSetNewObjectMetadata&,"
              },
              {
                "name": " metadata, proto);\n",
                "type": "method",
                "start_line": 2419,
                "end_line": 2445,
                "line_count": 27,
                "signature": "/* static */ std::tuple<ArrayBufferType*, uint8_t*> ArrayBufferObject::createBufferAndData( JSContext* cx, size_t nbytes, AutoSetNewObjectMetadata& metadata,"
              },
              {
                "name": "e allocating the ma",
                "type": "method",
                "start_line": 2448,
                "end_line": 2480,
                "line_count": 33,
                "signature": "/* static */ std::tuple<ResizableArrayBufferObject*, uint8_t*> ResizableArrayBufferObject::createBufferAndData( JSContext* cx, size_t byteLength, size_t maxByteLength,"
              },
              {
                "name": "Contents contents = buffer->co",
                "type": "method",
                "start_line": 3013,
                "end_line": 3074,
                "line_count": 62,
                "signature": "/* static */ ArrayBufferObject::BufferContents ArrayBufferObject::extractStructuredCloneContents( JSContext* cx, Handle<ArrayBufferObject*> buffer) {"
              },
              {
                "name": " != INLINE_DATA",
                "type": "method",
                "start_line": 3077,
                "end_line": 3122,
                "line_count": 46,
                "signature": "bool ArrayBufferObject::ensureNonInline(JSContext* cx, Handle<ArrayBufferObject*> buffer) { if (buffer->isDetached() || buffer->isPreparedForAsmJS()) {"
              },
              {
                "name": "mallocSizeOf(buffer.da",
                "type": "method",
                "start_line": 3125,
                "end_line": 3169,
                "line_count": 45,
                "signature": "void ArrayBufferObject::addSizeOfExcludingThis( JSObject* obj, mozilla::MallocSizeOf mallocSizeOf, JS::ClassInfo* info, JS::RuntimeSizes* runtimeSizes) {"
              },
              {
                "name": ">byteLen",
                "type": "method",
                "start_line": 3172,
                "end_line": 3174,
                "line_count": 3,
                "signature": "void ArrayBufferObject::finalize(JS::GCContext* gcx, JSObject* obj) { obj->as<ArrayBufferObject>().releaseData(gcx); }"
              },
              {
                "name": "        ",
                "type": "method",
                "start_line": 3177,
                "end_line": 3189,
                "line_count": 13,
                "signature": "void ArrayBufferObject::copyData(ArrayBufferObject* toBuffer, size_t toIndex, ArrayBufferObject* fromBuffer, size_t fromIndex, size_t count) {"
              },
              {
                "name": "!nursery.is",
                "type": "method",
                "start_line": 3193,
                "end_line": 3213,
                "line_count": 21,
                "signature": "size_t ArrayBufferObject::objectMoved(JSObject* obj, JSObject* old) { auto& dst = obj->as<ArrayBufferType>(); const auto& src = old->as<ArrayBufferType>();"
              },
              {
                "name": "own) {\n  swi",
                "type": "method",
                "start_line": 3221,
                "end_line": 3223,
                "line_count": 3,
                "signature": "void ArrayBufferObject::setFirstView(ArrayBufferViewObject* view) { setFixedSlot(FIRST_VIEW_SLOT, ObjectOrNullValue(view)); }"
              },
              {
                "name": "rrayBuf",
                "type": "method",
                "start_line": 3225,
                "end_line": 3232,
                "line_count": 8,
                "signature": "bool ArrayBufferObject::addView(JSContext* cx, ArrayBufferViewObject* view) { if (!firstView()) { setFirstView(view);"
              },
              {
                "name": "\");\n      break;\n ",
                "type": "function",
                "start_line": 3237,
                "end_line": 3268,
                "line_count": 32,
                "signature": "void BufferKindToString(ArrayBufferObject::BufferKind kind, KnownF known, UnknownF unknown) { switch (kind) {"
              },
              {
                "name": " break;\n    }\n  }\n}\n\nv",
                "type": "function",
                "start_line": 3271,
                "end_line": 3289,
                "line_count": 19,
                "signature": "void ForEachArrayBufferFlag(uint32_t flags, KnownF known, UnknownF unknown) { for (uint32_t i = ArrayBufferObject::ArrayBufferFlags::BUFFER_KIND_MASK + 1; i; i = i << 1) {"
              },
              {
                "name": "_t value) { j",
                "type": "method",
                "start_line": 3291,
                "end_line": 3314,
                "line_count": 24,
                "signature": "void ArrayBufferObject::dumpOwnFields(js::JSONPrinter& json) const { json.formatProperty(\"byteLength\", \"%zu\", size_t(getFixedSlot(BYTE_LENGTH_SLOT).toPrivate()));"
              },
              {
                "name": "first = false;\n     ",
                "type": "method",
                "start_line": 3316,
                "end_line": 3351,
                "line_count": 36,
                "signature": "void ArrayBufferObject::dumpOwnStringContent(js::GenericPrinter& out) const { out.printf(\"byteLength=%zu, \", size_t(getFixedSlot(BYTE_LENGTH_SLOT).toPrivate()));"
              },
              {
                "name": "urseryV",
                "type": "method",
                "start_line": 3430,
                "end_line": 3467,
                "line_count": 38,
                "signature": "bool InnerViewTable::addView(JSContext* cx, ArrayBufferObject* buffer, ArrayBufferViewObject* view) { // ArrayBufferObject entries are only added when there are multiple views."
              },
              {
                "name": "ject* buffe",
                "type": "method",
                "start_line": 3478,
                "end_line": 3483,
                "line_count": 6,
                "signature": "void InnerViewTable::removeViews(ArrayBufferObject* buffer) { auto ptr = map.lookup(buffer); MOZ_ASSERT(ptr);"
              },
              {
                "name": "fterMinor",
                "type": "method",
                "start_line": 3485,
                "end_line": 3489,
                "line_count": 5,
                "signature": "bool InnerViewTable::traceWeak(JSTracer* trc) { nurseryKeys.traceWeak(trc); map.traceWeak(trc);"
              },
              {
                "name": "at every map entr",
                "type": "method",
                "start_line": 3491,
                "end_line": 3518,
                "line_count": 28,
                "signature": "void InnerViewTable::sweepAfterMinorGC(JSTracer* trc) { MOZ_ASSERT(needsSweepAfterMinorGC()); "
              },
              {
                "name": "    vectorSize += r.fr",
                "type": "method",
                "start_line": 3520,
                "end_line": 3532,
                "line_count": 13,
                "signature": "bool InnerViewTable::sweepViewsAfterMinorGC(JSTracer* trc, ArrayBufferObject* buffer, Views& views) {"
              },
              {
                "name": "ferByteLength(JSObj",
                "type": "method",
                "start_line": 3534,
                "end_line": 3542,
                "line_count": 9,
                "signature": "size_t InnerViewTable::sizeOfExcludingThis(mozilla::MallocSizeOf mallocSizeOf) { size_t vectorSize = 0; for (auto r = map.all(); !r.empty(); r.popFront()) {"
              },
              {
                "name": "tatic ArrayBufferObject*",
                "type": "method",
                "start_line": 3549,
                "end_line": 3552,
                "line_count": 4,
                "signature": "JS_PUBLIC_API size_t JS::GetArrayBufferByteLength(JSObject* obj) { ArrayBufferObject* aobj = obj->maybeUnwrapAs<ArrayBufferObject>(); return aobj ? aobj->byteLength() : 0;"
              },
              {
                "name": "ge, nullptr,\n    ",
                "type": "method",
                "start_line": 3582,
                "end_line": 3612,
                "line_count": 31,
                "signature": "JS_PUBLIC_API bool JS::DetachArrayBuffer(JSContext* cx, HandleObject obj) { AssertHeapIsIdle(); CHECK_THREAD(cx);"
              },
              {
                "name": "fferObject>();\n  if (!aobj) {\n",
                "type": "method",
                "start_line": 3614,
                "end_line": 3625,
                "line_count": 12,
                "signature": "JS_PUBLIC_API bool JS::HasDefinedArrayBufferDetachKey(JSContext* cx, HandleObject obj, bool* isDefined) {"
              },
              {
                "name": "rayBufferWithContents(\n    ",
                "type": "method",
                "start_line": 3627,
                "end_line": 3634,
                "line_count": 8,
                "signature": "JS_PUBLIC_API bool JS::IsDetachedArrayBufferObject(JSObject* obj) { ArrayBufferObject* aobj = obj->maybeUnwrapIf<ArrayBufferObject>(); if (!aobj) {"
              },
              {
                "name": "                   ",
                "type": "method",
                "start_line": 3734,
                "end_line": 3736,
                "line_count": 3,
                "signature": "JS_PUBLIC_API bool JS::IsArrayBufferObject(JSObject* obj) { return obj->canUnwrapAs<ArrayBufferObject>(); }"
              },
              {
                "name": "(obj);\n\n  Rooted<A",
                "type": "method",
                "start_line": 3738,
                "end_line": 3740,
                "line_count": 3,
                "signature": "JS_PUBLIC_API bool JS::ArrayBufferHasData(JSObject* obj) { return !obj->unwrapAs<ArrayBufferObject>().isDetached(); }"
              },
              {
                "name": "                                ",
                "type": "method",
                "start_line": 3807,
                "end_line": 3810,
                "line_count": 4,
                "signature": "JS_PUBLIC_API void JS::ReleaseMappedArrayBufferContents(void* contents, size_t length) { gc::DeallocateMappedContent(contents, length);"
              },
              {
                "name": "ta = aobj->dataPointer();",
                "type": "method",
                "start_line": 3812,
                "end_line": 3819,
                "line_count": 8,
                "signature": "JS_PUBLIC_API bool JS::IsMappedArrayBufferObject(JSObject* obj) { ArrayBufferObject* aobj = obj->maybeUnwrapIf<ArrayBufferObject>(); if (!aobj) {"
              },
              {
                "name": "ffer::ResizableUnsharedClas",
                "type": "method",
                "start_line": 3835,
                "end_line": 3843,
                "line_count": 9,
                "signature": "JS_PUBLIC_API void JS::GetArrayBufferLengthAndData(JSObject* obj, size_t* length, bool* isSharedMemory,"
              },
              {
                "name": ");\n  if (!unwrapped",
                "type": "method",
                "start_line": 3886,
                "end_line": 3936,
                "line_count": 51,
                "signature": "bool JS::ArrayBufferCopyData(JSContext* cx, Handle<JSObject*> toBlock, size_t toIndex, Handle<JSObject*> fromBlock, size_t fromIndex, size_t count) {"
              }
            ]
          },
          "hunks_count": 1,
          "hunk_ranges": [
            "@@ -546,6 @@"
          ]
        },
        {
          "commit_hash": "85d47a33200c",
          "full_hash": "85d47a33200c36a5f91f011f5713c34da79329ee",
          "parent_hash": "5860a981c750659eba0199e9ee5e45edcaa58a5a",
          "commit_type": "regressor",
          "filepath": "js/src/vm/ArrayBufferObject.cpp",
          "diff_found": true,
          "diff_path": "/Users/sidiqafekrat/Mozilla_crashAnalyzer_BugBug/method2_bugzilla_bugs/outputs/step5_extracted_diffs/bug_1988694/regressor_commits/regressor_1969509_85d47a33200c/js_src_vm_ArrayBufferObject.cpp.diff",
          "methods_count": 95,
          "matched_methods": {
            "fully_modified": [],
            "partially_modified": [
              {
                "name": "maxByteLengthGetterImpl",
                "type": "method",
                "start_line": 543,
                "end_line": 556,
                "line_count": 14,
                "signature": "bool ArrayBufferObject::maxByteLengthGetterImpl(JSContext* cx, const CallArgs& args) { MOZ_ASSERT(IsArrayBuffer(args.thisv()));",
                "changed_lines": [
                  546,
                  547,
                  548,
                  549,
                  550,
                  551
                ],
                "overlap_count": 6,
                "overlap_percentage": 42.9
              }
            ],
            "unmodified": [
              {
                "name": "WasmReservedBytes",
                "type": "method",
                "start_line": 160,
                "end_line": 160,
                "line_count": 1,
                "signature": "uint64_t js::WasmReservedBytes() { return wasmReservedBytes; }  [[nodiscard]] static bool CheckArrayBufferTooLarge(JSContext* cx,"
              },
              {
                "name": "CheckArrayBufferTooLarge",
                "type": "function",
                "start_line": 162,
                "end_line": 172,
                "line_count": 11,
                "signature": "[[nodiscard]] static bool CheckArrayBufferTooLarge(JSContext* cx, uint64_t nbytes) { // Refuse to allocate too large buffers."
              },
              {
                "name": "CommitBufferMemory",
                "type": "method",
                "start_line": 244,
                "end_line": 269,
                "line_count": 26,
                "signature": "bool js::CommitBufferMemory(void* dataEnd, size_t delta) { MOZ_ASSERT(delta); MOZ_ASSERT(delta % gc::SystemPageSize() == 0);"
              },
              {
                "name": "UnmapBufferMemory",
                "type": "method",
                "start_line": 271,
                "end_line": 296,
                "line_count": 26,
                "signature": "void js::UnmapBufferMemory(wasm::AddressType t, void* base, size_t mappedSize, size_t committedSize) { MOZ_ASSERT(mappedSize % gc::SystemPageSize() == 0);"
              },
              {
                "name": "IsArrayBuffer",
                "type": "function",
                "start_line": 431,
                "end_line": 433,
                "line_count": 3,
                "signature": "static bool IsArrayBuffer(HandleValue v) { return v.isObject() && v.toObject().is<ArrayBufferObject>(); }"
              },
              {
                "name": "IsResizableArrayBuffer",
                "type": "function",
                "start_line": 435,
                "end_line": 437,
                "line_count": 3,
                "signature": "static bool IsResizableArrayBuffer(HandleValue v) { return v.isObject() && v.toObject().is<ResizableArrayBufferObject>(); }"
              },
              {
                "name": "byteLengthGetterImpl",
                "type": "method",
                "start_line": 439,
                "end_line": 445,
                "line_count": 7,
                "signature": "MOZ_ALWAYS_INLINE bool ArrayBufferObject::byteLengthGetterImpl( JSContext* cx, const CallArgs& args) { MOZ_ASSERT(IsArrayBuffer(args.thisv()));"
              },
              {
                "name": "byteLengthGetter",
                "type": "method",
                "start_line": 447,
                "end_line": 451,
                "line_count": 5,
                "signature": "bool ArrayBufferObject::byteLengthGetter(JSContext* cx, unsigned argc, Value* vp) { CallArgs args = CallArgsFromVp(argc, vp);"
              },
              {
                "name": "maxByteLengthGetter",
                "type": "method",
                "start_line": 563,
                "end_line": 568,
                "line_count": 6,
                "signature": "bool ArrayBufferObject::maxByteLengthGetter(JSContext* cx, unsigned argc, Value* vp) { // Steps 1-3."
              },
              {
                "name": "resizableGetterImpl",
                "type": "method",
                "start_line": 575,
                "end_line": 583,
                "line_count": 9,
                "signature": "bool ArrayBufferObject::resizableGetterImpl(JSContext* cx, const CallArgs& args) { MOZ_ASSERT(IsArrayBuffer(args.thisv()));"
              },
              {
                "name": "resizableGetter",
                "type": "method",
                "start_line": 590,
                "end_line": 595,
                "line_count": 6,
                "signature": "bool ArrayBufferObject::resizableGetter(JSContext* cx, unsigned argc, Value* vp) { // Steps 1-3."
              },
              {
                "name": "detachedGetterImpl",
                "type": "method",
                "start_line": 602,
                "end_line": 610,
                "line_count": 9,
                "signature": "bool ArrayBufferObject::detachedGetterImpl(JSContext* cx, const CallArgs& args) { MOZ_ASSERT(IsArrayBuffer(args.thisv()));"
              },
              {
                "name": "detachedGetter",
                "type": "method",
                "start_line": 617,
                "end_line": 622,
                "line_count": 6,
                "signature": "bool ArrayBufferObject::detachedGetter(JSContext* cx, unsigned argc, Value* vp) { // Steps 1-3."
              },
              {
                "name": "immutableGetterImpl",
                "type": "method",
                "start_line": 630,
                "end_line": 638,
                "line_count": 9,
                "signature": "bool ArrayBufferObject::immutableGetterImpl(JSContext* cx, const CallArgs& args) { MOZ_ASSERT(IsArrayBuffer(args.thisv()));"
              },
              {
                "name": "immutableGetter",
                "type": "method",
                "start_line": 645,
                "end_line": 650,
                "line_count": 6,
                "signature": "bool ArrayBufferObject::immutableGetter(JSContext* cx, unsigned argc, Value* vp) { // Steps 1-3."
              },
              {
                "name": "transferImpl",
                "type": "method",
                "start_line": 658,
                "end_line": 672,
                "line_count": 15,
                "signature": "bool ArrayBufferObject::transferImpl(JSContext* cx, const CallArgs& args) { MOZ_ASSERT(IsArrayBuffer(args.thisv())); "
              },
              {
                "name": "transfer",
                "type": "method",
                "start_line": 679,
                "end_line": 682,
                "line_count": 4,
                "signature": "bool ArrayBufferObject::transfer(JSContext* cx, unsigned argc, Value* vp) { CallArgs args = CallArgsFromVp(argc, vp); return CallNonGenericMethod<IsArrayBuffer, transferImpl>(cx, args);"
              },
              {
                "name": "transferToFixedLengthImpl",
                "type": "method",
                "start_line": 689,
                "end_line": 704,
                "line_count": 16,
                "signature": "bool ArrayBufferObject::transferToFixedLengthImpl(JSContext* cx, const CallArgs& args) { MOZ_ASSERT(IsArrayBuffer(args.thisv()));"
              },
              {
                "name": "transferToFixedLength",
                "type": "method",
                "start_line": 711,
                "end_line": 716,
                "line_count": 6,
                "signature": "bool ArrayBufferObject::transferToFixedLength(JSContext* cx, unsigned argc, Value* vp) { CallArgs args = CallArgsFromVp(argc, vp);"
              },
              {
                "name": "transferToImmutableImpl",
                "type": "method",
                "start_line": 724,
                "end_line": 739,
                "line_count": 16,
                "signature": "bool ArrayBufferObject::transferToImmutableImpl(JSContext* cx, const CallArgs& args) { MOZ_ASSERT(IsArrayBuffer(args.thisv()));"
              },
              {
                "name": "transferToImmutable",
                "type": "method",
                "start_line": 746,
                "end_line": 750,
                "line_count": 5,
                "signature": "bool ArrayBufferObject::transferToImmutable(JSContext* cx, unsigned argc, Value* vp) { CallArgs args = CallArgsFromVp(argc, vp);"
              },
              {
                "name": "resizeImpl",
                "type": "method",
                "start_line": 758,
                "end_line": 820,
                "line_count": 63,
                "signature": "bool ArrayBufferObject::resizeImpl(JSContext* cx, const CallArgs& args) { MOZ_ASSERT(IsResizableArrayBuffer(args.thisv())); "
              },
              {
                "name": "resize",
                "type": "method",
                "start_line": 827,
                "end_line": 831,
                "line_count": 5,
                "signature": "bool ArrayBufferObject::resize(JSContext* cx, unsigned argc, Value* vp) { // Steps 1-3. CallArgs args = CallArgsFromVp(argc, vp);"
              },
              {
                "name": "IsArrayBufferSpecies",
                "type": "function",
                "start_line": 833,
                "end_line": 836,
                "line_count": 4,
                "signature": "static bool IsArrayBufferSpecies(JSContext* cx, JSFunction* species) { return IsSelfHostedFunctionWithName(species, cx->names().dollar_ArrayBufferSpecies_);"
              },
              {
                "name": "HasBuiltinArrayBufferSpecies",
                "type": "function",
                "start_line": 838,
                "end_line": 858,
                "line_count": 21,
                "signature": "static bool HasBuiltinArrayBufferSpecies(ArrayBufferObject* obj, JSContext* cx) { // Ensure `ArrayBuffer.prototype.constructor` and `ArrayBuffer[@@species]`"
              },
              {
                "name": "sliceImpl",
                "type": "method",
                "start_line": 865,
                "end_line": 1011,
                "line_count": 147,
                "signature": "bool ArrayBufferObject::sliceImpl(JSContext* cx, const CallArgs& args) { MOZ_ASSERT(IsArrayBuffer(args.thisv())); "
              },
              {
                "name": "slice",
                "type": "method",
                "start_line": 1018,
                "end_line": 1022,
                "line_count": 5,
                "signature": "bool ArrayBufferObject::slice(JSContext* cx, unsigned argc, Value* vp) { // Steps 1-3. CallArgs args = CallArgsFromVp(argc, vp);"
              },
              {
                "name": "sliceToImmutableImpl",
                "type": "method",
                "start_line": 1030,
                "end_line": 1095,
                "line_count": 66,
                "signature": "bool ArrayBufferObject::sliceToImmutableImpl(JSContext* cx, const CallArgs& args) { MOZ_ASSERT(IsArrayBuffer(args.thisv()));"
              },
              {
                "name": "sliceToImmutable",
                "type": "method",
                "start_line": 1102,
                "end_line": 1107,
                "line_count": 6,
                "signature": "bool ArrayBufferObject::sliceToImmutable(JSContext* cx, unsigned argc, Value* vp) { // Steps 1-3."
              },
              {
                "name": "fun_isView",
                "type": "method",
                "start_line": 1113,
                "end_line": 1118,
                "line_count": 6,
                "signature": "bool ArrayBufferObject::fun_isView(JSContext* cx, unsigned argc, Value* vp) { CallArgs args = CallArgsFromVp(argc, vp); args.rval().setBoolean(args.get(0).isObject() &&"
              },
              {
                "name": "class_constructor",
                "type": "method",
                "start_line": 1122,
                "end_line": 1199,
                "line_count": 78,
                "signature": "bool ArrayBufferObject::class_constructor(JSContext* cx, unsigned argc, Value* vp) { CallArgs args = CallArgsFromVp(argc, vp);"
              },
              {
                "name": "AllocateUninitializedArrayBufferContents",
                "type": "function",
                "start_line": 1203,
                "end_line": 1221,
                "line_count": 19,
                "signature": "static ArrayBufferContents AllocateUninitializedArrayBufferContents( JSContext* cx, size_t nbytes) { // First attempt a normal allocation."
              },
              {
                "name": "AllocateArrayBufferContents",
                "type": "function",
                "start_line": 1223,
                "end_line": 1239,
                "line_count": 17,
                "signature": "static ArrayBufferContents AllocateArrayBufferContents(JSContext* cx, size_t nbytes) { // First attempt a normal allocation."
              },
              {
                "name": "ReallocateArrayBufferContents",
                "type": "function",
                "start_line": 1241,
                "end_line": 1260,
                "line_count": 20,
                "signature": "static ArrayBufferContents ReallocateArrayBufferContents(JSContext* cx, uint8_t* old, size_t oldSize,"
              },
              {
                "name": "NewCopiedBufferContents",
                "type": "function",
                "start_line": 1262,
                "end_line": 1272,
                "line_count": 11,
                "signature": "static ArrayBufferContents NewCopiedBufferContents( JSContext* cx, Handle<ArrayBufferObject*> buffer) { ArrayBufferContents dataCopy ="
              },
              {
                "name": "detach",
                "type": "method",
                "start_line": 1275,
                "end_line": 1310,
                "line_count": 36,
                "signature": "void ArrayBufferObject::detach(JSContext* cx, Handle<ArrayBufferObject*> buffer) { cx->check(buffer);"
              },
              {
                "name": "resize",
                "type": "method",
                "start_line": 1312,
                "end_line": 1347,
                "line_count": 36,
                "signature": "void ResizableArrayBufferObject::resize(size_t newByteLength) { MOZ_ASSERT(!isPreparedForAsmJS()); MOZ_ASSERT(!isWasm());"
              },
              {
                "name": " true;\n}\n\nvoid Was",
                "type": "method",
                "start_line": 1520,
                "end_line": 1541,
                "line_count": 22,
                "signature": "[[nodiscard]] bool WasmArrayRawBuffer::growToPagesInPlace(Pages newPages) { size_t newSize = newPages.byteLength(); size_t oldSize = byteLength();"
              },
              {
                "name": " void* ",
                "type": "method",
                "start_line": 1543,
                "end_line": 1586,
                "line_count": 44,
                "signature": "void WasmArrayRawBuffer::discard(size_t byteOffset, size_t byteLen) { uint8_t* memBase = dataPointer(); "
              },
              {
                "name": "sePoint",
                "type": "method",
                "start_line": 1631,
                "end_line": 1644,
                "line_count": 14,
                "signature": "void WasmArrayRawBuffer::Release(void* mem) { WasmArrayRawBuffer* header = (WasmArrayRawBuffer*)((uint8_t*)mem - sizeof(WasmArrayRawBuffer));"
              },
              {
                "name": " MALLOCED_UNKNO",
                "type": "method",
                "start_line": 1775,
                "end_line": 1821,
                "line_count": 47,
                "signature": "bool ArrayBufferObject::prepareForAsmJS() { MOZ_ASSERT(byteLength() % wasm::PageSize == 0, \"prior size checking should have guaranteed page-size multiple\");"
              },
              {
                "name": "ect::inlineDataPoint",
                "type": "method",
                "start_line": 1823,
                "end_line": 1828,
                "line_count": 6,
                "signature": "ArrayBufferObject::BufferContents ArrayBufferObject::createMappedContents( int fd, size_t offset, size_t length) { void* data ="
              },
              {
                "name": "asing.\n      brea",
                "type": "method",
                "start_line": 1846,
                "end_line": 1848,
                "line_count": 3,
                "signature": "SharedMem<uint8_t*> ArrayBufferObject::dataPointerShared() const { return SharedMem<uint8_t*>::unshared(getFixedSlot(DATA_SLOT).toPrivate()); }"
              },
              {
                "name": "ed by, well",
                "type": "method",
                "start_line": 1858,
                "end_line": 1896,
                "line_count": 39,
                "signature": "void ArrayBufferObject::releaseData(JS::GCContext* gcx) { switch (bufferKind()) { case INLINE_DATA:"
              },
              {
                "name": "  if (isMapped",
                "type": "method",
                "start_line": 1898,
                "end_line": 1907,
                "line_count": 10,
                "signature": "void ArrayBufferObject::setDataPointer(BufferContents contents) { setFixedSlot(DATA_SLOT, PrivateValue(contents.data())); setFlags((flags() & ~KIND_MASK) | contents.kind());"
              },
              {
                "name": "MappedSize",
                "type": "method",
                "start_line": 1909,
                "end_line": 1911,
                "line_count": 3,
                "signature": "size_t ArrayBufferObject::byteLength() const { return size_t(getFixedSlot(BYTE_LENGTH_SLOT).toPrivate()); }"
              },
              {
                "name": "\nAddressType Ar",
                "type": "method",
                "start_line": 1913,
                "end_line": 1921,
                "line_count": 9,
                "signature": "inline size_t ArrayBufferObject::associatedBytes() const { if (isMalloced()) { return maxByteLength();"
              },
              {
                "name": "smPages() con",
                "type": "method",
                "start_line": 1923,
                "end_line": 1926,
                "line_count": 4,
                "signature": "void ArrayBufferObject::setByteLength(size_t length) { MOZ_ASSERT(length <= ArrayBufferObject::ByteLengthLimit); setFixedSlot(BYTE_LENGTH_SLOT, PrivateValue(length));"
              },
              {
                "name": "ages ArrayBuff",
                "type": "method",
                "start_line": 1928,
                "end_line": 1933,
                "line_count": 6,
                "signature": "size_t ArrayBufferObject::wasmMappedSize() const { if (isWasm()) { return contents().wasmBuffer()->mappedSize();"
              },
              {
                "name": "ForAsmJS());\n  ",
                "type": "method",
                "start_line": 1935,
                "end_line": 1941,
                "line_count": 7,
                "signature": "AddressType ArrayBufferObject::wasmAddressType() const { if (isWasm()) { return contents().wasmBuffer()->addressType();"
              },
              {
                "name": "();\n  }\n ",
                "type": "method",
                "start_line": 1943,
                "end_line": 1949,
                "line_count": 7,
                "signature": "Pages ArrayBufferObject::wasmPages() const { if (isWasm()) { return contents().wasmBuffer()->pages();"
              },
              {
                "name": "is<ArrayBufferObjec",
                "type": "method",
                "start_line": 1951,
                "end_line": 1957,
                "line_count": 7,
                "signature": "Pages ArrayBufferObject::wasmClampedMaxPages() const { if (isWasm()) { return contents().wasmBuffer()->clampedMaxPages();"
              },
              {
                "name": "eShared* buf) {\n  ",
                "type": "method",
                "start_line": 1959,
                "end_line": 1965,
                "line_count": 7,
                "signature": "Maybe<Pages> ArrayBufferObject::wasmSourceMaxPages() const { if (isWasm()) { return contents().wasmBuffer()->sourceMaxPages();"
              },
              {
                "name": "ArrayBufferObjectMaybeSha",
                "type": "method",
                "start_line": 1967,
                "end_line": 1972,
                "line_count": 6,
                "signature": "size_t js::WasmArrayBufferMappedSize(const ArrayBufferObjectMaybeShared* buf) { if (buf->is<ArrayBufferObject>()) { return buf->as<ArrayBufferObject>().wasmMappedSize();"
              },
              {
                "name": " ArrayBufferObjectMaybeSha",
                "type": "method",
                "start_line": 1974,
                "end_line": 1980,
                "line_count": 7,
                "signature": "AddressType js::WasmArrayBufferAddressType( const ArrayBufferObjectMaybeShared* buf) { if (buf->is<ArrayBufferObject>()) {"
              },
              {
                "name": "axPages(\n    const A",
                "type": "method",
                "start_line": 1981,
                "end_line": 1986,
                "line_count": 6,
                "signature": "Pages js::WasmArrayBufferPages(const ArrayBufferObjectMaybeShared* buf) { if (buf->is<ArrayBufferObject>()) { return buf->as<ArrayBufferObject>().wasmPages();"
              },
              {
                "name": "tatic void CheckStealPrecondit",
                "type": "method",
                "start_line": 1987,
                "end_line": 1993,
                "line_count": 7,
                "signature": "Pages js::WasmArrayBufferClampedMaxPages( const ArrayBufferObjectMaybeShared* buf) { if (buf->is<ArrayBufferObject>()) {"
              },
              {
                "name": "from an immutable buffer\");\n ",
                "type": "method",
                "start_line": 1994,
                "end_line": 2000,
                "line_count": 7,
                "signature": "Maybe<Pages> js::WasmArrayBufferSourceMaxPages( const ArrayBufferObjectMaybeShared* buf) { if (buf->is<ArrayBufferObject>()) {"
              },
              {
                "name": "\nArrayBufferObject* Arr",
                "type": "function",
                "start_line": 2002,
                "end_line": 2012,
                "line_count": 11,
                "signature": "static void CheckStealPreconditions(Handle<ArrayBufferObject*> buffer, JSContext* cx) { cx->check(buffer);"
              },
              {
                "name": "turn js::gc",
                "type": "method",
                "start_line": 2148,
                "end_line": 2152,
                "line_count": 5,
                "signature": "void ArrayBufferObject::wasmDiscard(Handle<ArrayBufferObject*> buf, uint64_t byteOffset, uint64_t byteLen) { MOZ_ASSERT(buf->isWasm());"
              },
              {
                "name": "lass ",
                "type": "method",
                "start_line": 2154,
                "end_line": 2156,
                "line_count": 3,
                "signature": "uint32_t ArrayBufferObject::flags() const { return uint32_t(getFixedSlot(FLAGS_SLOT).toInt32()); }"
              },
              {
                "name": "to_,\n   ",
                "type": "method",
                "start_line": 2158,
                "end_line": 2160,
                "line_count": 3,
                "signature": "void ArrayBufferObject::setFlags(uint32_t flags) { setFixedSlot(FLAGS_SLOT, Int32Value(flags)); }"
              },
              {
                "name": "Kind::ARRAYBUFFER4 ||\n    ",
                "type": "function",
                "start_line": 2162,
                "end_line": 2173,
                "line_count": 12,
                "signature": "static constexpr js::gc::AllocKind GetArrayBufferGCObjectKind(size_t numSlots) { if (numSlots <= 4) { return js::gc::AllocKind::ARRAYBUFFER4;"
              },
              {
                "name": "h the object by repurposing fixe",
                "type": "method",
                "start_line": 2358,
                "end_line": 2416,
                "line_count": 59,
                "signature": "/* static */ std::tuple<ArrayBufferType*, uint8_t*> ArrayBufferObject::createUninitializedBufferAndData( JSContext* cx, size_t nbytes, AutoSetNewObjectMetadata&,"
              },
              {
                "name": " metadata, proto);\n",
                "type": "method",
                "start_line": 2419,
                "end_line": 2445,
                "line_count": 27,
                "signature": "/* static */ std::tuple<ArrayBufferType*, uint8_t*> ArrayBufferObject::createBufferAndData( JSContext* cx, size_t nbytes, AutoSetNewObjectMetadata& metadata,"
              },
              {
                "name": "e allocating the ma",
                "type": "method",
                "start_line": 2448,
                "end_line": 2480,
                "line_count": 33,
                "signature": "/* static */ std::tuple<ResizableArrayBufferObject*, uint8_t*> ResizableArrayBufferObject::createBufferAndData( JSContext* cx, size_t byteLength, size_t maxByteLength,"
              },
              {
                "name": "Contents contents = buffer->co",
                "type": "method",
                "start_line": 3013,
                "end_line": 3074,
                "line_count": 62,
                "signature": "/* static */ ArrayBufferObject::BufferContents ArrayBufferObject::extractStructuredCloneContents( JSContext* cx, Handle<ArrayBufferObject*> buffer) {"
              },
              {
                "name": " != INLINE_DATA",
                "type": "method",
                "start_line": 3077,
                "end_line": 3122,
                "line_count": 46,
                "signature": "bool ArrayBufferObject::ensureNonInline(JSContext* cx, Handle<ArrayBufferObject*> buffer) { if (buffer->isDetached() || buffer->isPreparedForAsmJS()) {"
              },
              {
                "name": "mallocSizeOf(buffer.da",
                "type": "method",
                "start_line": 3125,
                "end_line": 3169,
                "line_count": 45,
                "signature": "void ArrayBufferObject::addSizeOfExcludingThis( JSObject* obj, mozilla::MallocSizeOf mallocSizeOf, JS::ClassInfo* info, JS::RuntimeSizes* runtimeSizes) {"
              },
              {
                "name": ">byteLen",
                "type": "method",
                "start_line": 3172,
                "end_line": 3174,
                "line_count": 3,
                "signature": "void ArrayBufferObject::finalize(JS::GCContext* gcx, JSObject* obj) { obj->as<ArrayBufferObject>().releaseData(gcx); }"
              },
              {
                "name": "        ",
                "type": "method",
                "start_line": 3177,
                "end_line": 3189,
                "line_count": 13,
                "signature": "void ArrayBufferObject::copyData(ArrayBufferObject* toBuffer, size_t toIndex, ArrayBufferObject* fromBuffer, size_t fromIndex, size_t count) {"
              },
              {
                "name": "!nursery.is",
                "type": "method",
                "start_line": 3193,
                "end_line": 3213,
                "line_count": 21,
                "signature": "size_t ArrayBufferObject::objectMoved(JSObject* obj, JSObject* old) { auto& dst = obj->as<ArrayBufferType>(); const auto& src = old->as<ArrayBufferType>();"
              },
              {
                "name": "own) {\n  swi",
                "type": "method",
                "start_line": 3221,
                "end_line": 3223,
                "line_count": 3,
                "signature": "void ArrayBufferObject::setFirstView(ArrayBufferViewObject* view) { setFixedSlot(FIRST_VIEW_SLOT, ObjectOrNullValue(view)); }"
              },
              {
                "name": "rrayBuf",
                "type": "method",
                "start_line": 3225,
                "end_line": 3232,
                "line_count": 8,
                "signature": "bool ArrayBufferObject::addView(JSContext* cx, ArrayBufferViewObject* view) { if (!firstView()) { setFirstView(view);"
              },
              {
                "name": "\");\n      break;\n ",
                "type": "function",
                "start_line": 3237,
                "end_line": 3268,
                "line_count": 32,
                "signature": "void BufferKindToString(ArrayBufferObject::BufferKind kind, KnownF known, UnknownF unknown) { switch (kind) {"
              },
              {
                "name": " break;\n    }\n  }\n}\n\nv",
                "type": "function",
                "start_line": 3271,
                "end_line": 3289,
                "line_count": 19,
                "signature": "void ForEachArrayBufferFlag(uint32_t flags, KnownF known, UnknownF unknown) { for (uint32_t i = ArrayBufferObject::ArrayBufferFlags::BUFFER_KIND_MASK + 1; i; i = i << 1) {"
              },
              {
                "name": "_t value) { j",
                "type": "method",
                "start_line": 3291,
                "end_line": 3314,
                "line_count": 24,
                "signature": "void ArrayBufferObject::dumpOwnFields(js::JSONPrinter& json) const { json.formatProperty(\"byteLength\", \"%zu\", size_t(getFixedSlot(BYTE_LENGTH_SLOT).toPrivate()));"
              },
              {
                "name": "first = false;\n     ",
                "type": "method",
                "start_line": 3316,
                "end_line": 3351,
                "line_count": 36,
                "signature": "void ArrayBufferObject::dumpOwnStringContent(js::GenericPrinter& out) const { out.printf(\"byteLength=%zu, \", size_t(getFixedSlot(BYTE_LENGTH_SLOT).toPrivate()));"
              },
              {
                "name": "urseryV",
                "type": "method",
                "start_line": 3430,
                "end_line": 3467,
                "line_count": 38,
                "signature": "bool InnerViewTable::addView(JSContext* cx, ArrayBufferObject* buffer, ArrayBufferViewObject* view) { // ArrayBufferObject entries are only added when there are multiple views."
              },
              {
                "name": "ject* buffe",
                "type": "method",
                "start_line": 3478,
                "end_line": 3483,
                "line_count": 6,
                "signature": "void InnerViewTable::removeViews(ArrayBufferObject* buffer) { auto ptr = map.lookup(buffer); MOZ_ASSERT(ptr);"
              },
              {
                "name": "fterMinor",
                "type": "method",
                "start_line": 3485,
                "end_line": 3489,
                "line_count": 5,
                "signature": "bool InnerViewTable::traceWeak(JSTracer* trc) { nurseryKeys.traceWeak(trc); map.traceWeak(trc);"
              },
              {
                "name": "at every map entr",
                "type": "method",
                "start_line": 3491,
                "end_line": 3518,
                "line_count": 28,
                "signature": "void InnerViewTable::sweepAfterMinorGC(JSTracer* trc) { MOZ_ASSERT(needsSweepAfterMinorGC()); "
              },
              {
                "name": "    vectorSize += r.fr",
                "type": "method",
                "start_line": 3520,
                "end_line": 3532,
                "line_count": 13,
                "signature": "bool InnerViewTable::sweepViewsAfterMinorGC(JSTracer* trc, ArrayBufferObject* buffer, Views& views) {"
              },
              {
                "name": "ferByteLength(JSObj",
                "type": "method",
                "start_line": 3534,
                "end_line": 3542,
                "line_count": 9,
                "signature": "size_t InnerViewTable::sizeOfExcludingThis(mozilla::MallocSizeOf mallocSizeOf) { size_t vectorSize = 0; for (auto r = map.all(); !r.empty(); r.popFront()) {"
              },
              {
                "name": "tatic ArrayBufferObject*",
                "type": "method",
                "start_line": 3549,
                "end_line": 3552,
                "line_count": 4,
                "signature": "JS_PUBLIC_API size_t JS::GetArrayBufferByteLength(JSObject* obj) { ArrayBufferObject* aobj = obj->maybeUnwrapAs<ArrayBufferObject>(); return aobj ? aobj->byteLength() : 0;"
              },
              {
                "name": "ge, nullptr,\n    ",
                "type": "method",
                "start_line": 3582,
                "end_line": 3612,
                "line_count": 31,
                "signature": "JS_PUBLIC_API bool JS::DetachArrayBuffer(JSContext* cx, HandleObject obj) { AssertHeapIsIdle(); CHECK_THREAD(cx);"
              },
              {
                "name": "fferObject>();\n  if (!aobj) {\n",
                "type": "method",
                "start_line": 3614,
                "end_line": 3625,
                "line_count": 12,
                "signature": "JS_PUBLIC_API bool JS::HasDefinedArrayBufferDetachKey(JSContext* cx, HandleObject obj, bool* isDefined) {"
              },
              {
                "name": "rayBufferWithContents(\n    ",
                "type": "method",
                "start_line": 3627,
                "end_line": 3634,
                "line_count": 8,
                "signature": "JS_PUBLIC_API bool JS::IsDetachedArrayBufferObject(JSObject* obj) { ArrayBufferObject* aobj = obj->maybeUnwrapIf<ArrayBufferObject>(); if (!aobj) {"
              },
              {
                "name": "                   ",
                "type": "method",
                "start_line": 3734,
                "end_line": 3736,
                "line_count": 3,
                "signature": "JS_PUBLIC_API bool JS::IsArrayBufferObject(JSObject* obj) { return obj->canUnwrapAs<ArrayBufferObject>(); }"
              },
              {
                "name": "(obj);\n\n  Rooted<A",
                "type": "method",
                "start_line": 3738,
                "end_line": 3740,
                "line_count": 3,
                "signature": "JS_PUBLIC_API bool JS::ArrayBufferHasData(JSObject* obj) { return !obj->unwrapAs<ArrayBufferObject>().isDetached(); }"
              },
              {
                "name": "                                ",
                "type": "method",
                "start_line": 3807,
                "end_line": 3810,
                "line_count": 4,
                "signature": "JS_PUBLIC_API void JS::ReleaseMappedArrayBufferContents(void* contents, size_t length) { gc::DeallocateMappedContent(contents, length);"
              },
              {
                "name": "ta = aobj->dataPointer();",
                "type": "method",
                "start_line": 3812,
                "end_line": 3819,
                "line_count": 8,
                "signature": "JS_PUBLIC_API bool JS::IsMappedArrayBufferObject(JSObject* obj) { ArrayBufferObject* aobj = obj->maybeUnwrapIf<ArrayBufferObject>(); if (!aobj) {"
              },
              {
                "name": "ffer::ResizableUnsharedClas",
                "type": "method",
                "start_line": 3835,
                "end_line": 3843,
                "line_count": 9,
                "signature": "JS_PUBLIC_API void JS::GetArrayBufferLengthAndData(JSObject* obj, size_t* length, bool* isSharedMemory,"
              },
              {
                "name": ");\n  if (!unwrapped",
                "type": "method",
                "start_line": 3886,
                "end_line": 3936,
                "line_count": 51,
                "signature": "bool JS::ArrayBufferCopyData(JSContext* cx, Handle<JSObject*> toBlock, size_t toIndex, Handle<JSObject*> fromBlock, size_t fromIndex, size_t count) {"
              }
            ]
          },
          "hunks_count": 1,
          "hunk_ranges": [
            "@@ -546,6 @@"
          ]
        }
      ]
    },
    {
      "filepath": "js/src/vm/SharedArrayObject.cpp",
      "fixing_commits": [
        {
          "commit_hash": "75d829afb4b0",
          "full_hash": "75d829afb4b06a3a8b7e91ea15c8a0cf34665fb7",
          "parent_hash": "896c8ee9171db6fb15ab84ff673c1272c46f28b2",
          "commit_type": "fixing",
          "filepath": "js/src/vm/SharedArrayObject.cpp",
          "diff_found": true,
          "diff_path": "/Users/sidiqafekrat/Mozilla_crashAnalyzer_BugBug/method2_bugzilla_bugs/outputs/step5_extracted_diffs/bug_1988694/fixing_commit/75d829afb4b0/js_src_vm_SharedArrayObject.cpp.diff",
          "methods_count": 33,
          "matched_methods": {
            "fully_modified": [],
            "partially_modified": [
              {
                "name": "maxByteLengthGetterImpl",
                "type": "method",
                "start_line": 329,
                "end_line": 359,
                "line_count": 31,
                "signature": "bool SharedArrayBufferObject::maxByteLengthGetterImpl(JSContext* cx, const CallArgs& args) { MOZ_ASSERT(IsSharedArrayBuffer(args.thisv()));",
                "changed_lines": [
                  331,
                  332,
                  333,
                  334,
                  335,
                  336,
                  337,
                  338,
                  339,
                  340,
                  341,
                  342,
                  343,
                  344,
                  345,
                  346,
                  347,
                  348,
                  349,
                  350,
                  351,
                  352,
                  353,
                  354,
                  355,
                  356,
                  357,
                  358
                ],
                "overlap_count": 28,
                "overlap_percentage": 90.3
              }
            ],
            "unmodified": [
              {
                "name": "WasmSharedArrayAccessibleSize",
                "type": "function",
                "start_line": 40,
                "end_line": 42,
                "line_count": 3,
                "signature": "static size_t WasmSharedArrayAccessibleSize(size_t length) { return AlignBytes(length, gc::SystemPageSize()); }"
              },
              {
                "name": "NonWasmSharedArrayAllocSize",
                "type": "function",
                "start_line": 44,
                "end_line": 47,
                "line_count": 4,
                "signature": "static size_t NonWasmSharedArrayAllocSize(size_t length) { MOZ_ASSERT(length <= ArrayBufferObject::ByteLengthLimit); return sizeof(SharedArrayRawBuffer) + length;"
              },
              {
                "name": "SharedArrayMappedSize",
                "type": "function",
                "start_line": 53,
                "end_line": 60,
                "line_count": 8,
                "signature": "static size_t SharedArrayMappedSize(bool isWasm, size_t length) { // Wasm buffers use MapBufferMemory and allocate a full page for the header. // Non-Wasm buffers use malloc."
              },
              {
                "name": "wasmGrowToPagesInPlace",
                "type": "method",
                "start_line": 135,
                "end_line": 173,
                "line_count": 39,
                "signature": "bool WasmSharedArrayRawBuffer::wasmGrowToPagesInPlace(const Lock&, wasm::AddressType t, wasm::Pages newPages) {"
              },
              {
                "name": "discard",
                "type": "method",
                "start_line": 175,
                "end_line": 234,
                "line_count": 60,
                "signature": "void WasmSharedArrayRawBuffer::discard(size_t byteOffset, size_t byteLen) { SharedMem<uint8_t*> memBase = dataPointerShared(); "
              },
              {
                "name": "addReference",
                "type": "method",
                "start_line": 236,
                "end_line": 250,
                "line_count": 15,
                "signature": "bool SharedArrayRawBuffer::addReference() { MOZ_RELEASE_ASSERT(refcount_ > 0); "
              },
              {
                "name": "dropReference",
                "type": "method",
                "start_line": 252,
                "end_line": 278,
                "line_count": 27,
                "signature": "void SharedArrayRawBuffer::dropReference() { // Normally if the refcount is zero then the memory will have been unmapped // and this test may just crash, but if the memory has been retained for any"
              },
              {
                "name": "growJS",
                "type": "method",
                "start_line": 280,
                "end_line": 301,
                "line_count": 22,
                "signature": "bool SharedArrayRawBuffer::growJS(size_t newByteLength) { MOZ_ASSERT(!isWasm()); MOZ_RELEASE_ASSERT(isGrowableJS());"
              },
              {
                "name": "IsSharedArrayBuffer",
                "type": "function",
                "start_line": 303,
                "end_line": 305,
                "line_count": 3,
                "signature": "static bool IsSharedArrayBuffer(HandleValue v) { return v.isObject() && v.toObject().is<SharedArrayBufferObject>(); }"
              },
              {
                "name": "IsGrowableSharedArrayBuffer",
                "type": "function",
                "start_line": 307,
                "end_line": 309,
                "line_count": 3,
                "signature": "static bool IsGrowableSharedArrayBuffer(HandleValue v) { return v.isObject() && v.toObject().is<GrowableSharedArrayBufferObject>(); }"
              },
              {
                "name": "byteLengthGetterImpl",
                "type": "method",
                "start_line": 311,
                "end_line": 317,
                "line_count": 7,
                "signature": "MOZ_ALWAYS_INLINE bool SharedArrayBufferObject::byteLengthGetterImpl( JSContext* cx, const CallArgs& args) { MOZ_ASSERT(IsSharedArrayBuffer(args.thisv()));"
              },
              {
                "name": "byteLengthGetter",
                "type": "method",
                "start_line": 319,
                "end_line": 324,
                "line_count": 6,
                "signature": "bool SharedArrayBufferObject::byteLengthGetter(JSContext* cx, unsigned argc, Value* vp) { CallArgs args = CallArgsFromVp(argc, vp);"
              },
              {
                "name": "maxByteLengthGetter",
                "type": "method",
                "start_line": 364,
                "end_line": 370,
                "line_count": 7,
                "signature": "bool SharedArrayBufferObject::maxByteLengthGetter(JSContext* cx, unsigned argc, Value* vp) { // Steps 1-3."
              },
              {
                "name": "growableGetterImpl",
                "type": "method",
                "start_line": 375,
                "end_line": 383,
                "line_count": 9,
                "signature": "bool SharedArrayBufferObject::growableGetterImpl(JSContext* cx, const CallArgs& args) { MOZ_ASSERT(IsSharedArrayBuffer(args.thisv()));"
              },
              {
                "name": "growableGetter",
                "type": "method",
                "start_line": 388,
                "end_line": 394,
                "line_count": 7,
                "signature": "bool SharedArrayBufferObject::growableGetter(JSContext* cx, unsigned argc, Value* vp) { // Steps 1-3."
              },
              {
                "name": "growImpl",
                "type": "method",
                "start_line": 399,
                "end_line": 448,
                "line_count": 50,
                "signature": "bool SharedArrayBufferObject::growImpl(JSContext* cx, const CallArgs& args) { MOZ_ASSERT(IsGrowableSharedArrayBuffer(args.thisv())); Rooted<GrowableSharedArrayBufferObject*> buffer("
              },
              {
                "name": "grow",
                "type": "method",
                "start_line": 453,
                "end_line": 457,
                "line_count": 5,
                "signature": "bool SharedArrayBufferObject::grow(JSContext* cx, unsigned argc, Value* vp) { // Steps 1-3. CallArgs args = CallArgsFromVp(argc, vp);"
              },
              {
                "name": "IsSharedArrayBufferSpecies",
                "type": "function",
                "start_line": 459,
                "end_line": 462,
                "line_count": 4,
                "signature": "static bool IsSharedArrayBufferSpecies(JSContext* cx, JSFunction* species) { return IsSelfHostedFunctionWithName( species, cx->names().dollar_SharedArrayBufferSpecies_);"
              },
              {
                "name": "HasBuiltinSharedArrayBufferSpecies",
                "type": "function",
                "start_line": 464,
                "end_line": 484,
                "line_count": 21,
                "signature": "static bool HasBuiltinSharedArrayBufferSpecies(SharedArrayBufferObject* obj, JSContext* cx) { // Ensure `SharedArrayBuffer.prototype.constructor` and"
              },
              {
                "name": "sliceImpl",
                "type": "method",
                "start_line": 491,
                "end_line": 596,
                "line_count": 106,
                "signature": "bool SharedArrayBufferObject::sliceImpl(JSContext* cx, const CallArgs& args) { MOZ_ASSERT(IsSharedArrayBuffer(args.thisv())); "
              },
              {
                "name": "slice",
                "type": "method",
                "start_line": 603,
                "end_line": 607,
                "line_count": 5,
                "signature": "bool SharedArrayBufferObject::slice(JSContext* cx, unsigned argc, Value* vp) { // Steps 1-3. CallArgs args = CallArgsFromVp(argc, vp);"
              },
              {
                "name": "class_constructor",
                "type": "method",
                "start_line": 611,
                "end_line": 688,
                "line_count": 78,
                "signature": "bool SharedArrayBufferObject::class_constructor(JSContext* cx, unsigned argc, Value* vp) { CallArgs args = CallArgsFromVp(argc, vp);"
              },
              {
                "name": "acceptRawBuffer",
                "type": "method",
                "start_line": 777,
                "end_line": 790,
                "line_count": 14,
                "signature": "bool SharedArrayBufferObject::acceptRawBuffer(SharedArrayRawBuffer* buffer, size_t length) { MOZ_ASSERT(!isInitialized());"
              },
              {
                "name": "dropRawBuffer",
                "type": "method",
                "start_line": 792,
                "end_line": 800,
                "line_count": 9,
                "signature": "void SharedArrayBufferObject::dropRawBuffer() { size_t length = byteLengthOrMaxByteLength(); size_t size = SharedArrayMappedSize(isWasm(), length);"
              },
              {
                "name": "Finalize",
                "type": "method",
                "start_line": 808,
                "end_line": 821,
                "line_count": 14,
                "signature": "void SharedArrayBufferObject::Finalize(JS::GCContext* gcx, JSObject* obj) { // Must be foreground finalizable so that we can account for the object. MOZ_ASSERT(gcx->onMainThread());"
              },
              {
                "name": "addSizeOfExcludingThis",
                "type": "method",
                "start_line": 824,
                "end_line": 851,
                "line_count": 28,
                "signature": "void SharedArrayBufferObject::addSizeOfExcludingThis( JSObject* obj, mozilla::MallocSizeOf mallocSizeOf, JS::ClassInfo* info, JS::RuntimeSizes* runtimeSizes) {"
              },
              {
                "name": "copyData",
                "type": "method",
                "start_line": 854,
                "end_line": 868,
                "line_count": 15,
                "signature": "void SharedArrayBufferObject::copyData(ArrayBufferObjectMaybeShared* toBuffer, size_t toIndex, ArrayBufferObjectMaybeShared* fromBuffer,"
              },
              {
                "name": "wasmDiscard",
                "type": "method",
                "start_line": 933,
                "end_line": 938,
                "line_count": 6,
                "signature": "void SharedArrayBufferObject::wasmDiscard(Handle<SharedArrayBufferObject*> buf, uint64_t byteOffset, uint64_t byteLen) {"
              },
              {
                "name": "GetSharedArrayBufferByteLength",
                "type": "method",
                "start_line": 1022,
                "end_line": 1025,
                "line_count": 4,
                "signature": "JS_PUBLIC_API size_t JS::GetSharedArrayBufferByteLength(JSObject* obj) { auto* aobj = obj->maybeUnwrapAs<SharedArrayBufferObject>(); return aobj ? aobj->byteLength() : 0;"
              },
              {
                "name": "GetSharedArrayBufferLengthAndData",
                "type": "method",
                "start_line": 1027,
                "end_line": 1036,
                "line_count": 10,
                "signature": "JS_PUBLIC_API void JS::GetSharedArrayBufferLengthAndData(JSObject* obj, size_t* length, bool* isSharedMemory,"
              },
              {
                "name": "IsSharedArrayBufferObject",
                "type": "method",
                "start_line": 1051,
                "end_line": 1053,
                "line_count": 3,
                "signature": "JS_PUBLIC_API bool JS::IsSharedArrayBufferObject(JSObject* obj) { return obj->canUnwrapAs<SharedArrayBufferObject>(); }"
              },
              {
                "name": "ContainsSharedArrayBuffer",
                "type": "method",
                "start_line": 1065,
                "end_line": 1067,
                "line_count": 3,
                "signature": "JS_PUBLIC_API bool JS::ContainsSharedArrayBuffer(JSContext* cx) { return cx->runtime()->hasLiveSABs(); }"
              }
            ]
          },
          "hunks_count": 1,
          "hunk_ranges": [
            "@@ -331,28 @@"
          ]
        }
      ],
      "regressor_commits": [
        {
          "commit_hash": "75d829afb4b0",
          "full_hash": "75d829afb4b06a3a8b7e91ea15c8a0cf34665fb7",
          "parent_hash": "896c8ee9171db6fb15ab84ff673c1272c46f28b2",
          "commit_type": "regressor",
          "filepath": "js/src/vm/SharedArrayObject.cpp",
          "diff_found": true,
          "diff_path": "/Users/sidiqafekrat/Mozilla_crashAnalyzer_BugBug/method2_bugzilla_bugs/outputs/step5_extracted_diffs/bug_1988694/regressor_commits/regressor_1969509_75d829afb4b0/js_src_vm_SharedArrayObject.cpp.diff",
          "methods_count": 33,
          "matched_methods": {
            "fully_modified": [],
            "partially_modified": [
              {
                "name": "maxByteLengthGetterImpl",
                "type": "method",
                "start_line": 329,
                "end_line": 359,
                "line_count": 31,
                "signature": "bool SharedArrayBufferObject::maxByteLengthGetterImpl(JSContext* cx, const CallArgs& args) { MOZ_ASSERT(IsSharedArrayBuffer(args.thisv()));",
                "changed_lines": [
                  331,
                  332,
                  333,
                  334,
                  335,
                  336,
                  337,
                  338,
                  339,
                  340,
                  341,
                  342,
                  343,
                  344,
                  345,
                  346,
                  347,
                  348,
                  349,
                  350,
                  351,
                  352,
                  353,
                  354,
                  355,
                  356,
                  357,
                  358
                ],
                "overlap_count": 28,
                "overlap_percentage": 90.3
              }
            ],
            "unmodified": [
              {
                "name": "WasmSharedArrayAccessibleSize",
                "type": "function",
                "start_line": 40,
                "end_line": 42,
                "line_count": 3,
                "signature": "static size_t WasmSharedArrayAccessibleSize(size_t length) { return AlignBytes(length, gc::SystemPageSize()); }"
              },
              {
                "name": "NonWasmSharedArrayAllocSize",
                "type": "function",
                "start_line": 44,
                "end_line": 47,
                "line_count": 4,
                "signature": "static size_t NonWasmSharedArrayAllocSize(size_t length) { MOZ_ASSERT(length <= ArrayBufferObject::ByteLengthLimit); return sizeof(SharedArrayRawBuffer) + length;"
              },
              {
                "name": "SharedArrayMappedSize",
                "type": "function",
                "start_line": 53,
                "end_line": 60,
                "line_count": 8,
                "signature": "static size_t SharedArrayMappedSize(bool isWasm, size_t length) { // Wasm buffers use MapBufferMemory and allocate a full page for the header. // Non-Wasm buffers use malloc."
              },
              {
                "name": "wasmGrowToPagesInPlace",
                "type": "method",
                "start_line": 135,
                "end_line": 173,
                "line_count": 39,
                "signature": "bool WasmSharedArrayRawBuffer::wasmGrowToPagesInPlace(const Lock&, wasm::AddressType t, wasm::Pages newPages) {"
              },
              {
                "name": "discard",
                "type": "method",
                "start_line": 175,
                "end_line": 234,
                "line_count": 60,
                "signature": "void WasmSharedArrayRawBuffer::discard(size_t byteOffset, size_t byteLen) { SharedMem<uint8_t*> memBase = dataPointerShared(); "
              },
              {
                "name": "addReference",
                "type": "method",
                "start_line": 236,
                "end_line": 250,
                "line_count": 15,
                "signature": "bool SharedArrayRawBuffer::addReference() { MOZ_RELEASE_ASSERT(refcount_ > 0); "
              },
              {
                "name": "dropReference",
                "type": "method",
                "start_line": 252,
                "end_line": 278,
                "line_count": 27,
                "signature": "void SharedArrayRawBuffer::dropReference() { // Normally if the refcount is zero then the memory will have been unmapped // and this test may just crash, but if the memory has been retained for any"
              },
              {
                "name": "growJS",
                "type": "method",
                "start_line": 280,
                "end_line": 301,
                "line_count": 22,
                "signature": "bool SharedArrayRawBuffer::growJS(size_t newByteLength) { MOZ_ASSERT(!isWasm()); MOZ_RELEASE_ASSERT(isGrowableJS());"
              },
              {
                "name": "IsSharedArrayBuffer",
                "type": "function",
                "start_line": 303,
                "end_line": 305,
                "line_count": 3,
                "signature": "static bool IsSharedArrayBuffer(HandleValue v) { return v.isObject() && v.toObject().is<SharedArrayBufferObject>(); }"
              },
              {
                "name": "IsGrowableSharedArrayBuffer",
                "type": "function",
                "start_line": 307,
                "end_line": 309,
                "line_count": 3,
                "signature": "static bool IsGrowableSharedArrayBuffer(HandleValue v) { return v.isObject() && v.toObject().is<GrowableSharedArrayBufferObject>(); }"
              },
              {
                "name": "byteLengthGetterImpl",
                "type": "method",
                "start_line": 311,
                "end_line": 317,
                "line_count": 7,
                "signature": "MOZ_ALWAYS_INLINE bool SharedArrayBufferObject::byteLengthGetterImpl( JSContext* cx, const CallArgs& args) { MOZ_ASSERT(IsSharedArrayBuffer(args.thisv()));"
              },
              {
                "name": "byteLengthGetter",
                "type": "method",
                "start_line": 319,
                "end_line": 324,
                "line_count": 6,
                "signature": "bool SharedArrayBufferObject::byteLengthGetter(JSContext* cx, unsigned argc, Value* vp) { CallArgs args = CallArgsFromVp(argc, vp);"
              },
              {
                "name": "maxByteLengthGetter",
                "type": "method",
                "start_line": 364,
                "end_line": 370,
                "line_count": 7,
                "signature": "bool SharedArrayBufferObject::maxByteLengthGetter(JSContext* cx, unsigned argc, Value* vp) { // Steps 1-3."
              },
              {
                "name": "growableGetterImpl",
                "type": "method",
                "start_line": 375,
                "end_line": 383,
                "line_count": 9,
                "signature": "bool SharedArrayBufferObject::growableGetterImpl(JSContext* cx, const CallArgs& args) { MOZ_ASSERT(IsSharedArrayBuffer(args.thisv()));"
              },
              {
                "name": "growableGetter",
                "type": "method",
                "start_line": 388,
                "end_line": 394,
                "line_count": 7,
                "signature": "bool SharedArrayBufferObject::growableGetter(JSContext* cx, unsigned argc, Value* vp) { // Steps 1-3."
              },
              {
                "name": "growImpl",
                "type": "method",
                "start_line": 399,
                "end_line": 448,
                "line_count": 50,
                "signature": "bool SharedArrayBufferObject::growImpl(JSContext* cx, const CallArgs& args) { MOZ_ASSERT(IsGrowableSharedArrayBuffer(args.thisv())); Rooted<GrowableSharedArrayBufferObject*> buffer("
              },
              {
                "name": "grow",
                "type": "method",
                "start_line": 453,
                "end_line": 457,
                "line_count": 5,
                "signature": "bool SharedArrayBufferObject::grow(JSContext* cx, unsigned argc, Value* vp) { // Steps 1-3. CallArgs args = CallArgsFromVp(argc, vp);"
              },
              {
                "name": "IsSharedArrayBufferSpecies",
                "type": "function",
                "start_line": 459,
                "end_line": 462,
                "line_count": 4,
                "signature": "static bool IsSharedArrayBufferSpecies(JSContext* cx, JSFunction* species) { return IsSelfHostedFunctionWithName( species, cx->names().dollar_SharedArrayBufferSpecies_);"
              },
              {
                "name": "HasBuiltinSharedArrayBufferSpecies",
                "type": "function",
                "start_line": 464,
                "end_line": 484,
                "line_count": 21,
                "signature": "static bool HasBuiltinSharedArrayBufferSpecies(SharedArrayBufferObject* obj, JSContext* cx) { // Ensure `SharedArrayBuffer.prototype.constructor` and"
              },
              {
                "name": "sliceImpl",
                "type": "method",
                "start_line": 491,
                "end_line": 596,
                "line_count": 106,
                "signature": "bool SharedArrayBufferObject::sliceImpl(JSContext* cx, const CallArgs& args) { MOZ_ASSERT(IsSharedArrayBuffer(args.thisv())); "
              },
              {
                "name": "slice",
                "type": "method",
                "start_line": 603,
                "end_line": 607,
                "line_count": 5,
                "signature": "bool SharedArrayBufferObject::slice(JSContext* cx, unsigned argc, Value* vp) { // Steps 1-3. CallArgs args = CallArgsFromVp(argc, vp);"
              },
              {
                "name": "class_constructor",
                "type": "method",
                "start_line": 611,
                "end_line": 688,
                "line_count": 78,
                "signature": "bool SharedArrayBufferObject::class_constructor(JSContext* cx, unsigned argc, Value* vp) { CallArgs args = CallArgsFromVp(argc, vp);"
              },
              {
                "name": "acceptRawBuffer",
                "type": "method",
                "start_line": 777,
                "end_line": 790,
                "line_count": 14,
                "signature": "bool SharedArrayBufferObject::acceptRawBuffer(SharedArrayRawBuffer* buffer, size_t length) { MOZ_ASSERT(!isInitialized());"
              },
              {
                "name": "dropRawBuffer",
                "type": "method",
                "start_line": 792,
                "end_line": 800,
                "line_count": 9,
                "signature": "void SharedArrayBufferObject::dropRawBuffer() { size_t length = byteLengthOrMaxByteLength(); size_t size = SharedArrayMappedSize(isWasm(), length);"
              },
              {
                "name": "Finalize",
                "type": "method",
                "start_line": 808,
                "end_line": 821,
                "line_count": 14,
                "signature": "void SharedArrayBufferObject::Finalize(JS::GCContext* gcx, JSObject* obj) { // Must be foreground finalizable so that we can account for the object. MOZ_ASSERT(gcx->onMainThread());"
              },
              {
                "name": "addSizeOfExcludingThis",
                "type": "method",
                "start_line": 824,
                "end_line": 851,
                "line_count": 28,
                "signature": "void SharedArrayBufferObject::addSizeOfExcludingThis( JSObject* obj, mozilla::MallocSizeOf mallocSizeOf, JS::ClassInfo* info, JS::RuntimeSizes* runtimeSizes) {"
              },
              {
                "name": "copyData",
                "type": "method",
                "start_line": 854,
                "end_line": 868,
                "line_count": 15,
                "signature": "void SharedArrayBufferObject::copyData(ArrayBufferObjectMaybeShared* toBuffer, size_t toIndex, ArrayBufferObjectMaybeShared* fromBuffer,"
              },
              {
                "name": "wasmDiscard",
                "type": "method",
                "start_line": 933,
                "end_line": 938,
                "line_count": 6,
                "signature": "void SharedArrayBufferObject::wasmDiscard(Handle<SharedArrayBufferObject*> buf, uint64_t byteOffset, uint64_t byteLen) {"
              },
              {
                "name": "GetSharedArrayBufferByteLength",
                "type": "method",
                "start_line": 1022,
                "end_line": 1025,
                "line_count": 4,
                "signature": "JS_PUBLIC_API size_t JS::GetSharedArrayBufferByteLength(JSObject* obj) { auto* aobj = obj->maybeUnwrapAs<SharedArrayBufferObject>(); return aobj ? aobj->byteLength() : 0;"
              },
              {
                "name": "GetSharedArrayBufferLengthAndData",
                "type": "method",
                "start_line": 1027,
                "end_line": 1036,
                "line_count": 10,
                "signature": "JS_PUBLIC_API void JS::GetSharedArrayBufferLengthAndData(JSObject* obj, size_t* length, bool* isSharedMemory,"
              },
              {
                "name": "IsSharedArrayBufferObject",
                "type": "method",
                "start_line": 1051,
                "end_line": 1053,
                "line_count": 3,
                "signature": "JS_PUBLIC_API bool JS::IsSharedArrayBufferObject(JSObject* obj) { return obj->canUnwrapAs<SharedArrayBufferObject>(); }"
              },
              {
                "name": "ContainsSharedArrayBuffer",
                "type": "method",
                "start_line": 1065,
                "end_line": 1067,
                "line_count": 3,
                "signature": "JS_PUBLIC_API bool JS::ContainsSharedArrayBuffer(JSContext* cx) { return cx->runtime()->hasLiveSABs(); }"
              }
            ]
          },
          "hunks_count": 1,
          "hunk_ranges": [
            "@@ -331,28 @@"
          ]
        },
        {
          "commit_hash": "13b7086f65cb",
          "full_hash": "13b7086f65cbbbf1fed6e0341cfbdfb309fb962c",
          "parent_hash": "f7c96ac82c1aa9ff1f1a873b6d15ac9c3900b05d",
          "commit_type": "regressor",
          "filepath": "js/src/vm/SharedArrayObject.cpp",
          "diff_found": true,
          "diff_path": "/Users/sidiqafekrat/Mozilla_crashAnalyzer_BugBug/method2_bugzilla_bugs/outputs/step5_extracted_diffs/bug_1988694/regressor_commits/regressor_1969509_13b7086f65cb/js_src_vm_SharedArrayObject.cpp.diff",
          "methods_count": 33,
          "matched_methods": {
            "fully_modified": [],
            "partially_modified": [
              {
                "name": "maxByteLengthGetterImpl",
                "type": "method",
                "start_line": 329,
                "end_line": 337,
                "line_count": 9,
                "signature": "bool SharedArrayBufferObject::maxByteLengthGetterImpl(JSContext* cx, const CallArgs& args) { MOZ_ASSERT(IsSharedArrayBuffer(args.thisv()));",
                "changed_lines": [
                  331,
                  332,
                  333,
                  334,
                  335,
                  336
                ],
                "overlap_count": 6,
                "overlap_percentage": 66.7
              }
            ],
            "unmodified": [
              {
                "name": "WasmSharedArrayAccessibleSize",
                "type": "function",
                "start_line": 40,
                "end_line": 42,
                "line_count": 3,
                "signature": "static size_t WasmSharedArrayAccessibleSize(size_t length) { return AlignBytes(length, gc::SystemPageSize()); }"
              },
              {
                "name": "NonWasmSharedArrayAllocSize",
                "type": "function",
                "start_line": 44,
                "end_line": 47,
                "line_count": 4,
                "signature": "static size_t NonWasmSharedArrayAllocSize(size_t length) { MOZ_ASSERT(length <= ArrayBufferObject::ByteLengthLimit); return sizeof(SharedArrayRawBuffer) + length;"
              },
              {
                "name": "SharedArrayMappedSize",
                "type": "function",
                "start_line": 53,
                "end_line": 60,
                "line_count": 8,
                "signature": "static size_t SharedArrayMappedSize(bool isWasm, size_t length) { // Wasm buffers use MapBufferMemory and allocate a full page for the header. // Non-Wasm buffers use malloc."
              },
              {
                "name": "wasmGrowToPagesInPlace",
                "type": "method",
                "start_line": 135,
                "end_line": 173,
                "line_count": 39,
                "signature": "bool WasmSharedArrayRawBuffer::wasmGrowToPagesInPlace(const Lock&, wasm::AddressType t, wasm::Pages newPages) {"
              },
              {
                "name": "discard",
                "type": "method",
                "start_line": 175,
                "end_line": 234,
                "line_count": 60,
                "signature": "void WasmSharedArrayRawBuffer::discard(size_t byteOffset, size_t byteLen) { SharedMem<uint8_t*> memBase = dataPointerShared(); "
              },
              {
                "name": "addReference",
                "type": "method",
                "start_line": 236,
                "end_line": 250,
                "line_count": 15,
                "signature": "bool SharedArrayRawBuffer::addReference() { MOZ_RELEASE_ASSERT(refcount_ > 0); "
              },
              {
                "name": "dropReference",
                "type": "method",
                "start_line": 252,
                "end_line": 278,
                "line_count": 27,
                "signature": "void SharedArrayRawBuffer::dropReference() { // Normally if the refcount is zero then the memory will have been unmapped // and this test may just crash, but if the memory has been retained for any"
              },
              {
                "name": "growJS",
                "type": "method",
                "start_line": 280,
                "end_line": 301,
                "line_count": 22,
                "signature": "bool SharedArrayRawBuffer::growJS(size_t newByteLength) { MOZ_ASSERT(!isWasm()); MOZ_RELEASE_ASSERT(isGrowableJS());"
              },
              {
                "name": "IsSharedArrayBuffer",
                "type": "function",
                "start_line": 303,
                "end_line": 305,
                "line_count": 3,
                "signature": "static bool IsSharedArrayBuffer(HandleValue v) { return v.isObject() && v.toObject().is<SharedArrayBufferObject>(); }"
              },
              {
                "name": "IsGrowableSharedArrayBuffer",
                "type": "function",
                "start_line": 307,
                "end_line": 309,
                "line_count": 3,
                "signature": "static bool IsGrowableSharedArrayBuffer(HandleValue v) { return v.isObject() && v.toObject().is<GrowableSharedArrayBufferObject>(); }"
              },
              {
                "name": "byteLengthGetterImpl",
                "type": "method",
                "start_line": 311,
                "end_line": 317,
                "line_count": 7,
                "signature": "MOZ_ALWAYS_INLINE bool SharedArrayBufferObject::byteLengthGetterImpl( JSContext* cx, const CallArgs& args) { MOZ_ASSERT(IsSharedArrayBuffer(args.thisv()));"
              },
              {
                "name": "byteLengthGetter",
                "type": "method",
                "start_line": 319,
                "end_line": 324,
                "line_count": 6,
                "signature": "bool SharedArrayBufferObject::byteLengthGetter(JSContext* cx, unsigned argc, Value* vp) { CallArgs args = CallArgsFromVp(argc, vp);"
              },
              {
                "name": "maxByteLengthGetter",
                "type": "method",
                "start_line": 342,
                "end_line": 348,
                "line_count": 7,
                "signature": "bool SharedArrayBufferObject::maxByteLengthGetter(JSContext* cx, unsigned argc, Value* vp) { // Steps 1-3."
              },
              {
                "name": "growableGetterImpl",
                "type": "method",
                "start_line": 353,
                "end_line": 361,
                "line_count": 9,
                "signature": "bool SharedArrayBufferObject::growableGetterImpl(JSContext* cx, const CallArgs& args) { MOZ_ASSERT(IsSharedArrayBuffer(args.thisv()));"
              },
              {
                "name": "growableGetter",
                "type": "method",
                "start_line": 366,
                "end_line": 372,
                "line_count": 7,
                "signature": "bool SharedArrayBufferObject::growableGetter(JSContext* cx, unsigned argc, Value* vp) { // Steps 1-3."
              },
              {
                "name": "growImpl",
                "type": "method",
                "start_line": 377,
                "end_line": 426,
                "line_count": 50,
                "signature": "bool SharedArrayBufferObject::growImpl(JSContext* cx, const CallArgs& args) { MOZ_ASSERT(IsGrowableSharedArrayBuffer(args.thisv())); Rooted<GrowableSharedArrayBufferObject*> buffer("
              },
              {
                "name": "grow",
                "type": "method",
                "start_line": 431,
                "end_line": 435,
                "line_count": 5,
                "signature": "bool SharedArrayBufferObject::grow(JSContext* cx, unsigned argc, Value* vp) { // Steps 1-3. CallArgs args = CallArgsFromVp(argc, vp);"
              },
              {
                "name": "IsSharedArrayBufferSpecies",
                "type": "function",
                "start_line": 437,
                "end_line": 440,
                "line_count": 4,
                "signature": "static bool IsSharedArrayBufferSpecies(JSContext* cx, JSFunction* species) { return IsSelfHostedFunctionWithName( species, cx->names().dollar_SharedArrayBufferSpecies_);"
              },
              {
                "name": "HasBuiltinSharedArrayBufferSpecies",
                "type": "function",
                "start_line": 442,
                "end_line": 462,
                "line_count": 21,
                "signature": "static bool HasBuiltinSharedArrayBufferSpecies(SharedArrayBufferObject* obj, JSContext* cx) { // Ensure `SharedArrayBuffer.prototype.constructor` and"
              },
              {
                "name": "sliceImpl",
                "type": "method",
                "start_line": 469,
                "end_line": 574,
                "line_count": 106,
                "signature": "bool SharedArrayBufferObject::sliceImpl(JSContext* cx, const CallArgs& args) { MOZ_ASSERT(IsSharedArrayBuffer(args.thisv())); "
              },
              {
                "name": "slice",
                "type": "method",
                "start_line": 581,
                "end_line": 585,
                "line_count": 5,
                "signature": "bool SharedArrayBufferObject::slice(JSContext* cx, unsigned argc, Value* vp) { // Steps 1-3. CallArgs args = CallArgsFromVp(argc, vp);"
              },
              {
                "name": "class_constructor",
                "type": "method",
                "start_line": 589,
                "end_line": 666,
                "line_count": 78,
                "signature": "bool SharedArrayBufferObject::class_constructor(JSContext* cx, unsigned argc, Value* vp) { CallArgs args = CallArgsFromVp(argc, vp);"
              },
              {
                "name": "acceptRawBuffer",
                "type": "method",
                "start_line": 755,
                "end_line": 768,
                "line_count": 14,
                "signature": "bool SharedArrayBufferObject::acceptRawBuffer(SharedArrayRawBuffer* buffer, size_t length) { MOZ_ASSERT(!isInitialized());"
              },
              {
                "name": "dropRawBuffer",
                "type": "method",
                "start_line": 770,
                "end_line": 778,
                "line_count": 9,
                "signature": "void SharedArrayBufferObject::dropRawBuffer() { size_t length = byteLengthOrMaxByteLength(); size_t size = SharedArrayMappedSize(isWasm(), length);"
              },
              {
                "name": "Finalize",
                "type": "method",
                "start_line": 786,
                "end_line": 799,
                "line_count": 14,
                "signature": "void SharedArrayBufferObject::Finalize(JS::GCContext* gcx, JSObject* obj) { // Must be foreground finalizable so that we can account for the object. MOZ_ASSERT(gcx->onMainThread());"
              },
              {
                "name": "addSizeOfExcludingThis",
                "type": "method",
                "start_line": 802,
                "end_line": 829,
                "line_count": 28,
                "signature": "void SharedArrayBufferObject::addSizeOfExcludingThis( JSObject* obj, mozilla::MallocSizeOf mallocSizeOf, JS::ClassInfo* info, JS::RuntimeSizes* runtimeSizes) {"
              },
              {
                "name": "copyData",
                "type": "method",
                "start_line": 832,
                "end_line": 846,
                "line_count": 15,
                "signature": "void SharedArrayBufferObject::copyData(ArrayBufferObjectMaybeShared* toBuffer, size_t toIndex, ArrayBufferObjectMaybeShared* fromBuffer,"
              },
              {
                "name": "wasmDiscard",
                "type": "method",
                "start_line": 911,
                "end_line": 916,
                "line_count": 6,
                "signature": "void SharedArrayBufferObject::wasmDiscard(Handle<SharedArrayBufferObject*> buf, uint64_t byteOffset, uint64_t byteLen) {"
              },
              {
                "name": "GetSharedArrayBufferByteLength",
                "type": "method",
                "start_line": 1000,
                "end_line": 1003,
                "line_count": 4,
                "signature": "JS_PUBLIC_API size_t JS::GetSharedArrayBufferByteLength(JSObject* obj) { auto* aobj = obj->maybeUnwrapAs<SharedArrayBufferObject>(); return aobj ? aobj->byteLength() : 0;"
              },
              {
                "name": "GetSharedArrayBufferLengthAndData",
                "type": "method",
                "start_line": 1005,
                "end_line": 1014,
                "line_count": 10,
                "signature": "JS_PUBLIC_API void JS::GetSharedArrayBufferLengthAndData(JSObject* obj, size_t* length, bool* isSharedMemory,"
              },
              {
                "name": "IsSharedArrayBufferObject",
                "type": "method",
                "start_line": 1029,
                "end_line": 1031,
                "line_count": 3,
                "signature": "JS_PUBLIC_API bool JS::IsSharedArrayBufferObject(JSObject* obj) { return obj->canUnwrapAs<SharedArrayBufferObject>(); }"
              },
              {
                "name": "ContainsSharedArrayBuffer",
                "type": "method",
                "start_line": 1043,
                "end_line": 1045,
                "line_count": 3,
                "signature": "JS_PUBLIC_API bool JS::ContainsSharedArrayBuffer(JSContext* cx) { return cx->runtime()->hasLiveSABs(); }"
              }
            ]
          },
          "hunks_count": 1,
          "hunk_ranges": [
            "@@ -331,6 @@"
          ]
        },
        {
          "commit_hash": "85d47a33200c",
          "full_hash": "85d47a33200c36a5f91f011f5713c34da79329ee",
          "parent_hash": "5860a981c750659eba0199e9ee5e45edcaa58a5a",
          "commit_type": "regressor",
          "filepath": "js/src/vm/SharedArrayObject.cpp",
          "diff_found": true,
          "diff_path": "/Users/sidiqafekrat/Mozilla_crashAnalyzer_BugBug/method2_bugzilla_bugs/outputs/step5_extracted_diffs/bug_1988694/regressor_commits/regressor_1969509_85d47a33200c/js_src_vm_SharedArrayObject.cpp.diff",
          "methods_count": 33,
          "matched_methods": {
            "fully_modified": [],
            "partially_modified": [
              {
                "name": "maxByteLengthGetterImpl",
                "type": "method",
                "start_line": 329,
                "end_line": 337,
                "line_count": 9,
                "signature": "bool SharedArrayBufferObject::maxByteLengthGetterImpl(JSContext* cx, const CallArgs& args) { MOZ_ASSERT(IsSharedArrayBuffer(args.thisv()));",
                "changed_lines": [
                  331,
                  332,
                  333,
                  334,
                  335,
                  336
                ],
                "overlap_count": 6,
                "overlap_percentage": 66.7
              }
            ],
            "unmodified": [
              {
                "name": "WasmSharedArrayAccessibleSize",
                "type": "function",
                "start_line": 40,
                "end_line": 42,
                "line_count": 3,
                "signature": "static size_t WasmSharedArrayAccessibleSize(size_t length) { return AlignBytes(length, gc::SystemPageSize()); }"
              },
              {
                "name": "NonWasmSharedArrayAllocSize",
                "type": "function",
                "start_line": 44,
                "end_line": 47,
                "line_count": 4,
                "signature": "static size_t NonWasmSharedArrayAllocSize(size_t length) { MOZ_ASSERT(length <= ArrayBufferObject::ByteLengthLimit); return sizeof(SharedArrayRawBuffer) + length;"
              },
              {
                "name": "SharedArrayMappedSize",
                "type": "function",
                "start_line": 53,
                "end_line": 60,
                "line_count": 8,
                "signature": "static size_t SharedArrayMappedSize(bool isWasm, size_t length) { // Wasm buffers use MapBufferMemory and allocate a full page for the header. // Non-Wasm buffers use malloc."
              },
              {
                "name": "wasmGrowToPagesInPlace",
                "type": "method",
                "start_line": 135,
                "end_line": 173,
                "line_count": 39,
                "signature": "bool WasmSharedArrayRawBuffer::wasmGrowToPagesInPlace(const Lock&, wasm::AddressType t, wasm::Pages newPages) {"
              },
              {
                "name": "discard",
                "type": "method",
                "start_line": 175,
                "end_line": 234,
                "line_count": 60,
                "signature": "void WasmSharedArrayRawBuffer::discard(size_t byteOffset, size_t byteLen) { SharedMem<uint8_t*> memBase = dataPointerShared(); "
              },
              {
                "name": "addReference",
                "type": "method",
                "start_line": 236,
                "end_line": 250,
                "line_count": 15,
                "signature": "bool SharedArrayRawBuffer::addReference() { MOZ_RELEASE_ASSERT(refcount_ > 0); "
              },
              {
                "name": "dropReference",
                "type": "method",
                "start_line": 252,
                "end_line": 278,
                "line_count": 27,
                "signature": "void SharedArrayRawBuffer::dropReference() { // Normally if the refcount is zero then the memory will have been unmapped // and this test may just crash, but if the memory has been retained for any"
              },
              {
                "name": "growJS",
                "type": "method",
                "start_line": 280,
                "end_line": 301,
                "line_count": 22,
                "signature": "bool SharedArrayRawBuffer::growJS(size_t newByteLength) { MOZ_ASSERT(!isWasm()); MOZ_RELEASE_ASSERT(isGrowableJS());"
              },
              {
                "name": "IsSharedArrayBuffer",
                "type": "function",
                "start_line": 303,
                "end_line": 305,
                "line_count": 3,
                "signature": "static bool IsSharedArrayBuffer(HandleValue v) { return v.isObject() && v.toObject().is<SharedArrayBufferObject>(); }"
              },
              {
                "name": "IsGrowableSharedArrayBuffer",
                "type": "function",
                "start_line": 307,
                "end_line": 309,
                "line_count": 3,
                "signature": "static bool IsGrowableSharedArrayBuffer(HandleValue v) { return v.isObject() && v.toObject().is<GrowableSharedArrayBufferObject>(); }"
              },
              {
                "name": "byteLengthGetterImpl",
                "type": "method",
                "start_line": 311,
                "end_line": 317,
                "line_count": 7,
                "signature": "MOZ_ALWAYS_INLINE bool SharedArrayBufferObject::byteLengthGetterImpl( JSContext* cx, const CallArgs& args) { MOZ_ASSERT(IsSharedArrayBuffer(args.thisv()));"
              },
              {
                "name": "byteLengthGetter",
                "type": "method",
                "start_line": 319,
                "end_line": 324,
                "line_count": 6,
                "signature": "bool SharedArrayBufferObject::byteLengthGetter(JSContext* cx, unsigned argc, Value* vp) { CallArgs args = CallArgsFromVp(argc, vp);"
              },
              {
                "name": "maxByteLengthGetter",
                "type": "method",
                "start_line": 342,
                "end_line": 348,
                "line_count": 7,
                "signature": "bool SharedArrayBufferObject::maxByteLengthGetter(JSContext* cx, unsigned argc, Value* vp) { // Steps 1-3."
              },
              {
                "name": "growableGetterImpl",
                "type": "method",
                "start_line": 353,
                "end_line": 361,
                "line_count": 9,
                "signature": "bool SharedArrayBufferObject::growableGetterImpl(JSContext* cx, const CallArgs& args) { MOZ_ASSERT(IsSharedArrayBuffer(args.thisv()));"
              },
              {
                "name": "growableGetter",
                "type": "method",
                "start_line": 366,
                "end_line": 372,
                "line_count": 7,
                "signature": "bool SharedArrayBufferObject::growableGetter(JSContext* cx, unsigned argc, Value* vp) { // Steps 1-3."
              },
              {
                "name": "growImpl",
                "type": "method",
                "start_line": 377,
                "end_line": 426,
                "line_count": 50,
                "signature": "bool SharedArrayBufferObject::growImpl(JSContext* cx, const CallArgs& args) { MOZ_ASSERT(IsGrowableSharedArrayBuffer(args.thisv())); Rooted<GrowableSharedArrayBufferObject*> buffer("
              },
              {
                "name": "grow",
                "type": "method",
                "start_line": 431,
                "end_line": 435,
                "line_count": 5,
                "signature": "bool SharedArrayBufferObject::grow(JSContext* cx, unsigned argc, Value* vp) { // Steps 1-3. CallArgs args = CallArgsFromVp(argc, vp);"
              },
              {
                "name": "IsSharedArrayBufferSpecies",
                "type": "function",
                "start_line": 437,
                "end_line": 440,
                "line_count": 4,
                "signature": "static bool IsSharedArrayBufferSpecies(JSContext* cx, JSFunction* species) { return IsSelfHostedFunctionWithName( species, cx->names().dollar_SharedArrayBufferSpecies_);"
              },
              {
                "name": "HasBuiltinSharedArrayBufferSpecies",
                "type": "function",
                "start_line": 442,
                "end_line": 462,
                "line_count": 21,
                "signature": "static bool HasBuiltinSharedArrayBufferSpecies(SharedArrayBufferObject* obj, JSContext* cx) { // Ensure `SharedArrayBuffer.prototype.constructor` and"
              },
              {
                "name": "sliceImpl",
                "type": "method",
                "start_line": 469,
                "end_line": 574,
                "line_count": 106,
                "signature": "bool SharedArrayBufferObject::sliceImpl(JSContext* cx, const CallArgs& args) { MOZ_ASSERT(IsSharedArrayBuffer(args.thisv())); "
              },
              {
                "name": "slice",
                "type": "method",
                "start_line": 581,
                "end_line": 585,
                "line_count": 5,
                "signature": "bool SharedArrayBufferObject::slice(JSContext* cx, unsigned argc, Value* vp) { // Steps 1-3. CallArgs args = CallArgsFromVp(argc, vp);"
              },
              {
                "name": "class_constructor",
                "type": "method",
                "start_line": 589,
                "end_line": 666,
                "line_count": 78,
                "signature": "bool SharedArrayBufferObject::class_constructor(JSContext* cx, unsigned argc, Value* vp) { CallArgs args = CallArgsFromVp(argc, vp);"
              },
              {
                "name": "acceptRawBuffer",
                "type": "method",
                "start_line": 755,
                "end_line": 768,
                "line_count": 14,
                "signature": "bool SharedArrayBufferObject::acceptRawBuffer(SharedArrayRawBuffer* buffer, size_t length) { MOZ_ASSERT(!isInitialized());"
              },
              {
                "name": "dropRawBuffer",
                "type": "method",
                "start_line": 770,
                "end_line": 778,
                "line_count": 9,
                "signature": "void SharedArrayBufferObject::dropRawBuffer() { size_t length = byteLengthOrMaxByteLength(); size_t size = SharedArrayMappedSize(isWasm(), length);"
              },
              {
                "name": "Finalize",
                "type": "method",
                "start_line": 786,
                "end_line": 799,
                "line_count": 14,
                "signature": "void SharedArrayBufferObject::Finalize(JS::GCContext* gcx, JSObject* obj) { // Must be foreground finalizable so that we can account for the object. MOZ_ASSERT(gcx->onMainThread());"
              },
              {
                "name": "addSizeOfExcludingThis",
                "type": "method",
                "start_line": 802,
                "end_line": 829,
                "line_count": 28,
                "signature": "void SharedArrayBufferObject::addSizeOfExcludingThis( JSObject* obj, mozilla::MallocSizeOf mallocSizeOf, JS::ClassInfo* info, JS::RuntimeSizes* runtimeSizes) {"
              },
              {
                "name": "copyData",
                "type": "method",
                "start_line": 832,
                "end_line": 846,
                "line_count": 15,
                "signature": "void SharedArrayBufferObject::copyData(ArrayBufferObjectMaybeShared* toBuffer, size_t toIndex, ArrayBufferObjectMaybeShared* fromBuffer,"
              },
              {
                "name": "wasmDiscard",
                "type": "method",
                "start_line": 911,
                "end_line": 916,
                "line_count": 6,
                "signature": "void SharedArrayBufferObject::wasmDiscard(Handle<SharedArrayBufferObject*> buf, uint64_t byteOffset, uint64_t byteLen) {"
              },
              {
                "name": "GetSharedArrayBufferByteLength",
                "type": "method",
                "start_line": 1000,
                "end_line": 1003,
                "line_count": 4,
                "signature": "JS_PUBLIC_API size_t JS::GetSharedArrayBufferByteLength(JSObject* obj) { auto* aobj = obj->maybeUnwrapAs<SharedArrayBufferObject>(); return aobj ? aobj->byteLength() : 0;"
              },
              {
                "name": "GetSharedArrayBufferLengthAndData",
                "type": "method",
                "start_line": 1005,
                "end_line": 1014,
                "line_count": 10,
                "signature": "JS_PUBLIC_API void JS::GetSharedArrayBufferLengthAndData(JSObject* obj, size_t* length, bool* isSharedMemory,"
              },
              {
                "name": "IsSharedArrayBufferObject",
                "type": "method",
                "start_line": 1029,
                "end_line": 1031,
                "line_count": 3,
                "signature": "JS_PUBLIC_API bool JS::IsSharedArrayBufferObject(JSObject* obj) { return obj->canUnwrapAs<SharedArrayBufferObject>(); }"
              },
              {
                "name": "ContainsSharedArrayBuffer",
                "type": "method",
                "start_line": 1043,
                "end_line": 1045,
                "line_count": 3,
                "signature": "JS_PUBLIC_API bool JS::ContainsSharedArrayBuffer(JSContext* cx) { return cx->runtime()->hasLiveSABs(); }"
              }
            ]
          },
          "hunks_count": 1,
          "hunk_ranges": [
            "@@ -331,6 @@"
          ]
        }
      ]
    },
    {
      "filepath": "js/src/wasm/WasmMemory.h",
      "fixing_commits": [
        {
          "commit_hash": "75d829afb4b0",
          "full_hash": "75d829afb4b06a3a8b7e91ea15c8a0cf34665fb7",
          "parent_hash": "896c8ee9171db6fb15ab84ff673c1272c46f28b2",
          "commit_type": "fixing",
          "filepath": "js/src/wasm/WasmMemory.h",
          "diff_found": true,
          "diff_path": "/Users/sidiqafekrat/Mozilla_crashAnalyzer_BugBug/method2_bugzilla_bugs/outputs/step5_extracted_diffs/bug_1988694/fixing_commit/75d829afb4b0/js_src_wasm_WasmMemory.h.diff",
          "methods_count": 9,
          "matched_methods": {
            "fully_modified": [],
            "partially_modified": [],
            "unmodified": [
              {
                "name": "ToValType",
                "type": "function",
                "start_line": 41,
                "end_line": 43,
                "line_count": 3,
                "signature": "inline ValType ToValType(AddressType at) { return at == AddressType::I64 ? ValType::I64 : ValType::I32; }"
              },
              {
                "name": "MinAddressType",
                "type": "function",
                "start_line": 45,
                "end_line": 48,
                "line_count": 4,
                "signature": "inline AddressType MinAddressType(AddressType a, AddressType b) { return (a == AddressType::I32 || b == AddressType::I32) ? AddressType::I32 : AddressType::I64;"
              },
              {
                "name": "fromByteLengthExact",
                "type": "function",
                "start_line": 68,
                "end_line": 87,
                "line_count": 20,
                "signature": "struct Pages { private: // Pages are specified by limit fields, which in general may be up to 2^48,"
              },
              {
                "name": "checkedIncrement",
                "type": "function",
                "start_line": 115,
                "end_line": 123,
                "line_count": 9,
                "signature": "bool checkedIncrement(Pages delta) { mozilla::CheckedInt<uint64_t> newValue = value_; newValue += delta.value_;"
              },
              {
                "name": "MaxMemoryBytes",
                "type": "function",
                "start_line": 139,
                "end_line": 141,
                "line_count": 3,
                "signature": "static inline size_t MaxMemoryBytes(AddressType t) { return MaxMemoryPages(t).byteLength(); }"
              },
              {
                "name": "MaxMemoryPagesValidation",
                "type": "function",
                "start_line": 149,
                "end_line": 152,
                "line_count": 4,
                "signature": "static inline uint64_t MaxMemoryPagesValidation(AddressType addressType) { return addressType == AddressType::I32 ? MaxMemory32PagesValidation : MaxMemory64PagesValidation;"
              },
              {
                "name": "MaxTableElemsValidation",
                "type": "function",
                "start_line": 154,
                "end_line": 157,
                "line_count": 4,
                "signature": "static inline uint64_t MaxTableElemsValidation(AddressType addressType) { return addressType == AddressType::I32 ? MaxTable32ElemsValidation : MaxTable64ElemsValidation;"
              },
              {
                "name": "MemoryBoundsCheck",
                "type": "function",
                "start_line": 225,
                "end_line": 229,
                "line_count": 5,
                "signature": "static inline bool MemoryBoundsCheck(uint32_t offset, uint32_t len, size_t memLen) { uint64_t offsetLimit = uint64_t(offset) + uint64_t(len);"
              },
              {
                "name": "MemoryBoundsCheck",
                "type": "function",
                "start_line": 233,
                "end_line": 239,
                "line_count": 7,
                "signature": "static inline bool MemoryBoundsCheck(uint64_t offset, uint64_t len, size_t memLen) { uint64_t offsetLimit = offset + len;"
              }
            ]
          },
          "hunks_count": 1,
          "hunk_ranges": [
            "@@ -102,13 @@"
          ]
        }
      ],
      "regressor_commits": [
        {
          "commit_hash": "75d829afb4b0",
          "full_hash": "75d829afb4b06a3a8b7e91ea15c8a0cf34665fb7",
          "parent_hash": "896c8ee9171db6fb15ab84ff673c1272c46f28b2",
          "commit_type": "regressor",
          "filepath": "js/src/wasm/WasmMemory.h",
          "diff_found": true,
          "diff_path": "/Users/sidiqafekrat/Mozilla_crashAnalyzer_BugBug/method2_bugzilla_bugs/outputs/step5_extracted_diffs/bug_1988694/regressor_commits/regressor_1969509_75d829afb4b0/js_src_wasm_WasmMemory.h.diff",
          "methods_count": 9,
          "matched_methods": {
            "fully_modified": [],
            "partially_modified": [],
            "unmodified": [
              {
                "name": "ToValType",
                "type": "function",
                "start_line": 41,
                "end_line": 43,
                "line_count": 3,
                "signature": "inline ValType ToValType(AddressType at) { return at == AddressType::I64 ? ValType::I64 : ValType::I32; }"
              },
              {
                "name": "MinAddressType",
                "type": "function",
                "start_line": 45,
                "end_line": 48,
                "line_count": 4,
                "signature": "inline AddressType MinAddressType(AddressType a, AddressType b) { return (a == AddressType::I32 || b == AddressType::I32) ? AddressType::I32 : AddressType::I64;"
              },
              {
                "name": "fromByteLengthExact",
                "type": "function",
                "start_line": 68,
                "end_line": 87,
                "line_count": 20,
                "signature": "struct Pages { private: // Pages are specified by limit fields, which in general may be up to 2^48,"
              },
              {
                "name": "checkedIncrement",
                "type": "function",
                "start_line": 115,
                "end_line": 123,
                "line_count": 9,
                "signature": "bool checkedIncrement(Pages delta) { mozilla::CheckedInt<uint64_t> newValue = value_; newValue += delta.value_;"
              },
              {
                "name": "MaxMemoryBytes",
                "type": "function",
                "start_line": 139,
                "end_line": 141,
                "line_count": 3,
                "signature": "static inline size_t MaxMemoryBytes(AddressType t) { return MaxMemoryPages(t).byteLength(); }"
              },
              {
                "name": "MaxMemoryPagesValidation",
                "type": "function",
                "start_line": 149,
                "end_line": 152,
                "line_count": 4,
                "signature": "static inline uint64_t MaxMemoryPagesValidation(AddressType addressType) { return addressType == AddressType::I32 ? MaxMemory32PagesValidation : MaxMemory64PagesValidation;"
              },
              {
                "name": "MaxTableElemsValidation",
                "type": "function",
                "start_line": 154,
                "end_line": 157,
                "line_count": 4,
                "signature": "static inline uint64_t MaxTableElemsValidation(AddressType addressType) { return addressType == AddressType::I32 ? MaxTable32ElemsValidation : MaxTable64ElemsValidation;"
              },
              {
                "name": "MemoryBoundsCheck",
                "type": "function",
                "start_line": 225,
                "end_line": 229,
                "line_count": 5,
                "signature": "static inline bool MemoryBoundsCheck(uint32_t offset, uint32_t len, size_t memLen) { uint64_t offsetLimit = uint64_t(offset) + uint64_t(len);"
              },
              {
                "name": "MemoryBoundsCheck",
                "type": "function",
                "start_line": 233,
                "end_line": 239,
                "line_count": 7,
                "signature": "static inline bool MemoryBoundsCheck(uint64_t offset, uint64_t len, size_t memLen) { uint64_t offsetLimit = offset + len;"
              }
            ]
          },
          "hunks_count": 1,
          "hunk_ranges": [
            "@@ -102,13 @@"
          ]
        },
        {
          "commit_hash": "13b7086f65cb",
          "full_hash": "13b7086f65cbbbf1fed6e0341cfbdfb309fb962c",
          "parent_hash": "f7c96ac82c1aa9ff1f1a873b6d15ac9c3900b05d",
          "commit_type": "regressor",
          "filepath": "js/src/wasm/WasmMemory.h",
          "diff_found": true,
          "diff_path": "/Users/sidiqafekrat/Mozilla_crashAnalyzer_BugBug/method2_bugzilla_bugs/outputs/step5_extracted_diffs/bug_1988694/regressor_commits/regressor_1969509_13b7086f65cb/js_src_wasm_WasmMemory.h.diff",
          "methods_count": 9,
          "matched_methods": {
            "fully_modified": [],
            "partially_modified": [],
            "unmodified": [
              {
                "name": "ToValType",
                "type": "function",
                "start_line": 41,
                "end_line": 43,
                "line_count": 3,
                "signature": "inline ValType ToValType(AddressType at) { return at == AddressType::I64 ? ValType::I64 : ValType::I32; }"
              },
              {
                "name": "MinAddressType",
                "type": "function",
                "start_line": 45,
                "end_line": 48,
                "line_count": 4,
                "signature": "inline AddressType MinAddressType(AddressType a, AddressType b) { return (a == AddressType::I32 || b == AddressType::I32) ? AddressType::I32 : AddressType::I64;"
              },
              {
                "name": "fromByteLengthExact",
                "type": "function",
                "start_line": 68,
                "end_line": 87,
                "line_count": 20,
                "signature": "struct Pages { private: // Pages are specified by limit fields, which in general may be up to 2^48,"
              },
              {
                "name": "checkedIncrement",
                "type": "function",
                "start_line": 108,
                "end_line": 116,
                "line_count": 9,
                "signature": "bool checkedIncrement(Pages delta) { mozilla::CheckedInt<uint64_t> newValue = value_; newValue += delta.value_;"
              },
              {
                "name": "MaxMemoryBytes",
                "type": "function",
                "start_line": 132,
                "end_line": 134,
                "line_count": 3,
                "signature": "static inline size_t MaxMemoryBytes(AddressType t) { return MaxMemoryPages(t).byteLength(); }"
              },
              {
                "name": "MaxMemoryPagesValidation",
                "type": "function",
                "start_line": 142,
                "end_line": 145,
                "line_count": 4,
                "signature": "static inline uint64_t MaxMemoryPagesValidation(AddressType addressType) { return addressType == AddressType::I32 ? MaxMemory32PagesValidation : MaxMemory64PagesValidation;"
              },
              {
                "name": "MaxTableElemsValidation",
                "type": "function",
                "start_line": 147,
                "end_line": 150,
                "line_count": 4,
                "signature": "static inline uint64_t MaxTableElemsValidation(AddressType addressType) { return addressType == AddressType::I32 ? MaxTable32ElemsValidation : MaxTable64ElemsValidation;"
              },
              {
                "name": "MemoryBoundsCheck",
                "type": "function",
                "start_line": 218,
                "end_line": 222,
                "line_count": 5,
                "signature": "static inline bool MemoryBoundsCheck(uint32_t offset, uint32_t len, size_t memLen) { uint64_t offsetLimit = uint64_t(offset) + uint64_t(len);"
              },
              {
                "name": "MemoryBoundsCheck",
                "type": "function",
                "start_line": 226,
                "end_line": 232,
                "line_count": 7,
                "signature": "static inline bool MemoryBoundsCheck(uint64_t offset, uint64_t len, size_t memLen) { uint64_t offsetLimit = offset + len;"
              }
            ]
          },
          "hunks_count": 1,
          "hunk_ranges": [
            "@@ -102,6 @@"
          ]
        },
        {
          "commit_hash": "85d47a33200c",
          "full_hash": "85d47a33200c36a5f91f011f5713c34da79329ee",
          "parent_hash": "5860a981c750659eba0199e9ee5e45edcaa58a5a",
          "commit_type": "regressor",
          "filepath": "js/src/wasm/WasmMemory.h",
          "diff_found": true,
          "diff_path": "/Users/sidiqafekrat/Mozilla_crashAnalyzer_BugBug/method2_bugzilla_bugs/outputs/step5_extracted_diffs/bug_1988694/regressor_commits/regressor_1969509_85d47a33200c/js_src_wasm_WasmMemory.h.diff",
          "methods_count": 9,
          "matched_methods": {
            "fully_modified": [],
            "partially_modified": [],
            "unmodified": [
              {
                "name": "ToValType",
                "type": "function",
                "start_line": 41,
                "end_line": 43,
                "line_count": 3,
                "signature": "inline ValType ToValType(AddressType at) { return at == AddressType::I64 ? ValType::I64 : ValType::I32; }"
              },
              {
                "name": "MinAddressType",
                "type": "function",
                "start_line": 45,
                "end_line": 48,
                "line_count": 4,
                "signature": "inline AddressType MinAddressType(AddressType a, AddressType b) { return (a == AddressType::I32 || b == AddressType::I32) ? AddressType::I32 : AddressType::I64;"
              },
              {
                "name": "fromByteLengthExact",
                "type": "function",
                "start_line": 68,
                "end_line": 87,
                "line_count": 20,
                "signature": "struct Pages { private: // Pages are specified by limit fields, which in general may be up to 2^48,"
              },
              {
                "name": "checkedIncrement",
                "type": "function",
                "start_line": 108,
                "end_line": 116,
                "line_count": 9,
                "signature": "bool checkedIncrement(Pages delta) { mozilla::CheckedInt<uint64_t> newValue = value_; newValue += delta.value_;"
              },
              {
                "name": "MaxMemoryBytes",
                "type": "function",
                "start_line": 132,
                "end_line": 134,
                "line_count": 3,
                "signature": "static inline size_t MaxMemoryBytes(AddressType t) { return MaxMemoryPages(t).byteLength(); }"
              },
              {
                "name": "MaxMemoryPagesValidation",
                "type": "function",
                "start_line": 142,
                "end_line": 145,
                "line_count": 4,
                "signature": "static inline uint64_t MaxMemoryPagesValidation(AddressType addressType) { return addressType == AddressType::I32 ? MaxMemory32PagesValidation : MaxMemory64PagesValidation;"
              },
              {
                "name": "MaxTableElemsValidation",
                "type": "function",
                "start_line": 147,
                "end_line": 150,
                "line_count": 4,
                "signature": "static inline uint64_t MaxTableElemsValidation(AddressType addressType) { return addressType == AddressType::I32 ? MaxTable32ElemsValidation : MaxTable64ElemsValidation;"
              },
              {
                "name": "MemoryBoundsCheck",
                "type": "function",
                "start_line": 218,
                "end_line": 222,
                "line_count": 5,
                "signature": "static inline bool MemoryBoundsCheck(uint32_t offset, uint32_t len, size_t memLen) { uint64_t offsetLimit = uint64_t(offset) + uint64_t(len);"
              },
              {
                "name": "MemoryBoundsCheck",
                "type": "function",
                "start_line": 226,
                "end_line": 232,
                "line_count": 7,
                "signature": "static inline bool MemoryBoundsCheck(uint64_t offset, uint64_t len, size_t memLen) { uint64_t offsetLimit = offset + len;"
              }
            ]
          },
          "hunks_count": 1,
          "hunk_ranges": [
            "@@ -102,6 @@"
          ]
        }
      ]
    }
  ],
  "summary": {
    "total_files": 4,
    "total_commits": 16,
    "diffs_found": 16,
    "methods_fully_modified": 0,
    "methods_partially_modified": 8,
    "methods_unmodified": 632
  }
}